/* tslint:disable */
/* eslint-disable */
/**
 * Munchi Super Server Api
 * The Munchi API description
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AblyBusinessEventPayloadDto
 */
export interface AblyBusinessEventPayloadDto {
    /**
     * 
     * @type {string}
     * @memberof AblyBusinessEventPayloadDto
     */
    'action': ActionEnum;
    /**
     * 
     * @type {string}
     * @memberof AblyBusinessEventPayloadDto
     */
    'entityType': EntityTypeEnum;
    /**
     * 
     * @type {object}
     * @memberof AblyBusinessEventPayloadDto
     */
    'entityId': object;
    /**
     * 
     * @type {object}
     * @memberof AblyBusinessEventPayloadDto
     */
    'businessId': object;
    /**
     * 
     * @type {ProviderEnum}
     * @memberof AblyBusinessEventPayloadDto
     */
    'channel': ProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof AblyBusinessEventPayloadDto
     */
    'timestamp': string;
    /**
     * 
     * @type {object}
     * @memberof AblyBusinessEventPayloadDto
     */
    'productUpdates'?: object;
}

export const ActionEnum = {
    ProductUpdated: 'PRODUCT_UPDATED',
    ProductDeleted: 'PRODUCT_DELETED',
    MenuUpdated: 'MENU_UPDATED',
    CategoryUpdated: 'CATEGORY_UPDATED',
    ExtraUpdated: 'EXTRA_UPDATED',
    ExtraDeleted: 'EXTRA_DELETED',
    OptionUpdated: 'OPTION_UPDATED',
    OptionDeleted: 'OPTION_DELETED',
    SuboptionUpdated: 'SUBOPTION_UPDATED',
    SuboptionDeleted: 'SUBOPTION_DELETED',
    SiteUpdated: 'SITE_UPDATED',
    CategoryDeleted: 'CATEGORY_DELETED',
    ProductCreated: 'PRODUCT_CREATED',
    BusinessConfigUpdated: 'BUSINESS_CONFIG_UPDATED',
    DataSyncRequired: 'data_sync_required',
    PosSessionUpdated: 'pos_session_updated'
} as const;

export type ActionEnum = typeof ActionEnum[keyof typeof ActionEnum];
export const EntityTypeEnum = {
    Product: 'product',
    Menu: 'menu',
    Category: 'category',
    Extra: 'extra',
    Option: 'option',
    Role: 'role',
    Shift: 'shift',
    Employee: 'employee'
} as const;

export type EntityTypeEnum = typeof EntityTypeEnum[keyof typeof EntityTypeEnum];

/**
 * 
 * @export
 * @interface AcceptOrderDto
 */
export interface AcceptOrderDto {
    /**
     * Unique identifier for the order
     * @type {string}
     * @memberof AcceptOrderDto
     */
    'orderId': string;
    /**
     * ID of the business updating the order
     * @type {number}
     * @memberof AcceptOrderDto
     */
    'orderingBusinessId': number;
    /**
     * 
     * @type {ProviderEnum}
     * @memberof AcceptOrderDto
     */
    'provider': ProviderEnum;
    /**
     * Time of acceptance if applicable
     * @type {number}
     * @memberof AcceptOrderDto
     */
    'preparedIn'?: number;
}


/**
 * 
 * @export
 * @interface AccountFundingTransactionDetails
 */
export interface AccountFundingTransactionDetails {
    /**
     * Transaction category for Account Funding Transactions.
     * @type {string}
     * @memberof AccountFundingTransactionDetails
     */
    'transactionCategory'?: string;
    /**
     * Payment type for Account Funding Transactions.
     * @type {string}
     * @memberof AccountFundingTransactionDetails
     */
    'paymentType': string;
    /**
     * Purpose of the transaction.
     * @type {string}
     * @memberof AccountFundingTransactionDetails
     */
    'transactionPurpose'?: string;
    /**
     * A reference number for the sender.
     * @type {string}
     * @memberof AccountFundingTransactionDetails
     */
    'senderReferenceNumber': string;
    /**
     * The sender\'s name.
     * @type {string}
     * @memberof AccountFundingTransactionDetails
     */
    'senderName'?: string;
    /**
     * The sender\'s city.
     * @type {string}
     * @memberof AccountFundingTransactionDetails
     */
    'senderCity'?: string;
    /**
     * The sender\'s state.
     * @type {string}
     * @memberof AccountFundingTransactionDetails
     */
    'senderState'?: string;
    /**
     * The sender\'s country in NOR-3166-1 alpha-3 format.
     * @type {string}
     * @memberof AccountFundingTransactionDetails
     */
    'senderCountry'?: string;
    /**
     * The sender\'s street address.
     * @type {string}
     * @memberof AccountFundingTransactionDetails
     */
    'senderStreetAddress'?: string;
    /**
     * Source of funds.
     * @type {string}
     * @memberof AccountFundingTransactionDetails
     */
    'sourceOfFunds'?: string;
    /**
     * The recipient\'s name.
     * @type {string}
     * @memberof AccountFundingTransactionDetails
     */
    'recipientName'?: string;
    /**
     * The recipient\'s account number (e.g., IBAN).
     * @type {string}
     * @memberof AccountFundingTransactionDetails
     */
    'recipientAccount'?: string;
    /**
     * The type of the recipient account number.
     * @type {string}
     * @memberof AccountFundingTransactionDetails
     */
    'recipientAccountNumberType'?: string;
    /**
     * The legal business name of the acceptor.
     * @type {string}
     * @memberof AccountFundingTransactionDetails
     */
    'acceptorLegalBusinessName'?: string;
    /**
     * Any markup fee applied by the merchant.
     * @type {string}
     * @memberof AccountFundingTransactionDetails
     */
    'merchantMarkupFee'?: string;
}
/**
 * 
 * @export
 * @interface ActionPasscodeResponseDto
 */
export interface ActionPasscodeResponseDto {
    /**
     * 
     * @type {string}
     * @memberof ActionPasscodeResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ActionPasscodeResponseDto
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof ActionPasscodeResponseDto
     */
    'businessId'?: object | null;
    /**
     * 
     * @type {object}
     * @memberof ActionPasscodeResponseDto
     */
    'merchantId'?: object | null;
    /**
     * 
     * @type {Array<PermissionRuleResponseDto>}
     * @memberof ActionPasscodeResponseDto
     */
    'permissionRules': Array<PermissionRuleResponseDto>;
}
/**
 * 
 * @export
 * @interface AdditionalConfigDto
 */
export interface AdditionalConfigDto {
    /**
     * Viva merchant id
     * @type {string}
     * @memberof AdditionalConfigDto
     */
    'merchantId'?: string | null;
    /**
     * Viva source code
     * @type {string}
     * @memberof AdditionalConfigDto
     */
    'sourceCode'?: string | null;
}
/**
 * 
 * @export
 * @interface AdminPaginationDto
 */
export interface AdminPaginationDto {
    /**
     * 
     * @type {number}
     * @memberof AdminPaginationDto
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof AdminPaginationDto
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof AdminPaginationDto
     */
    'total_pages': number;
    /**
     * 
     * @type {boolean}
     * @memberof AdminPaginationDto
     */
    'has_previous': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AdminPaginationDto
     */
    'has_next': boolean;
}
/**
 * 
 * @export
 * @interface AdminTransactionDto
 */
export interface AdminTransactionDto {
    /**
     * 
     * @type {number}
     * @memberof AdminTransactionDto
     */
    'transaction_id': number;
    /**
     * 
     * @type {number}
     * @memberof AdminTransactionDto
     */
    'admin_action_id': number;
    /**
     * 
     * @type {string}
     * @memberof AdminTransactionDto
     */
    'admin_user_name': string;
    /**
     * 
     * @type {string}
     * @memberof AdminTransactionDto
     */
    'admin_user_phone': string;
    /**
     * 
     * @type {string}
     * @memberof AdminTransactionDto
     */
    'target_user_name': string;
    /**
     * 
     * @type {string}
     * @memberof AdminTransactionDto
     */
    'target_user_phone': string;
    /**
     * 
     * @type {number}
     * @memberof AdminTransactionDto
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof AdminTransactionDto
     */
    'event_type': EventTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AdminTransactionDto
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof AdminTransactionDto
     */
    'created_at': string;
}

export const EventTypeEnum = {
    Earn: 'earn',
    Redeem: 'redeem',
    Collect: 'collect',
    Credit: 'credit',
    Debit: 'debit',
    Claimed: 'claimed'
} as const;

export type EventTypeEnum = typeof EventTypeEnum[keyof typeof EventTypeEnum];

/**
 * 
 * @export
 * @interface AdminTransactionResponseDto
 */
export interface AdminTransactionResponseDto {
    /**
     * 
     * @type {Array<AdminTransactionDto>}
     * @memberof AdminTransactionResponseDto
     */
    'data': Array<AdminTransactionDto>;
    /**
     * 
     * @type {AdminPaginationDto}
     * @memberof AdminTransactionResponseDto
     */
    'pagination': AdminPaginationDto;
}
/**
 * 
 * @export
 * @interface AffirmDetailsDto
 */
export interface AffirmDetailsDto {
    /**
     * Payment location
     * @type {string}
     * @memberof AffirmDetailsDto
     */
    'location'?: string | null;
    /**
     * Reader identifier
     * @type {string}
     * @memberof AffirmDetailsDto
     */
    'reader'?: string | null;
    /**
     * Affirm transaction ID
     * @type {string}
     * @memberof AffirmDetailsDto
     */
    'transactionId'?: string | null;
}
/**
 * 
 * @export
 * @interface AmountDetailsDto
 */
export interface AmountDetailsDto {
    /**
     * 
     * @type {AmountDetailsDtoTip}
     * @memberof AmountDetailsDto
     */
    'tip': AmountDetailsDtoTip;
}
/**
 * Tip amount details
 * @export
 * @interface AmountDetailsDtoTip
 */
export interface AmountDetailsDtoTip {
    /**
     * Amount value in smallest currency unit
     * @type {number}
     * @memberof AmountDetailsDtoTip
     */
    'value': number;
    /**
     * Currency code
     * @type {string}
     * @memberof AmountDetailsDtoTip
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface AmountDto
 */
export interface AmountDto {
    /**
     * Amount value in smallest currency unit
     * @type {number}
     * @memberof AmountDto
     */
    'value': number;
    /**
     * Currency code
     * @type {string}
     * @memberof AmountDto
     */
    'currency': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BusinessBackgroundType = {
    Image: 'image',
    Video: 'video',
    Animation: 'animation'
} as const;

export type BusinessBackgroundType = typeof BusinessBackgroundType[keyof typeof BusinessBackgroundType];


/**
 * 
 * @export
 * @interface BusinessCategoryBodyDto
 */
export interface BusinessCategoryBodyDto {
    /**
     * Array of category IDs
     * @type {Array<number>}
     * @memberof BusinessCategoryBodyDto
     */
    'cid': Array<number>;
}
/**
 * 
 * @export
 * @interface BusinessConfigResponseDto
 */
export interface BusinessConfigResponseDto {
    /**
     * 
     * @type {string}
     * @memberof BusinessConfigResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessConfigResponseDto
     */
    'timeZone': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessConfigResponseDto
     */
    'currency': string;
    /**
     * 
     * @type {BusinessConfigResponseDtoBusiness}
     * @memberof BusinessConfigResponseDto
     */
    'business': BusinessConfigResponseDtoBusiness;
    /**
     * 
     * @type {string}
     * @memberof BusinessConfigResponseDto
     */
    'locationId': string;
    /**
     * 
     * @type {number}
     * @memberof BusinessConfigResponseDto
     */
    'orderingBusinessId': number;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof BusinessConfigResponseDto
     */
    'selectedPaymentProvider'?: PaymentProvider | null;
    /**
     * 
     * @type {Array<PaymentProviderResponseDto>}
     * @memberof BusinessConfigResponseDto
     */
    'paymentProviders': Array<PaymentProviderResponseDto>;
    /**
     * 
     * @type {Array<PaymentMethodsResponseDto>}
     * @memberof BusinessConfigResponseDto
     */
    'paymentMethods': Array<PaymentMethodsResponseDto>;
    /**
     * 
     * @type {string}
     * @memberof BusinessConfigResponseDto
     */
    'companyName'?: string | null;
    /**
     * Active payment integrations for the business (e.g. GiftCard)
     * @type {Array<PaymentIntegrationDto>}
     * @memberof BusinessConfigResponseDto
     */
    'paymentIntegrations'?: Array<PaymentIntegrationDto>;
    /**
     * Indicates if the business has a loyalty program linked
     * @type {boolean}
     * @memberof BusinessConfigResponseDto
     */
    'hasLoyaltyProgram': boolean;
    /**
     * Indicates if the business has a invoice company linked
     * @type {boolean}
     * @memberof BusinessConfigResponseDto
     */
    'hasInvoiceCompany': boolean;
}


/**
 * Business data attached
 * @export
 * @interface BusinessConfigResponseDtoBusiness
 */
export interface BusinessConfigResponseDtoBusiness {
    /**
     * Unique identifier of the business
     * @type {string}
     * @memberof BusinessConfigResponseDtoBusiness
     */
    'id': string;
    /**
     * Name of the business
     * @type {string}
     * @memberof BusinessConfigResponseDtoBusiness
     */
    'name': string;
    /**
     * Logo of the business
     * @type {string}
     * @memberof BusinessConfigResponseDtoBusiness
     */
    'logo': string;
    /**
     * Email of the business
     * @type {string}
     * @memberof BusinessConfigResponseDtoBusiness
     */
    'email'?: string;
    /**
     * Address of the business
     * @type {string}
     * @memberof BusinessConfigResponseDtoBusiness
     */
    'address'?: string;
    /**
     * Creation date of the business
     * @type {string}
     * @memberof BusinessConfigResponseDtoBusiness
     */
    'createdAt': string;
    /**
     * Time zone of the business
     * @type {string}
     * @memberof BusinessConfigResponseDtoBusiness
     */
    'timeZone': string;
    /**
     * Currency used by the business
     * @type {string}
     * @memberof BusinessConfigResponseDtoBusiness
     */
    'currency': string;
    /**
     * Phone number of the business
     * @type {string}
     * @memberof BusinessConfigResponseDtoBusiness
     */
    'phone'?: string;
    /**
     * Ordering business identifier
     * @type {number}
     * @memberof BusinessConfigResponseDtoBusiness
     */
    'orderingBusinessId': number;
    /**
     * BIC/SWIFT code of the business
     * @type {string}
     * @memberof BusinessConfigResponseDtoBusiness
     */
    'bic': string | null;
    /**
     * Whether the business is enabled
     * @type {boolean}
     * @memberof BusinessConfigResponseDtoBusiness
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof BusinessConfigResponseDtoBusiness
     */
    'chainId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessConfigResponseDtoBusiness
     */
    'merchantId'?: string;
}
/**
 * 
 * @export
 * @interface BusinessDetail
 */
export interface BusinessDetail {
    /**
     * Legal business address
     * @type {string}
     * @memberof BusinessDetail
     */
    'address': string;
    /**
     * Business Identity Code
     * @type {string}
     * @memberof BusinessDetail
     */
    'identityCode': string | null;
    /**
     * Timezone of the business
     * @type {string}
     * @memberof BusinessDetail
     */
    'timezone': string;
}
/**
 * 
 * @export
 * @interface BusinessDiscountDto
 */
export interface BusinessDiscountDto {
    /**
     * Discount ID
     * @type {number}
     * @memberof BusinessDiscountDto
     */
    'id': number;
    /**
     * Ordering business ID
     * @type {number}
     * @memberof BusinessDiscountDto
     */
    'business_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BusinessDiscountDto
     */
    'name': string;
    /**
     * Discount value (amount or percentage depending on type)
     * @type {number}
     * @memberof BusinessDiscountDto
     */
    'value': number;
    /**
     * 
     * @type {DiscountType}
     * @memberof BusinessDiscountDto
     */
    'type'?: DiscountType;
    /**
     * 
     * @type {string}
     * @memberof BusinessDiscountDto
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BusinessDiscountDto
     */
    'available'?: boolean;
}


/**
 * 
 * @export
 * @interface BusinessDto
 */
export interface BusinessDto {
    /**
     * Unique identifier of the business
     * @type {string}
     * @memberof BusinessDto
     */
    'id': string;
    /**
     * Name of the business
     * @type {string}
     * @memberof BusinessDto
     */
    'name': string;
    /**
     * Logo of the business
     * @type {string}
     * @memberof BusinessDto
     */
    'logo': string;
    /**
     * Email of the business
     * @type {string}
     * @memberof BusinessDto
     */
    'email'?: string;
    /**
     * Address of the business
     * @type {string}
     * @memberof BusinessDto
     */
    'address'?: string;
    /**
     * Creation date of the business
     * @type {string}
     * @memberof BusinessDto
     */
    'createdAt': string;
    /**
     * Time zone of the business
     * @type {string}
     * @memberof BusinessDto
     */
    'timeZone': string;
    /**
     * Currency used by the business
     * @type {string}
     * @memberof BusinessDto
     */
    'currency': string;
    /**
     * Phone number of the business
     * @type {string}
     * @memberof BusinessDto
     */
    'phone'?: string;
    /**
     * Ordering business identifier
     * @type {number}
     * @memberof BusinessDto
     */
    'orderingBusinessId': number;
    /**
     * BIC/SWIFT code of the business
     * @type {string}
     * @memberof BusinessDto
     */
    'bic': string | null;
    /**
     * Whether the business is enabled
     * @type {boolean}
     * @memberof BusinessDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof BusinessDto
     */
    'chainId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessDto
     */
    'merchantId'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BusinessEventAction = {
    ProductUpdated: 'PRODUCT_UPDATED',
    ProductDeleted: 'PRODUCT_DELETED',
    MenuUpdated: 'MENU_UPDATED',
    CategoryUpdated: 'CATEGORY_UPDATED',
    ExtraUpdated: 'EXTRA_UPDATED',
    ExtraDeleted: 'EXTRA_DELETED',
    OptionUpdated: 'OPTION_UPDATED',
    OptionDeleted: 'OPTION_DELETED',
    SuboptionUpdated: 'SUBOPTION_UPDATED',
    SuboptionDeleted: 'SUBOPTION_DELETED',
    SiteUpdated: 'SITE_UPDATED',
    CategoryDeleted: 'CATEGORY_DELETED',
    ProductCreated: 'PRODUCT_CREATED',
    BusinessConfigUpdated: 'BUSINESS_CONFIG_UPDATED',
    DataSyncRequired: 'data_sync_required',
    PosSessionUpdated: 'pos_session_updated'
} as const;

export type BusinessEventAction = typeof BusinessEventAction[keyof typeof BusinessEventAction];


/**
 * 
 * @export
 * @enum {string}
 */

export const BusinessEventType = {
    StatusUpdated: 'business:status-updated',
    MenuUpdated: 'business:menu-updated',
    ConfigUpdated: 'business:config-updated'
} as const;

export type BusinessEventType = typeof BusinessEventType[keyof typeof BusinessEventType];


/**
 * 
 * @export
 * @interface BusinessInfoResponseDto
 */
export interface BusinessInfoResponseDto {
    /**
     * The ID of the business
     * @type {number}
     * @memberof BusinessInfoResponseDto
     */
    'businessId': number;
    /**
     * The name of the business
     * @type {string}
     * @memberof BusinessInfoResponseDto
     */
    'businessName': string;
    /**
     * The URL of the business logo
     * @type {string}
     * @memberof BusinessInfoResponseDto
     */
    'logoUrl': string | null;
    /**
     * The phone of the business
     * @type {string}
     * @memberof BusinessInfoResponseDto
     */
    'phone'?: string | null;
    /**
     * 
     * @type {BusinessInfoResponseDtoLoyaltyPlan}
     * @memberof BusinessInfoResponseDto
     */
    'loyaltyPlan': BusinessInfoResponseDtoLoyaltyPlan | null;
    /**
     * 
     * @type {BusinessInfoResponseDtoDetail}
     * @memberof BusinessInfoResponseDto
     */
    'detail': BusinessInfoResponseDtoDetail;
    /**
     * Email address of the business
     * @type {string}
     * @memberof BusinessInfoResponseDto
     */
    'businessEmail': string | null;
}
/**
 * Business details
 * @export
 * @interface BusinessInfoResponseDtoDetail
 */
export interface BusinessInfoResponseDtoDetail {
    /**
     * Legal business address
     * @type {string}
     * @memberof BusinessInfoResponseDtoDetail
     */
    'address': string;
    /**
     * Business Identity Code
     * @type {string}
     * @memberof BusinessInfoResponseDtoDetail
     */
    'identityCode': string | null;
    /**
     * Timezone of the business
     * @type {string}
     * @memberof BusinessInfoResponseDtoDetail
     */
    'timezone': string;
}
/**
 * The loyalty plan of the business
 * @export
 * @interface BusinessInfoResponseDtoLoyaltyPlan
 */
export interface BusinessInfoResponseDtoLoyaltyPlan {
    /**
     * Unique identifier for the business loyalty plan
     * @type {number}
     * @memberof BusinessInfoResponseDtoLoyaltyPlan
     */
    'id': number;
    /**
     * ID of the business this loyalty plan belongs to
     * @type {number}
     * @memberof BusinessInfoResponseDtoLoyaltyPlan
     */
    'business_id': number;
    /**
     * ID of the associated loyalty plan
     * @type {number}
     * @memberof BusinessInfoResponseDtoLoyaltyPlan
     */
    'loyalty_plan_id': number;
    /**
     * Whether points can be redeemed in this plan
     * @type {boolean}
     * @memberof BusinessInfoResponseDtoLoyaltyPlan
     */
    'redeems': boolean;
    /**
     * Whether points can be accumulated in this plan
     * @type {boolean}
     * @memberof BusinessInfoResponseDtoLoyaltyPlan
     */
    'accumulates': boolean;
    /**
     * The rate at which points can be redeemed (null if not applicable)
     * @type {number}
     * @memberof BusinessInfoResponseDtoLoyaltyPlan
     */
    'redemption_rate': number | null;
    /**
     * The rate at which points are accumulated per dollar spent (null if not applicable)
     * @type {number}
     * @memberof BusinessInfoResponseDtoLoyaltyPlan
     */
    'accumulation_rate': number | null;
    /**
     * Type of maximum redemption limit
     * @type {string}
     * @memberof BusinessInfoResponseDtoLoyaltyPlan
     */
    'maximum_redemption_type': string | null;
    /**
     * Maximum redemption rate if applicable
     * @type {number}
     * @memberof BusinessInfoResponseDtoLoyaltyPlan
     */
    'maximum_redemption_rate': number | null;
    /**
     * Maximum points that can be accumulated
     * @type {number}
     * @memberof BusinessInfoResponseDtoLoyaltyPlan
     */
    'maximum_accumulation': number | null;
    /**
     * Time in minutes after which points expire
     * @type {number}
     * @memberof BusinessInfoResponseDtoLoyaltyPlan
     */
    'expire_after_minutes': number | null;
}
/**
 * 
 * @export
 * @interface BusinessLoyaltyPlan
 */
export interface BusinessLoyaltyPlan {
    /**
     * Unique identifier for the business loyalty plan
     * @type {number}
     * @memberof BusinessLoyaltyPlan
     */
    'id': number;
    /**
     * ID of the business this loyalty plan belongs to
     * @type {number}
     * @memberof BusinessLoyaltyPlan
     */
    'business_id': number;
    /**
     * ID of the associated loyalty plan
     * @type {number}
     * @memberof BusinessLoyaltyPlan
     */
    'loyalty_plan_id': number;
    /**
     * Whether points can be redeemed in this plan
     * @type {boolean}
     * @memberof BusinessLoyaltyPlan
     */
    'redeems': boolean;
    /**
     * Whether points can be accumulated in this plan
     * @type {boolean}
     * @memberof BusinessLoyaltyPlan
     */
    'accumulates': boolean;
    /**
     * The rate at which points can be redeemed (null if not applicable)
     * @type {number}
     * @memberof BusinessLoyaltyPlan
     */
    'redemption_rate': number | null;
    /**
     * The rate at which points are accumulated per dollar spent (null if not applicable)
     * @type {number}
     * @memberof BusinessLoyaltyPlan
     */
    'accumulation_rate': number | null;
    /**
     * Type of maximum redemption limit
     * @type {string}
     * @memberof BusinessLoyaltyPlan
     */
    'maximum_redemption_type': string | null;
    /**
     * Maximum redemption rate if applicable
     * @type {number}
     * @memberof BusinessLoyaltyPlan
     */
    'maximum_redemption_rate': number | null;
    /**
     * Maximum points that can be accumulated
     * @type {number}
     * @memberof BusinessLoyaltyPlan
     */
    'maximum_accumulation': number | null;
    /**
     * Time in minutes after which points expire
     * @type {number}
     * @memberof BusinessLoyaltyPlan
     */
    'expire_after_minutes': number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BusinessPaymentIntegrationType = {
    GiftCard: 'GiftCard'
} as const;

export type BusinessPaymentIntegrationType = typeof BusinessPaymentIntegrationType[keyof typeof BusinessPaymentIntegrationType];


/**
 * 
 * @export
 * @interface BusinessPermissionResponseDto
 */
export interface BusinessPermissionResponseDto {
    /**
     * Permission key identifier
     * @type {string}
     * @memberof BusinessPermissionResponseDto
     */
    'key': string;
    /**
     * Whether the permission is enabled
     * @type {boolean}
     * @memberof BusinessPermissionResponseDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof BusinessPermissionResponseDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof BusinessPermissionResponseDto
     */
    'businessId': number;
    /**
     * 
     * @type {string}
     * @memberof BusinessPermissionResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessPermissionResponseDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface BusinessResponseDto
 */
export interface BusinessResponseDto {
    /**
     * Unique identifier for the business
     * @type {string}
     * @memberof BusinessResponseDto
     */
    'id': string;
    /**
     * Indicates if the business is enabled
     * @type {boolean}
     * @memberof BusinessResponseDto
     */
    'enabled': boolean;
    /**
     * Name of the business
     * @type {string}
     * @memberof BusinessResponseDto
     */
    'name': string;
    /**
     * URL for the business logo image
     * @type {string}
     * @memberof BusinessResponseDto
     */
    'logo': string | null;
    /**
     * Contact email address
     * @type {string}
     * @memberof BusinessResponseDto
     */
    'email': string | null;
    /**
     * Physical address of the business
     * @type {string}
     * @memberof BusinessResponseDto
     */
    'address': string | null;
    /**
     * Creation date and time in ISO 8601 format
     * @type {string}
     * @memberof BusinessResponseDto
     */
    'createdAt': string;
    /**
     * Contact phone number
     * @type {string}
     * @memberof BusinessResponseDto
     */
    'phone': string | null;
    /**
     * ID used by the ordering business system
     * @type {number}
     * @memberof BusinessResponseDto
     */
    'orderingBusinessId': number;
    /**
     * Business Identity Code (BIC)
     * @type {string}
     * @memberof BusinessResponseDto
     */
    'bic': string | null;
    /**
     * Weekly operating schedule (7 elements for 7 days)
     * @type {Array<ScheduleDto>}
     * @memberof BusinessResponseDto
     */
    'schedule': Array<ScheduleDto>;
    /**
     * Identifier for the business chain
     * @type {string}
     * @memberof BusinessResponseDto
     */
    'chainId': string | null;
    /**
     * Identifier for the merchant
     * @type {string}
     * @memberof BusinessResponseDto
     */
    'merchantId': string | null;
    /**
     * Configuration settings for the business (usually a single element)
     * @type {Array<ConfigDto>}
     * @memberof BusinessResponseDto
     */
    'config': Array<ConfigDto>;
    /**
     * Links to loyalty programs associated with the business
     * @type {Array<LoyaltyLinkDto>}
     * @memberof BusinessResponseDto
     */
    'loyaltyLinks': Array<LoyaltyLinkDto>;
}
/**
 * 
 * @export
 * @interface BusinessStatusDto
 */
export interface BusinessStatusDto {
    /**
     * 
     * @type {ProviderEnum}
     * @memberof BusinessStatusDto
     */
    'provider': ProviderEnum;
    /**
     * 
     * @type {BusinessStatusEnum}
     * @memberof BusinessStatusDto
     */
    'status': BusinessStatusEnum;
    /**
     * Duration of the status in minutes
     * @type {number}
     * @memberof BusinessStatusDto
     */
    'duration'?: number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const BusinessStatusEnum = {
    Online: 'ONLINE',
    Offline: 'OFFLINE'
} as const;

export type BusinessStatusEnum = typeof BusinessStatusEnum[keyof typeof BusinessStatusEnum];


/**
 * 
 * @export
 * @interface BusinessTaxResponseDto
 */
export interface BusinessTaxResponseDto {
    /**
     * 
     * @type {number}
     * @memberof BusinessTaxResponseDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BusinessTaxResponseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessTaxResponseDto
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof BusinessTaxResponseDto
     */
    'rate': number;
    /**
     * 
     * @type {number}
     * @memberof BusinessTaxResponseDto
     */
    'type': number;
}
/**
 * 
 * @export
 * @interface BusinessValidationResponseDto
 */
export interface BusinessValidationResponseDto {
    /**
     * Is valid business id or not for the current user session
     * @type {boolean}
     * @memberof BusinessValidationResponseDto
     */
    'isValid': boolean;
}
/**
 * 
 * @export
 * @interface CardDetailDto
 */
export interface CardDetailDto {
    /**
     * 
     * @type {string}
     * @memberof CardDetailDto
     */
    'cardType': string;
    /**
     * 
     * @type {string}
     * @memberof CardDetailDto
     */
    'cardNumber': string;
    /**
     * 
     * @type {string}
     * @memberof CardDetailDto
     */
    'aid': string | null;
    /**
     * 
     * @type {string}
     * @memberof CardDetailDto
     */
    'orderCode': string | null;
    /**
     * 
     * @type {string}
     * @memberof CardDetailDto
     */
    'transactionId': string;
    /**
     * 
     * @type {string}
     * @memberof CardDetailDto
     */
    'timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof CardDetailDto
     */
    'applicationLabel': string | null;
    /**
     * 
     * @type {string}
     * @memberof CardDetailDto
     */
    'issuer': string | null;
}
/**
 * 
 * @export
 * @interface CardPresentDetailsDto
 */
export interface CardPresentDetailsDto {
    /**
     * Last 4 digits of the card
     * @type {string}
     * @memberof CardPresentDetailsDto
     */
    'last4': string;
    /**
     * Card expiration month
     * @type {string}
     * @memberof CardPresentDetailsDto
     */
    'expMonth': string;
    /**
     * Card expiration year
     * @type {string}
     * @memberof CardPresentDetailsDto
     */
    'expYear': string;
    /**
     * Cardholder name
     * @type {string}
     * @memberof CardPresentDetailsDto
     */
    'cardholderName'?: string | null;
    /**
     * Card funding type
     * @type {string}
     * @memberof CardPresentDetailsDto
     */
    'funding': string;
    /**
     * Card brand
     * @type {string}
     * @memberof CardPresentDetailsDto
     */
    'brand': string;
    /**
     * Generated card identifier
     * @type {string}
     * @memberof CardPresentDetailsDto
     */
    'generatedCard'?: string | null;
    /**
     * Receipt data
     * @type {string}
     * @memberof CardPresentDetailsDto
     */
    'receipt'?: string | null;
    /**
     * EMV authorization data
     * @type {string}
     * @memberof CardPresentDetailsDto
     */
    'emvAuthData'?: string | null;
    /**
     * Card issuing country
     * @type {string}
     * @memberof CardPresentDetailsDto
     */
    'country'?: string | null;
    /**
     * Preferred locales
     * @type {Array<string>}
     * @memberof CardPresentDetailsDto
     */
    'preferredLocales': Array<string>;
    /**
     * Card issuer
     * @type {string}
     * @memberof CardPresentDetailsDto
     */
    'issuer': string;
    /**
     * Issuer identification number
     * @type {string}
     * @memberof CardPresentDetailsDto
     */
    'iin': string;
    /**
     * Card network
     * @type {string}
     * @memberof CardPresentDetailsDto
     */
    'network': string;
    /**
     * Card description
     * @type {string}
     * @memberof CardPresentDetailsDto
     */
    'description': string;
    /**
     * 
     * @type {CardPresentDetailsDtoWallet}
     * @memberof CardPresentDetailsDto
     */
    'wallet': CardPresentDetailsDtoWallet;
    /**
     * Reader location
     * @type {string}
     * @memberof CardPresentDetailsDto
     */
    'location'?: string | null;
    /**
     * Card reader identifier
     * @type {string}
     * @memberof CardPresentDetailsDto
     */
    'reader'?: string | null;
}
/**
 * Wallet information
 * @export
 * @interface CardPresentDetailsDtoWallet
 */
export interface CardPresentDetailsDtoWallet {
    /**
     * The ID of the wallet
     * @type {number}
     * @memberof CardPresentDetailsDtoWallet
     */
    'id': number;
    /**
     * Unique code for the wallet
     * @type {string}
     * @memberof CardPresentDetailsDtoWallet
     */
    'code': string;
    /**
     * The ID of the user who owns this wallet
     * @type {number}
     * @memberof CardPresentDetailsDtoWallet
     */
    'user_id': number;
    /**
     * Current balance in the wallet
     * @type {number}
     * @memberof CardPresentDetailsDtoWallet
     */
    'balance': number;
    /**
     * Whether the wallet is locked
     * @type {boolean}
     * @memberof CardPresentDetailsDtoWallet
     */
    'locked': boolean;
    /**
     * Reason for locking the wallet, if applicable
     * @type {object}
     * @memberof CardPresentDetailsDtoWallet
     */
    'locked_reason': object | null;
    /**
     * Timestamp when the wallet was locked, if applicable
     * @type {object}
     * @memberof CardPresentDetailsDtoWallet
     */
    'locked_at': object | null;
    /**
     * Timestamp when the wallet was created
     * @type {string}
     * @memberof CardPresentDetailsDtoWallet
     */
    'created_at': string;
    /**
     * Timestamp when the wallet was last updated
     * @type {string}
     * @memberof CardPresentDetailsDtoWallet
     */
    'updated_at': string;
    /**
     * Type of wallet (e.g., cash, credit_point)
     * @type {string}
     * @memberof CardPresentDetailsDtoWallet
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface CartOrderDto
 */
export interface CartOrderDto {
    /**
     * Cart ID
     * @type {string}
     * @memberof CartOrderDto
     */
    'cartId': string;
    /**
     * Document id
     * @type {string}
     * @memberof CartOrderDto
     */
    'documentId': string;
    /**
     * Order number
     * @type {string}
     * @memberof CartOrderDto
     */
    'orderNumber': string;
    /**
     * Table value or number
     * @type {string}
     * @memberof CartOrderDto
     */
    'tableValue': string | null;
    /**
     * 
     * @type {OrderTypePOS}
     * @memberof CartOrderDto
     */
    'orderType': OrderTypePOS;
    /**
     * 
     * @type {ServiceType}
     * @memberof CartOrderDto
     */
    'serviceType': ServiceType;
    /**
     * 
     * @type {LocatorType}
     * @memberof CartOrderDto
     */
    'locatorType': LocatorType;
    /**
     * Order items
     * @type {Array<PosItemDto>}
     * @memberof CartOrderDto
     */
    'items': Array<PosItemDto>;
    /**
     * 
     * @type {CartOrderDtoDiscount}
     * @memberof CartOrderDto
     */
    'discount': CartOrderDtoDiscount | null;
    /**
     * Additional comments for the order
     * @type {string}
     * @memberof CartOrderDto
     */
    'comments': string | null;
    /**
     * Total order amount
     * @type {number}
     * @memberof CartOrderDto
     */
    'total': number;
    /**
     * Subtotal before discounts and taxes
     * @type {number}
     * @memberof CartOrderDto
     */
    'subtotal': number;
    /**
     * Amount left to pay
     * @type {number}
     * @memberof CartOrderDto
     */
    'leftToPay': number;
    /**
     * Amount already paid
     * @type {number}
     * @memberof CartOrderDto
     */
    'paid': number;
    /**
     * Available payment methods
     * @type {Array<PaymentMethod>}
     * @memberof CartOrderDto
     */
    'paymentMethods': Array<PaymentMethod>;
    /**
     * Payments made with different methods
     * @type {Array<PaymentMethodTypeDto>}
     * @memberof CartOrderDto
     */
    'paidByPaymentMethods': Array<PaymentMethodTypeDto>;
    /**
     * Start date
     * @type {string}
     * @memberof CartOrderDto
     */
    'savedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof CartOrderDto
     */
    'currentlyPaidSplitPartId': string;
    /**
     * 
     * @type {CartOrderDtoCustomer}
     * @memberof CartOrderDto
     */
    'customer': CartOrderDtoCustomer | null;
    /**
     * Split bill parts if applicable
     * @type {Array<SplitPartDto>}
     * @memberof CartOrderDto
     */
    'splitParts': Array<SplitPartDto>;
    /**
     * Details of any refunds processed for this order.
     * @type {Array<PaymentRefundDto>}
     * @memberof CartOrderDto
     */
    'refunds'?: Array<PaymentRefundDto>;
    /**
     * 
     * @type {OrderRefundStatus}
     * @memberof CartOrderDto
     */
    'orderRefundStatus': OrderRefundStatus;
}


/**
 * Customer information
 * @export
 * @interface CartOrderDtoCustomer
 */
export interface CartOrderDtoCustomer {
    /**
     * The ID of the user
     * @type {number}
     * @memberof CartOrderDtoCustomer
     */
    'id': number;
    /**
     * The landline phone number of the user
     * @type {object}
     * @memberof CartOrderDtoCustomer
     */
    'phone': object | null;
    /**
     * The mobile phone number of the user
     * @type {string}
     * @memberof CartOrderDtoCustomer
     */
    'cellphone': string;
    /**
     * The first name of the user
     * @type {string}
     * @memberof CartOrderDtoCustomer
     */
    'name': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof CartOrderDtoCustomer
     */
    'lastname': string;
    /**
     * The level of the user
     * @type {number}
     * @memberof CartOrderDtoCustomer
     */
    'level': number;
    /**
     * Whether the user account is enabled
     * @type {boolean}
     * @memberof CartOrderDtoCustomer
     */
    'enabled': boolean;
    /**
     * The address of the user
     * @type {object}
     * @memberof CartOrderDtoCustomer
     */
    'address': object | null;
    /**
     * Loyalty points accumulated by the user
     * @type {number}
     * @memberof CartOrderDtoCustomer
     */
    'loyalty_level_points': number;
    /**
     * Country code of the user
     * @type {string}
     * @memberof CartOrderDtoCustomer
     */
    'country_code': string;
    /**
     * Number of orders placed by the user
     * @type {number}
     * @memberof CartOrderDtoCustomer
     */
    'orders_count': number;
    /**
     * URL to the user\'s profile photo
     * @type {object}
     * @memberof CartOrderDtoCustomer
     */
    'photo': object | null;
    /**
     * List of wallets associated with the user
     * @type {Array<WalletDto>}
     * @memberof CartOrderDtoCustomer
     */
    'wallets': Array<WalletDto>;
}
/**
 * Discount applied to the entire order
 * @export
 * @interface CartOrderDtoDiscount
 */
export interface CartOrderDtoDiscount {
    /**
     * 
     * @type {PosDiscountType}
     * @memberof CartOrderDtoDiscount
     */
    'type': PosDiscountType;
    /**
     * Discount value (percentage or amount)
     * @type {number}
     * @memberof CartOrderDtoDiscount
     */
    'value': number;
}


/**
 * 
 * @export
 * @interface CartStoreDto
 */
export interface CartStoreDto {
    /**
     * 
     * @type {CartStoreDtoCartOrder}
     * @memberof CartStoreDto
     */
    'cartOrder': CartStoreDtoCartOrder;
    /**
     * Selected items in the cart
     * @type {Array<PosItemDto>}
     * @memberof CartStoreDto
     */
    'selectedItems': Array<PosItemDto>;
    /**
     * Stripe payment intents
     * @type {Array<StripePaymentIntentDto>}
     * @memberof CartStoreDto
     */
    'paymentIntent': Array<StripePaymentIntentDto>;
}
/**
 * Cart order information
 * @export
 * @interface CartStoreDtoCartOrder
 */
export interface CartStoreDtoCartOrder {
    /**
     * Cart ID
     * @type {string}
     * @memberof CartStoreDtoCartOrder
     */
    'cartId': string;
    /**
     * Document id
     * @type {string}
     * @memberof CartStoreDtoCartOrder
     */
    'documentId': string;
    /**
     * Order number
     * @type {string}
     * @memberof CartStoreDtoCartOrder
     */
    'orderNumber': string;
    /**
     * Table value or number
     * @type {string}
     * @memberof CartStoreDtoCartOrder
     */
    'tableValue': string | null;
    /**
     * 
     * @type {OrderTypePOS}
     * @memberof CartStoreDtoCartOrder
     */
    'orderType': OrderTypePOS;
    /**
     * 
     * @type {ServiceType}
     * @memberof CartStoreDtoCartOrder
     */
    'serviceType': ServiceType;
    /**
     * 
     * @type {LocatorType}
     * @memberof CartStoreDtoCartOrder
     */
    'locatorType': LocatorType;
    /**
     * Order items
     * @type {Array<PosItemDto>}
     * @memberof CartStoreDtoCartOrder
     */
    'items': Array<PosItemDto>;
    /**
     * 
     * @type {CartOrderDtoDiscount}
     * @memberof CartStoreDtoCartOrder
     */
    'discount': CartOrderDtoDiscount | null;
    /**
     * Additional comments for the order
     * @type {string}
     * @memberof CartStoreDtoCartOrder
     */
    'comments': string | null;
    /**
     * Total order amount
     * @type {number}
     * @memberof CartStoreDtoCartOrder
     */
    'total': number;
    /**
     * Subtotal before discounts and taxes
     * @type {number}
     * @memberof CartStoreDtoCartOrder
     */
    'subtotal': number;
    /**
     * Amount left to pay
     * @type {number}
     * @memberof CartStoreDtoCartOrder
     */
    'leftToPay': number;
    /**
     * Amount already paid
     * @type {number}
     * @memberof CartStoreDtoCartOrder
     */
    'paid': number;
    /**
     * Available payment methods
     * @type {Array<PaymentMethod>}
     * @memberof CartStoreDtoCartOrder
     */
    'paymentMethods': Array<PaymentMethod>;
    /**
     * Payments made with different methods
     * @type {Array<PaymentMethodTypeDto>}
     * @memberof CartStoreDtoCartOrder
     */
    'paidByPaymentMethods': Array<PaymentMethodTypeDto>;
    /**
     * Start date
     * @type {string}
     * @memberof CartStoreDtoCartOrder
     */
    'savedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof CartStoreDtoCartOrder
     */
    'currentlyPaidSplitPartId': string;
    /**
     * 
     * @type {CartOrderDtoCustomer}
     * @memberof CartStoreDtoCartOrder
     */
    'customer': CartOrderDtoCustomer | null;
    /**
     * Split bill parts if applicable
     * @type {Array<SplitPartDto>}
     * @memberof CartStoreDtoCartOrder
     */
    'splitParts': Array<SplitPartDto>;
    /**
     * Details of any refunds processed for this order.
     * @type {Array<PaymentRefundDto>}
     * @memberof CartStoreDtoCartOrder
     */
    'refunds'?: Array<PaymentRefundDto>;
    /**
     * 
     * @type {OrderRefundStatus}
     * @memberof CartStoreDtoCartOrder
     */
    'orderRefundStatus': OrderRefundStatus;
}


/**
 * 
 * @export
 * @interface CashLogDto
 */
export interface CashLogDto {
    /**
     * Unique Log ID
     * @type {string}
     * @memberof CashLogDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CashLogDto
     */
    'currency': string;
    /**
     * Business ID
     * @type {string}
     * @memberof CashLogDto
     */
    'businessId': string;
    /**
     * Linked Session ID
     * @type {string}
     * @memberof CashLogDto
     */
    'cashSessionId': string;
    /**
     * Staff Member ID
     * @type {string}
     * @memberof CashLogDto
     */
    'staffId': string | null;
    /**
     * 
     * @type {string}
     * @memberof CashLogDto
     */
    'timestamp': string;
    /**
     * 
     * @type {CashLogType}
     * @memberof CashLogDto
     */
    'type': CashLogType;
    /**
     * Amount of movement (always positive absolute value)
     * @type {number}
     * @memberof CashLogDto
     */
    'amount': number;
    /**
     * 
     * @type {CashLogReason}
     * @memberof CashLogDto
     */
    'reason': CashLogReason;
    /**
     * Related Order ID if applicable
     * @type {string}
     * @memberof CashLogDto
     */
    'referenceId'?: string;
    /**
     * Optional detailed description
     * @type {string}
     * @memberof CashLogDto
     */
    'description'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const CashLogReason = {
    SaleTransaction: 'SALE_TRANSACTION',
    RefundTransaction: 'REFUND_TRANSACTION',
    OrderVoid: 'ORDER_VOID',
    OpeningFloat: 'OPENING_FLOAT',
    ClosingCount: 'CLOSING_COUNT',
    AdjustmentEntry: 'ADJUSTMENT_ENTRY',
    BankTransferIn: 'BANK_TRANSFER_IN',
    PrivateDeposit: 'PRIVATE_DEPOSIT',
    TipsDeposit: 'TIPS_DEPOSIT',
    PurchaseMaterials: 'PURCHASE_MATERIALS',
    BankTransferOut: 'BANK_TRANSFER_OUT',
    SalaryPayout: 'SALARY_PAYOUT',
    TipsPayout: 'TIPS_PAYOUT',
    PrivateWithdrawal: 'PRIVATE_WITHDRAWAL',
    OtherExpense: 'OTHER_EXPENSE',
    Other: 'OTHER'
} as const;

export type CashLogReason = typeof CashLogReason[keyof typeof CashLogReason];


/**
 * 
 * @export
 * @enum {string}
 */

export const CashLogType = {
    Opening: 'OPENING',
    Sale: 'SALE',
    Refund: 'REFUND',
    ManualIn: 'MANUAL_IN',
    ManualOut: 'MANUAL_OUT',
    Closing: 'CLOSING'
} as const;

export type CashLogType = typeof CashLogType[keyof typeof CashLogType];


/**
 * 
 * @export
 * @interface CashRefundPayload
 */
export interface CashRefundPayload {
    /**
     * Unique internal ID for this refund transaction
     * @type {string}
     * @memberof CashRefundPayload
     */
    'id': string;
    /**
     * Unique internal ID for this refund transaction
     * @type {string}
     * @memberof CashRefundPayload
     */
    'refundId': string;
    /**
     * Refund ID from the payment provider (e.g., Stripe refund ID). Deprecated soon
     * @type {string}
     * @memberof CashRefundPayload
     */
    'providerRefundId': string;
    /**
     * Refund ID from the payment provider V2 (e.g., Stripe refund ID)
     * @type {string}
     * @memberof CashRefundPayload
     */
    'sourceTransactionId': string | null;
    /**
     * ID of the original payment being refunded
     * @type {string}
     * @memberof CashRefundPayload
     * @deprecated
     */
    'originalPaymentId'?: string | null;
    /**
     * ID of the original payment being refunded
     * @type {string}
     * @memberof CashRefundPayload
     */
    'originalPaymentEventId'?: string | null;
    /**
     * 
     * @type {PaymentProviderEnum}
     * @memberof CashRefundPayload
     */
    'paymentProvider': PaymentProviderEnum;
    /**
     * The amount refunded
     * @type {number}
     * @memberof CashRefundPayload
     */
    'amount': number;
    /**
     * Currency of the refund (ISO 4217 code, e.g., EUR)
     * @type {string}
     * @memberof CashRefundPayload
     */
    'currency': string;
    /**
     * 
     * @type {RefundStatusEnum}
     * @memberof CashRefundPayload
     */
    'status': RefundStatusEnum;
    /**
     * Timestamp when the refund was processed
     * @type {string}
     * @memberof CashRefundPayload
     */
    'processedAt': string;
    /**
     * Reason for the refund
     * @type {string}
     * @memberof CashRefundPayload
     */
    'reason'?: string | null;
    /**
     * Specific items refunded
     * @type {Array<RefundedItemDto>}
     * @memberof CashRefundPayload
     */
    'items'?: Array<RefundedItemDto>;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof CashRefundPayload
     */
    'type'?: PaymentMethod;
    /**
     * Additional metadata from the payment provider or system
     * @type {{ [key: string]: any; }}
     * @memberof CashRefundPayload
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The ordering business ID for this transaction.
     * @type {number}
     * @memberof CashRefundPayload
     */
    'orderingBusinessId': number;
    /**
     * The POS order id for this transaction.
     * @type {string}
     * @memberof CashRefundPayload
     */
    'posOrderId': string;
}


/**
 * 
 * @export
 * @interface CashSessionClosingDto
 */
export interface CashSessionClosingDto {
    /**
     * Calculated Expected Amount
     * @type {number}
     * @memberof CashSessionClosingDto
     */
    'expectedCash': number;
    /**
     * Actual Counted Amount
     * @type {number}
     * @memberof CashSessionClosingDto
     */
    'countedCash': number;
    /**
     * Difference (Counted - Expected)
     * @type {number}
     * @memberof CashSessionClosingDto
     */
    'difference': number;
    /**
     * 
     * @type {string}
     * @memberof CashSessionClosingDto
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface CashSessionDto
 */
export interface CashSessionDto {
    /**
     * Session ID
     * @type {string}
     * @memberof CashSessionDto
     */
    'id': string;
    /**
     * Business ID
     * @type {string}
     * @memberof CashSessionDto
     */
    'businessId': string;
    /**
     * 
     * @type {string}
     * @memberof CashSessionDto
     */
    'currency': string;
    /**
     * 
     * @type {CashSessionStatus}
     * @memberof CashSessionDto
     */
    'status': CashSessionStatus;
    /**
     * ID of staff who opened
     * @type {string}
     * @memberof CashSessionDto
     */
    'openedBy'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CashSessionDto
     */
    'openedAt': string;
    /**
     * ID of staff who closed
     * @type {string}
     * @memberof CashSessionDto
     */
    'closedBy'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CashSessionDto
     */
    'closedAt'?: string;
    /**
     * Initial float amount
     * @type {number}
     * @memberof CashSessionDto
     */
    'openingBalance': number;
    /**
     * 
     * @type {CashSessionTotalsDto}
     * @memberof CashSessionDto
     */
    'totals': CashSessionTotalsDto;
    /**
     * 
     * @type {CashSessionDtoClosing}
     * @memberof CashSessionDto
     */
    'closing'?: CashSessionDtoClosing;
    /**
     * Optional label for the stage/shift
     * @type {string}
     * @memberof CashSessionDto
     */
    'currentStageLabel'?: string;
}


/**
 * Closing reconciliation data
 * @export
 * @interface CashSessionDtoClosing
 */
export interface CashSessionDtoClosing {
    /**
     * Calculated Expected Amount
     * @type {number}
     * @memberof CashSessionDtoClosing
     */
    'expectedCash': number;
    /**
     * Actual Counted Amount
     * @type {number}
     * @memberof CashSessionDtoClosing
     */
    'countedCash': number;
    /**
     * Difference (Counted - Expected)
     * @type {number}
     * @memberof CashSessionDtoClosing
     */
    'difference': number;
    /**
     * 
     * @type {string}
     * @memberof CashSessionDtoClosing
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface CashSessionMessageDto
 */
export interface CashSessionMessageDto {
    /**
     * The type of the signal.
     * @type {string}
     * @memberof CashSessionMessageDto
     */
    'CashSessionDto': CashSessionDtoEnum;
}

export const CashSessionDtoEnum = {
    SessionUpdated: 'SESSION_UPDATED',
    SessionClosed: 'SESSION_CLOSED',
    LogAdded: 'LOG_ADDED'
} as const;

export type CashSessionDtoEnum = typeof CashSessionDtoEnum[keyof typeof CashSessionDtoEnum];

/**
 * 
 * @export
 * @interface CashSessionResponseDto
 */
export interface CashSessionResponseDto {
    /**
     * 
     * @type {CashSessionResponseDtoActiveSession}
     * @memberof CashSessionResponseDto
     */
    'activeSession': CashSessionResponseDtoActiveSession | null;
}
/**
 * @type CashSessionResponseDtoActiveSession
 * The currently open cash session for the business, or null if none.
 * @export
 */
export type CashSessionResponseDtoActiveSession = CashSessionDto | Null;

/**
 * 
 * @export
 * @enum {string}
 */

export const CashSessionStatus = {
    Open: 'OPEN',
    Counting: 'COUNTING',
    Closed: 'CLOSED'
} as const;

export type CashSessionStatus = typeof CashSessionStatus[keyof typeof CashSessionStatus];


/**
 * 
 * @export
 * @interface CashSessionTotalsDto
 */
export interface CashSessionTotalsDto {
    /**
     * Total Cash Sales
     * @type {number}
     * @memberof CashSessionTotalsDto
     */
    'sales': number;
    /**
     * Total Cash Refunds
     * @type {number}
     * @memberof CashSessionTotalsDto
     */
    'refunds': number;
    /**
     * Total Manual Cash In
     * @type {number}
     * @memberof CashSessionTotalsDto
     */
    'cashIn': number;
    /**
     * Total Manual Cash Out
     * @type {number}
     * @memberof CashSessionTotalsDto
     */
    'cashOut': number;
}
/**
 * 
 * @export
 * @interface CategoryDto
 */
export interface CategoryDto {
    /**
     * 
     * @type {string}
     * @memberof CategoryDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryDto
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof CategoryDto
     */
    'image': object | null;
    /**
     * 
     * @type {number}
     * @memberof CategoryDto
     */
    'rank': number;
    /**
     * 
     * @type {boolean}
     * @memberof CategoryDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {object}
     * @memberof CategoryDto
     */
    'header': object | null;
    /**
     * 
     * @type {object}
     * @memberof CategoryDto
     */
    'description': object | null;
    /**
     * 
     * @type {Array<ExtendedProductDto>}
     * @memberof CategoryDto
     */
    'products': Array<ExtendedProductDto>;
    /**
     * 
     * @type {Array<SubcategoryDto>}
     * @memberof CategoryDto
     */
    'subcategories': Array<SubcategoryDto>;
}
/**
 * 
 * @export
 * @interface ChannelConfig
 */
export interface ChannelConfig {
    /**
     * 
     * @type {string}
     * @memberof ChannelConfig
     */
    'channel': ChannelEnum;
    /**
     * 
     * @type {number}
     * @memberof ChannelConfig
     */
    'quantity': number;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelConfig
     */
    'inventoried': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelConfig
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof ChannelConfig
     */
    'external_id'?: string | null;
}

export const ChannelEnum = {
    Wolt: 'Wolt',
    MunchiOnline: 'MunchiOnline',
    MunchiKiosk: 'MunchiKiosk',
    MunchiPos: 'MunchiPos',
    UberEats: 'UberEats',
    Foodora: 'Foodora',
    Bolt: 'Bolt',
    MunchiKioskV2: 'MunchiKioskV2',
    Kiosk: 'Kiosk'
} as const;

export type ChannelEnum = typeof ChannelEnum[keyof typeof ChannelEnum];

/**
 * 
 * @export
 * @interface ChannelInventoryResponseDto
 */
export interface ChannelInventoryResponseDto {
    /**
     * 
     * @type {ProviderEnum}
     * @memberof ChannelInventoryResponseDto
     */
    'channel': ProviderEnum;
    /**
     * 
     * @type {number}
     * @memberof ChannelInventoryResponseDto
     */
    'product_id': number;
    /**
     * 
     * @type {number}
     * @memberof ChannelInventoryResponseDto
     */
    'category_id': number;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelInventoryResponseDto
     */
    'pos_inventoried': boolean;
    /**
     * 
     * @type {number}
     * @memberof ChannelInventoryResponseDto
     */
    'pos_quantity': number;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelInventoryResponseDto
     */
    'enabled': boolean;
}


/**
 * 
 * @export
 * @interface ChannelInventoryUpdateDto
 */
export interface ChannelInventoryUpdateDto {
    /**
     * 
     * @type {ProviderEnum}
     * @memberof ChannelInventoryUpdateDto
     */
    'channel': ProviderEnum;
    /**
     * Whether inventory tracking is enabled for this channel
     * @type {boolean}
     * @memberof ChannelInventoryUpdateDto
     */
    'inventoried': boolean;
    /**
     * Current quantity for this channel
     * @type {number}
     * @memberof ChannelInventoryUpdateDto
     */
    'quantity': number;
    /**
     * Whether the product is enabled for this channel
     * @type {boolean}
     * @memberof ChannelInventoryUpdateDto
     */
    'enabled'?: boolean;
}


/**
 * 
 * @export
 * @interface ChargeDto
 */
export interface ChargeDto {
    /**
     * Charge identifier
     * @type {string}
     * @memberof ChargeDto
     */
    'id': string;
    /**
     * Charge amount in smallest currency unit
     * @type {number}
     * @memberof ChargeDto
     */
    'amount': number;
    /**
     * Charge description
     * @type {string}
     * @memberof ChargeDto
     */
    'description': string;
    /**
     * Charge currency
     * @type {string}
     * @memberof ChargeDto
     */
    'currency': string;
    /**
     * Charge status
     * @type {string}
     * @memberof ChargeDto
     */
    'status': string;
    /**
     * 
     * @type {ChargeDtoPaymentMethodDetails}
     * @memberof ChargeDto
     */
    'paymentMethodDetails': ChargeDtoPaymentMethodDetails;
}
/**
 * Payment method details
 * @export
 * @interface ChargeDtoPaymentMethodDetails
 */
export interface ChargeDtoPaymentMethodDetails {
    /**
     * Payment method type
     * @type {string}
     * @memberof ChargeDtoPaymentMethodDetails
     */
    'type': string;
    /**
     * 
     * @type {PaymentMethodDetailsDtoCardPresentDetails}
     * @memberof ChargeDtoPaymentMethodDetails
     */
    'cardPresentDetails'?: PaymentMethodDetailsDtoCardPresentDetails;
    /**
     * 
     * @type {PaymentMethodDetailsDtoInteracPresentDetails}
     * @memberof ChargeDtoPaymentMethodDetails
     */
    'interacPresentDetails'?: PaymentMethodDetailsDtoInteracPresentDetails;
    /**
     * 
     * @type {PaymentMethodDetailsDtoWechatPayDetails}
     * @memberof ChargeDtoPaymentMethodDetails
     */
    'wechatPayDetails'?: PaymentMethodDetailsDtoWechatPayDetails;
    /**
     * 
     * @type {PaymentMethodDetailsDtoAffirmDetails}
     * @memberof ChargeDtoPaymentMethodDetails
     */
    'affirmDetails'?: PaymentMethodDetailsDtoAffirmDetails;
}
/**
 * 
 * @export
 * @interface CheckInResponseDto
 */
export interface CheckInResponseDto {
    /**
     * 
     * @type {CheckInResponseDtoKiosk}
     * @memberof CheckInResponseDto
     */
    'kiosk': CheckInResponseDtoKiosk;
    /**
     * 
     * @type {CheckInResponseDtoTerminal}
     * @memberof CheckInResponseDto
     */
    'terminal': CheckInResponseDtoTerminal;
}
/**
 * Details of the Kiosk that was either fetched or created.
 * @export
 * @interface CheckInResponseDtoKiosk
 */
export interface CheckInResponseDtoKiosk {
    /**
     * The unique ID of the Kiosk.
     * @type {string}
     * @memberof CheckInResponseDtoKiosk
     */
    'id': string;
    /**
     * The unique ID of the Kiosk hardware.
     * @type {string}
     * @memberof CheckInResponseDtoKiosk
     */
    'hardwareId': string;
    /**
     * The unique ID of the payment terminal connected to this kiosk, or null if unassigned.
     * @type {string}
     * @memberof CheckInResponseDtoKiosk
     */
    'paymentTerminalId': string | null;
    /**
     * The display name of the Kiosk.
     * @type {string}
     * @memberof CheckInResponseDtoKiosk
     */
    'name': string;
    /**
     * 
     * @type {Status}
     * @memberof CheckInResponseDtoKiosk
     */
    'status': Status;
    /**
     * The prefix used by the kiosk when creating orders.
     * @type {string}
     * @memberof CheckInResponseDtoKiosk
     */
    'prefix': string;
    /**
     * The business ID the kiosk is registered to.
     * @type {number}
     * @memberof CheckInResponseDtoKiosk
     */
    'orderingBusinessId': number;
    /**
     * Timestamp when the kiosk record was created.
     * @type {string}
     * @memberof CheckInResponseDtoKiosk
     */
    'createdAt': string;
    /**
     * Timestamp when the kiosk record was last updated.
     * @type {string}
     * @memberof CheckInResponseDtoKiosk
     */
    'updatedAt': string;
    /**
     * 
     * @type {KioskDetailsDtoPaymentTerminal}
     * @memberof CheckInResponseDtoKiosk
     */
    'paymentTerminal': KioskDetailsDtoPaymentTerminal | null;
}


/**
 * Details of the Payment Terminal connected to the Kiosk.
 * @export
 * @interface CheckInResponseDtoTerminal
 */
export interface CheckInResponseDtoTerminal {
    /**
     * The unique ID of the payment terminal.
     * @type {string}
     * @memberof CheckInResponseDtoTerminal
     */
    'id': string;
    /**
     * The hardware ID provided by the payment service provider.
     * @type {string}
     * @memberof CheckInResponseDtoTerminal
     */
    'hardwareId': string;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof CheckInResponseDtoTerminal
     */
    'provider': PaymentProvider;
    /**
     * An optional human-readable label for the terminal.
     * @type {string}
     * @memberof CheckInResponseDtoTerminal
     */
    'label': string | null;
    /**
     * The business ID the terminal is registered to.
     * @type {number}
     * @memberof CheckInResponseDtoTerminal
     */
    'orderingBusinessId': number;
    /**
     * Timestamp when the terminal record was created.
     * @type {string}
     * @memberof CheckInResponseDtoTerminal
     */
    'createdAt': string;
    /**
     * Timestamp when the terminal record was last updated.
     * @type {string}
     * @memberof CheckInResponseDtoTerminal
     */
    'updatedAt': string;
}


/**
 * 
 * @export
 * @interface ClockInRequestDto
 */
export interface ClockInRequestDto {
    /**
     * The ID of the employee clocking in.
     * @type {string}
     * @memberof ClockInRequestDto
     */
    'employeeId': string;
}
/**
 * 
 * @export
 * @interface ClockOutRequestDto
 */
export interface ClockOutRequestDto {
    /**
     * The ID of the employee.
     * @type {string}
     * @memberof ClockOutRequestDto
     */
    'employeeId': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CodeChannel = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type CodeChannel = typeof CodeChannel[keyof typeof CodeChannel];


/**
 * 
 * @export
 * @interface CompletedStepDto
 */
export interface CompletedStepDto {
    /**
     * The unique ID of the plan step being completed.
     * @type {string}
     * @memberof CompletedStepDto
     */
    'stepId': string;
    /**
     * 
     * @type {RefundStepStatus}
     * @memberof CompletedStepDto
     */
    'status': RefundStepStatus;
    /**
     * ID of the original payment being refunded
     * @type {string}
     * @memberof CompletedStepDto
     */
    'originalPaymentEventId'?: string | null;
    /**
     * Refund ID from the payment provider V2 (e.g., Stripe refund ID)
     * @type {string}
     * @memberof CompletedStepDto
     */
    'sourceTransactionId': string | null;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof CompletedStepDto
     */
    'type'?: PaymentMethod;
    /**
     * Refund ID from the payment provider 
     * @type {string}
     * @memberof CompletedStepDto
     */
    'referenceId': string;
    /**
     * The full, unaltered raw response from the payment provider for this specific transaction.
     * @type {{ [key: string]: any; }}
     * @memberof CompletedStepDto
     */
    'rawData'?: { [key: string]: any; } | null;
}


/**
 * 
 * @export
 * @interface ConfigDto
 */
export interface ConfigDto {
    /**
     * Unique identifier for the configuration
     * @type {string}
     * @memberof ConfigDto
     */
    'id': string;
    /**
     * 
     * @type {CurrencyCode}
     * @memberof ConfigDto
     */
    'currency': CurrencyCode;
    /**
     * Creation date and time in ISO 8601 format
     * @type {string}
     * @memberof ConfigDto
     */
    'createdAt': string;
    /**
     * Last update date and time in ISO 8601 format
     * @type {string}
     * @memberof ConfigDto
     */
    'updatedAt': string;
    /**
     * ID used by the ordering business system
     * @type {number}
     * @memberof ConfigDto
     */
    'orderingBusinessId': number;
    /**
     * 
     * @type {ProviderEnum}
     * @memberof ConfigDto
     */
    'channel': ProviderEnum;
    /**
     * Whether automatic rejection of orders is enabled
     * @type {boolean}
     * @memberof ConfigDto
     */
    'autoRejectEnabled': boolean;
    /**
     * 
     * @type {KioskLayout}
     * @memberof ConfigDto
     */
    'layout': KioskLayout;
    /**
     * 
     * @type {UpsellMode}
     * @memberof ConfigDto
     */
    'upsellMode': UpsellMode;
    /**
     * Default config for kiosk auto print
     * @type {boolean}
     * @memberof ConfigDto
     */
    'kioskAutoPrintReceipt': boolean;
    /**
     * 
     * @type {ProductDetailLayout}
     * @memberof ConfigDto
     */
    'productDetailLayout': ProductDetailLayout;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof ConfigDto
     */
    'selectedPaymentProvider': PaymentProvider | null;
    /**
     * Show if business has loyalty program
     * @type {boolean}
     * @memberof ConfigDto
     */
    'hasLoyaltyProgram': boolean;
    /**
     * Configuration for the business background
     * @type {object}
     * @memberof ConfigDto
     */
    'appearanceConfig': object;
    /**
     * Configuration for the locator screen
     * @type {boolean}
     * @memberof ConfigDto
     */
    'showLocator': boolean;
    /**
     * Company name for the business
     * @type {string}
     * @memberof ConfigDto
     */
    'companyName': string | null;
    /**
     * Timezone for the business
     * @type {string}
     * @memberof ConfigDto
     */
    'timezone': string | null;
    /**
     * Configuration for the theme
     * @type {object}
     * @memberof ConfigDto
     */
    'theme': object;
}


/**
 * 
 * @export
 * @interface ConfirmPreorderDto
 */
export interface ConfirmPreorderDto {
    /**
     * Unique identifier for the order
     * @type {string}
     * @memberof ConfirmPreorderDto
     */
    'orderId': string;
    /**
     * ID of the business updating the order
     * @type {number}
     * @memberof ConfirmPreorderDto
     */
    'orderingBusinessId': number;
    /**
     * 
     * @type {ProviderEnum}
     * @memberof ConfirmPreorderDto
     */
    'provider': ProviderEnum;
    /**
     * Time of acceptance if applicable
     * @type {number}
     * @memberof ConfirmPreorderDto
     */
    'preparedIn': number;
}


/**
 * 
 * @export
 * @interface ConnectTerminalPayloadDto
 */
export interface ConnectTerminalPayloadDto {
    /**
     * Id of the terminal
     * @type {string}
     * @memberof ConnectTerminalPayloadDto
     */
    'terminalId': string;
    /**
     * Id of the business
     * @type {number}
     * @memberof ConnectTerminalPayloadDto
     */
    'orderingBusinessId': number;
}
/**
 * 
 * @export
 * @interface ConnectTerminaldDto
 */
export interface ConnectTerminaldDto {
    /**
     * Id of the terminal
     * @type {string}
     * @memberof ConnectTerminaldDto
     */
    'terminalId': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectTerminaldDto
     */
    'id': string;
    /**
     * Name of the terminal
     * @type {string}
     * @memberof ConnectTerminaldDto
     */
    'name': string;
    /**
     * Time when it last connected to the terminal
     * @type {string}
     * @memberof ConnectTerminaldDto
     */
    'connectedAt': string;
}
/**
 * 
 * @export
 * @interface ConnectionTokenPayloadDto
 */
export interface ConnectionTokenPayloadDto {
    /**
     * The ordering business ID for this transaction.
     * @type {number}
     * @memberof ConnectionTokenPayloadDto
     */
    'orderingBusinessId': number;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof ConnectionTokenPayloadDto
     */
    'provider': PaymentProvider;
}


/**
 * 
 * @export
 * @interface ConnectionTokenResponseDto
 */
export interface ConnectionTokenResponseDto {
    /**
     * The access token for the payment provider.
     * @type {string}
     * @memberof ConnectionTokenResponseDto
     */
    'accessToken': string;
}
/**
 * 
 * @export
 * @interface CoordinateDto
 */
export interface CoordinateDto {
    /**
     * Coordinate ID
     * @type {string}
     * @memberof CoordinateDto
     */
    'id': string;
    /**
     * Latitude
     * @type {number}
     * @memberof CoordinateDto
     */
    'lat': number;
    /**
     * Longitude
     * @type {number}
     * @memberof CoordinateDto
     */
    'lon': number;
}
/**
 * 
 * @export
 * @interface CreateActionPasscodeDto
 */
export interface CreateActionPasscodeDto {
    /**
     * 
     * @type {string}
     * @memberof CreateActionPasscodeDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateActionPasscodeDto
     */
    'pin': string;
    /**
     * 
     * @type {number}
     * @memberof CreateActionPasscodeDto
     */
    'businessId'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateActionPasscodeDto
     */
    'merchantId'?: string;
    /**
     * An array of permission rule objects
     * @type {Array<PermissionRuleDto>}
     * @memberof CreateActionPasscodeDto
     */
    'permissionRules': Array<PermissionRuleDto>;
}
/**
 * 
 * @export
 * @interface CreateEmployeeAssignmentDto
 */
export interface CreateEmployeeAssignmentDto {
    /**
     * The global ID of the employee to assign
     * @type {string}
     * @memberof CreateEmployeeAssignmentDto
     */
    'employeeId': string;
    /**
     * The ID of the role at this specific business
     * @type {string}
     * @memberof CreateEmployeeAssignmentDto
     */
    'roleId': string;
}
/**
 * 
 * @export
 * @interface CreateEmployeeDto
 */
export interface CreateEmployeeDto {
    /**
     * The employee\'s full name
     * @type {string}
     * @memberof CreateEmployeeDto
     */
    'name': string;
    /**
     * The ID of the merchant this employee belongs to
     * @type {string}
     * @memberof CreateEmployeeDto
     */
    'merchantId': string;
    /**
     * The 4-digit plain-text PIN for the employee
     * @type {string}
     * @memberof CreateEmployeeDto
     */
    'pin': string;
}
/**
 * 
 * @export
 * @interface CreateInvoiceCompanyDto
 */
export interface CreateInvoiceCompanyDto {
    /**
     * 
     * @type {number}
     * @memberof CreateInvoiceCompanyDto
     */
    'businessId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateInvoiceCompanyDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateInvoiceCompanyDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateInvoiceCompanyDto
     */
    'countryCode': string;
    /**
     * 
     * @type {string}
     * @memberof CreateInvoiceCompanyDto
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof CreateInvoiceCompanyDto
     */
    'bic'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateInvoiceCompanyDto
     */
    'address'?: string;
}
/**
 * 
 * @export
 * @interface CreateKioskDto
 */
export interface CreateKioskDto {
    /**
     * 
     * @type {string}
     * @memberof CreateKioskDto
     */
    'kioskId': string;
    /**
     * Ordering business ID
     * @type {number}
     * @memberof CreateKioskDto
     */
    'businessId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateKioskDto
     */
    'name'?: string;
    /**
     * Prefix for kiosk when create order
     * @type {string}
     * @memberof CreateKioskDto
     */
    'prefix': string;
    /**
     * 
     * @type {string}
     * @memberof CreateKioskDto
     */
    'paymentTerminalId': string;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof CreateKioskDto
     */
    'provider': PaymentProvider;
}


/**
 * 
 * @export
 * @interface CreateMerchantDto
 */
export interface CreateMerchantDto {
    /**
     * The name of the merchant or restaurant chain
     * @type {string}
     * @memberof CreateMerchantDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateNetsTransactionDto
 */
export interface CreateNetsTransactionDto {
    /**
     * 
     * @type {TransactionType}
     * @memberof CreateNetsTransactionDto
     */
    'transactionType': TransactionType;
    /**
     * The transaction amount in the smallest currency unit (e.g., cents for EUR). So 25.15 EUR should be sent as 2515.
     * @type {number}
     * @memberof CreateNetsTransactionDto
     */
    'amount': number;
    /**
     * If true, allows the cardholder to bypass PIN entry. The fraud liability shifts to the merchant.
     * @type {boolean}
     * @memberof CreateNetsTransactionDto
     */
    'allowPinBypass'?: boolean;
    /**
     * The operator ID for a terminal with a multimerchant configuration. Main merchant is \"0001\".
     * @type {string}
     * @memberof CreateNetsTransactionDto
     */
    'operatorId'?: string;
    /**
     * A unique ID for the order or receipt, used for reconciliation purposes.
     * @type {string}
     * @memberof CreateNetsTransactionDto
     */
    'orderId'?: string;
    /**
     * 
     * @type {CreateNetsTransactionDtoAccountFundingTransactionDetails}
     * @memberof CreateNetsTransactionDto
     */
    'accountFundingTransactionDetails'?: CreateNetsTransactionDtoAccountFundingTransactionDetails;
    /**
     * The authorization token received from a preceding \"authorization\" transaction, required for completion or reversal.
     * @type {string}
     * @memberof CreateNetsTransactionDto
     */
    'preAuthorizationInfo'?: string;
    /**
     * The ordering business ID for this transaction.
     * @type {number}
     * @memberof CreateNetsTransactionDto
     */
    'orderingBusinessId': number;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof CreateNetsTransactionDto
     */
    'provider': PaymentProvider;
    /**
     * The cart ID for this transaction.
     * @type {string}
     * @memberof CreateNetsTransactionDto
     */
    'cartId': string;
    /**
     * The terminal ID for this transaction.
     * @type {string}
     * @memberof CreateNetsTransactionDto
     */
    'terminalId': string;
}


/**
 * Contains details required for an Account Funding Transaction (AFT).
 * @export
 * @interface CreateNetsTransactionDtoAccountFundingTransactionDetails
 */
export interface CreateNetsTransactionDtoAccountFundingTransactionDetails {
    /**
     * Transaction category for Account Funding Transactions.
     * @type {string}
     * @memberof CreateNetsTransactionDtoAccountFundingTransactionDetails
     */
    'transactionCategory'?: string;
    /**
     * Payment type for Account Funding Transactions.
     * @type {string}
     * @memberof CreateNetsTransactionDtoAccountFundingTransactionDetails
     */
    'paymentType': string;
    /**
     * Purpose of the transaction.
     * @type {string}
     * @memberof CreateNetsTransactionDtoAccountFundingTransactionDetails
     */
    'transactionPurpose'?: string;
    /**
     * A reference number for the sender.
     * @type {string}
     * @memberof CreateNetsTransactionDtoAccountFundingTransactionDetails
     */
    'senderReferenceNumber': string;
    /**
     * The sender\'s name.
     * @type {string}
     * @memberof CreateNetsTransactionDtoAccountFundingTransactionDetails
     */
    'senderName'?: string;
    /**
     * The sender\'s city.
     * @type {string}
     * @memberof CreateNetsTransactionDtoAccountFundingTransactionDetails
     */
    'senderCity'?: string;
    /**
     * The sender\'s state.
     * @type {string}
     * @memberof CreateNetsTransactionDtoAccountFundingTransactionDetails
     */
    'senderState'?: string;
    /**
     * The sender\'s country in NOR-3166-1 alpha-3 format.
     * @type {string}
     * @memberof CreateNetsTransactionDtoAccountFundingTransactionDetails
     */
    'senderCountry'?: string;
    /**
     * The sender\'s street address.
     * @type {string}
     * @memberof CreateNetsTransactionDtoAccountFundingTransactionDetails
     */
    'senderStreetAddress'?: string;
    /**
     * Source of funds.
     * @type {string}
     * @memberof CreateNetsTransactionDtoAccountFundingTransactionDetails
     */
    'sourceOfFunds'?: string;
    /**
     * The recipient\'s name.
     * @type {string}
     * @memberof CreateNetsTransactionDtoAccountFundingTransactionDetails
     */
    'recipientName'?: string;
    /**
     * The recipient\'s account number (e.g., IBAN).
     * @type {string}
     * @memberof CreateNetsTransactionDtoAccountFundingTransactionDetails
     */
    'recipientAccount'?: string;
    /**
     * The type of the recipient account number.
     * @type {string}
     * @memberof CreateNetsTransactionDtoAccountFundingTransactionDetails
     */
    'recipientAccountNumberType'?: string;
    /**
     * The legal business name of the acceptor.
     * @type {string}
     * @memberof CreateNetsTransactionDtoAccountFundingTransactionDetails
     */
    'acceptorLegalBusinessName'?: string;
    /**
     * Any markup fee applied by the merchant.
     * @type {string}
     * @memberof CreateNetsTransactionDtoAccountFundingTransactionDetails
     */
    'merchantMarkupFee'?: string;
}
/**
 * 
 * @export
 * @interface CreateNetsTransactionResponseDto
 */
export interface CreateNetsTransactionResponseDto {
    /**
     * 
     * @type {TransactionType}
     * @memberof CreateNetsTransactionResponseDto
     */
    'transactionType': TransactionType;
    /**
     * The transaction amount in the smallest currency unit (e.g., cents for EUR). So 25.15 EUR should be sent as 2515.
     * @type {number}
     * @memberof CreateNetsTransactionResponseDto
     */
    'amount': number;
    /**
     * If true, allows the cardholder to bypass PIN entry. The fraud liability shifts to the merchant.
     * @type {boolean}
     * @memberof CreateNetsTransactionResponseDto
     */
    'allowPinBypass'?: boolean;
    /**
     * The operator ID for a terminal with a multimerchant configuration. Main merchant is \"0001\".
     * @type {string}
     * @memberof CreateNetsTransactionResponseDto
     */
    'operatorId'?: string;
    /**
     * A unique ID for the order or receipt, used for reconciliation purposes.
     * @type {string}
     * @memberof CreateNetsTransactionResponseDto
     */
    'orderId'?: string;
    /**
     * 
     * @type {CreateNetsTransactionDtoAccountFundingTransactionDetails}
     * @memberof CreateNetsTransactionResponseDto
     */
    'accountFundingTransactionDetails'?: CreateNetsTransactionDtoAccountFundingTransactionDetails;
    /**
     * The authorization token received from a preceding \"authorization\" transaction, required for completion or reversal.
     * @type {string}
     * @memberof CreateNetsTransactionResponseDto
     */
    'preAuthorizationInfo'?: string;
    /**
     * The ordering business ID for this transaction.
     * @type {number}
     * @memberof CreateNetsTransactionResponseDto
     */
    'orderingBusinessId': number;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof CreateNetsTransactionResponseDto
     */
    'provider': PaymentProvider;
    /**
     * The cart ID for this transaction.
     * @type {string}
     * @memberof CreateNetsTransactionResponseDto
     */
    'cartId': string;
    /**
     * The terminal ID for this transaction.
     * @type {string}
     * @memberof CreateNetsTransactionResponseDto
     */
    'terminalId': string;
    /**
     * A unique identifier for the Nets transaction.
     * @type {string}
     * @memberof CreateNetsTransactionResponseDto
     */
    'connectCloudRequestId': string;
}


/**
 * 
 * @export
 * @interface CreatePasscodeDto
 */
export interface CreatePasscodeDto {
    /**
     * 
     * @type {number}
     * @memberof CreatePasscodeDto
     */
    'passcode': number;
    /**
     * 
     * @type {PasscodeScopeType}
     * @memberof CreatePasscodeDto
     */
    'scopeType': PasscodeScopeType;
    /**
     * 
     * @type {string}
     * @memberof CreatePasscodeDto
     */
    'scopeId': string;
}


/**
 * 
 * @export
 * @interface CreatePasscodeResponseDto
 */
export interface CreatePasscodeResponseDto {
    /**
     * 
     * @type {number}
     * @memberof CreatePasscodeResponseDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof CreatePasscodeResponseDto
     */
    'pin': number;
    /**
     * 
     * @type {string}
     * @memberof CreatePasscodeResponseDto
     */
    'scopeType': ScopeTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreatePasscodeResponseDto
     */
    'scopeId': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePasscodeResponseDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof CreatePasscodeResponseDto
     */
    'createdAt': string;
}

export const ScopeTypeEnum = {
    Business: 'BUSINESS',
    Chain: 'CHAIN'
} as const;

export type ScopeTypeEnum = typeof ScopeTypeEnum[keyof typeof ScopeTypeEnum];

/**
 * 
 * @export
 * @interface CreateRefundPlanDto
 */
export interface CreateRefundPlanDto {
    /**
     * 
     * @type {RefundMode}
     * @memberof CreateRefundPlanDto
     */
    'mode': RefundMode;
    /**
     * The list of items to be refunded. Required only when mode is ITEM.
     * @type {Array<RefundRequestItemDto>}
     * @memberof CreateRefundPlanDto
     */
    'lineItems'?: Array<RefundRequestItemDto>;
}


/**
 * 
 * @export
 * @interface CreateRoleDto
 */
export interface CreateRoleDto {
    /**
     * The name of the role
     * @type {string}
     * @memberof CreateRoleDto
     */
    'name': string;
    /**
     * An array of permission rule objects
     * @type {Array<PermissionRuleDto>}
     * @memberof CreateRoleDto
     */
    'permissionRules': Array<PermissionRuleDto>;
}
/**
 * 
 * @export
 * @interface CreateTerminalPaymentDto
 */
export interface CreateTerminalPaymentDto {
    /**
     * The internal business ID.
     * @type {number}
     * @memberof CreateTerminalPaymentDto
     */
    'businessId': number;
    /**
     * The unique reference for the order or cart.
     * @type {string}
     * @memberof CreateTerminalPaymentDto
     */
    'referenceId': string;
    /**
     * The display reference for the order or cart.
     * @type {string}
     * @memberof CreateTerminalPaymentDto
     */
    'displayId': string;
    /**
     * Amount in the smallest currency unit (e.g., cents).
     * @type {number}
     * @memberof CreateTerminalPaymentDto
     */
    'amount': number;
    /**
     * 
     * @type {CurrencyCode}
     * @memberof CreateTerminalPaymentDto
     */
    'currency': CurrencyCode;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTerminalPaymentDto
     */
    'showReceipt'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateTerminalPaymentDto
     */
    'tipAmount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTerminalPaymentDto
     */
    'showTransactionResult'?: boolean;
}


/**
 * 
 * @export
 * @interface CreateTransactionPayloadDto
 */
export interface CreateTransactionPayloadDto {
    /**
     * The ordering business ID for this transaction.
     * @type {number}
     * @memberof CreateTransactionPayloadDto
     */
    'orderingBusinessId': number;
    /**
     * The order ID for this transaction.
     * @type {string}
     * @memberof CreateTransactionPayloadDto
     */
    'orderId': string;
    /**
     * The amount for this transaction in cents.
     * @type {number}
     * @memberof CreateTransactionPayloadDto
     */
    'amount': number;
    /**
     * The currency code for this transaction.
     * @type {string}
     * @memberof CreateTransactionPayloadDto
     */
    'currencyCode': string;
    /**
     * The identity ID for this transaction.
     * @type {string}
     * @memberof CreateTransactionPayloadDto
     */
    'identityId': string;
}
/**
 * 
 * @export
 * @interface CredentialDto
 */
export interface CredentialDto {
    /**
     * User email or username
     * @type {string}
     * @memberof CredentialDto
     */
    'email': string;
    /**
     * User password
     * @type {string}
     * @memberof CredentialDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CurrencyCode = {
    Eur: 'EUR',
    Gbp: 'GBP',
    Chf: 'CHF',
    Sek: 'SEK',
    Nok: 'NOK',
    Dkk: 'DKK',
    Pln: 'PLN',
    Czk: 'CZK',
    Huf: 'HUF',
    Ron: 'RON',
    Bgn: 'BGN',
    Hrk: 'HRK',
    Isk: 'ISK',
    Rsd: 'RSD',
    Try: 'TRY',
    Uah: 'UAH',
    Rub: 'RUB',
    All: 'ALL',
    Mkd: 'MKD',
    Mdl: 'MDL',
    Bam: 'BAM',
    Aed: 'AED'
} as const;

export type CurrencyCode = typeof CurrencyCode[keyof typeof CurrencyCode];


/**
 * 
 * @export
 * @interface CustomerDto
 */
export interface CustomerDto {
    /**
     * Customer ID
     * @type {string}
     * @memberof CustomerDto
     */
    'id': string;
    /**
     * Customer email
     * @type {string}
     * @memberof CustomerDto
     */
    'email': string | null;
    /**
     * Customer name
     * @type {string}
     * @memberof CustomerDto
     */
    'name': string;
    /**
     * Customer phone
     * @type {string}
     * @memberof CustomerDto
     */
    'phone': string | null;
}
/**
 * 
 * @export
 * @interface DeletePosOrderDto
 */
export interface DeletePosOrderDto {
    /**
     * Id of the business
     * @type {number}
     * @memberof DeletePosOrderDto
     */
    'businessId': number;
    /**
     * Id of the order
     * @type {string}
     * @memberof DeletePosOrderDto
     */
    'orderId': string;
}
/**
 * 
 * @export
 * @interface DeliveredOrderDto
 */
export interface DeliveredOrderDto {
    /**
     * Unique identifier for the order
     * @type {string}
     * @memberof DeliveredOrderDto
     */
    'orderId': string;
    /**
     * ID of the business updating the order
     * @type {number}
     * @memberof DeliveredOrderDto
     */
    'orderingBusinessId': number;
    /**
     * 
     * @type {ProviderEnum}
     * @memberof DeliveredOrderDto
     */
    'provider': ProviderEnum;
}


/**
 * 
 * @export
 * @interface DeliveryDto
 */
export interface DeliveryDto {
    /**
     * Delivery ID
     * @type {string}
     * @memberof DeliveryDto
     */
    'id': string;
    /**
     * Self delivery flag
     * @type {boolean}
     * @memberof DeliveryDto
     */
    'selfDelivery': boolean | null;
    /**
     * Delivery note
     * @type {string}
     * @memberof DeliveryDto
     */
    'note': string | null;
    /**
     * 
     * @type {DeliveryStatus}
     * @memberof DeliveryDto
     */
    'status': DeliveryStatus;
    /**
     * 
     * @type {DeliveryType}
     * @memberof DeliveryDto
     */
    'type': DeliveryType;
    /**
     * 
     * @type {DeliveryDtoLocation}
     * @memberof DeliveryDto
     */
    'location': DeliveryDtoLocation | null;
    /**
     * Delivery fee
     * @type {number}
     * @memberof DeliveryDto
     */
    'deliveryFee': number;
}


/**
 * Delivery location details
 * @export
 * @interface DeliveryDtoLocation
 */
export interface DeliveryDtoLocation {
    /**
     * Location ID
     * @type {string}
     * @memberof DeliveryDtoLocation
     */
    'id': string;
    /**
     * Formatted address
     * @type {string}
     * @memberof DeliveryDtoLocation
     */
    'formatted_address': string | null;
    /**
     * City
     * @type {string}
     * @memberof DeliveryDtoLocation
     */
    'city': string | null;
    /**
     * Country
     * @type {string}
     * @memberof DeliveryDtoLocation
     */
    'country': string | null;
    /**
     * 
     * @type {LocationDtoCoordinates}
     * @memberof DeliveryDtoLocation
     */
    'coordinates': LocationDtoCoordinates | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DeliveryStatus = {
    None: 'none',
    PickupEtaUpdated: 'pickup_eta_updated',
    PickupStarted: 'pickup_started',
    PickedUp: 'picked_up',
    DropoffStarted: 'dropoff_started',
    DropoffCompleted: 'dropoff_completed',
    Delivered: 'delivered',
    DropoffEtaUpdated: 'dropoff_eta_updated'
} as const;

export type DeliveryStatus = typeof DeliveryStatus[keyof typeof DeliveryStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const DeliveryType = {
    SelfDelivery: 'self_delivery',
    HomeDelivery: 'home_delivery'
} as const;

export type DeliveryType = typeof DeliveryType[keyof typeof DeliveryType];


/**
 * 
 * @export
 * @enum {string}
 */

export const DeviceStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7
} as const;

export type DeviceStatus = typeof DeviceStatus[keyof typeof DeviceStatus];


/**
 * 
 * @export
 * @interface DeviceSubscriptionDto
 */
export interface DeviceSubscriptionDto {
    /**
     * OneSignal Device ID
     * @type {string}
     * @memberof DeviceSubscriptionDto
     */
    'oneSignalId': string;
    /**
     * Hardware ID of the device
     * @type {string}
     * @memberof DeviceSubscriptionDto
     */
    'hardwareId': string;
    /**
     * List of business IDs to subscribe/unsubscribe
     * @type {Array<number>}
     * @memberof DeviceSubscriptionDto
     */
    'businessIds': Array<number>;
}
/**
 * 
 * @export
 * @interface DiscountDto
 */
export interface DiscountDto {
    /**
     * Discount ID
     * @type {string}
     * @memberof DiscountDto
     */
    'id': string;
    /**
     * Name of the discount
     * @type {string}
     * @memberof DiscountDto
     */
    'discountName': string;
    /**
     * Amount of discount
     * @type {number}
     * @memberof DiscountDto
     */
    'discountAmount': number;
    /**
     * Creation date of the discount
     * @type {string}
     * @memberof DiscountDto
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface DiscountOptionsDto
 */
export interface DiscountOptionsDto {
    /**
     * 
     * @type {PosDiscountType}
     * @memberof DiscountOptionsDto
     */
    'type': PosDiscountType;
    /**
     * Discount value (percentage or amount)
     * @type {number}
     * @memberof DiscountOptionsDto
     */
    'value': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const DiscountScope = {
    Item: 'ITEM',
    Cart: 'CART'
} as const;

export type DiscountScope = typeof DiscountScope[keyof typeof DiscountScope];


/**
 * 
 * @export
 * @enum {string}
 */

export const DiscountType = {
    Percentage: 'PERCENTAGE',
    Fixed: 'FIXED'
} as const;

export type DiscountType = typeof DiscountType[keyof typeof DiscountType];


/**
 * 
 * @export
 * @interface DiscoverTerminalDto
 */
export interface DiscoverTerminalDto {
    /**
     * The id of the business
     * @type {number}
     * @memberof DiscoverTerminalDto
     */
    'businessId': number;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof DiscoverTerminalDto
     */
    'provider': PaymentProvider;
}


/**
 * 
 * @export
 * @interface DiscoveredNetsTerminalDto
 */
export interface DiscoveredNetsTerminalDto {
    /**
     * The unique identifier for the payment terminal.
     * @type {string}
     * @memberof DiscoveredNetsTerminalDto
     */
    'terminalId': string;
    /**
     * A friendly name for the terminal, often the same as the ID.
     * @type {string}
     * @memberof DiscoveredNetsTerminalDto
     */
    'name': string;
    /**
     * Indicates if this terminal is currently connected in your database.
     * @type {boolean}
     * @memberof DiscoveredNetsTerminalDto
     */
    'isConnected': boolean;
    /**
     * Indicates if this terminal is currently connected in other business.
     * @type {boolean}
     * @memberof DiscoveredNetsTerminalDto
     */
    'connectedToCurrentBusiness': boolean;
    /**
     * Indicates if this business that the terminal is currently connected
     * @type {number}
     * @memberof DiscoveredNetsTerminalDto
     */
    'connectedToOtherBusinessId': number;
}
/**
 * 
 * @export
 * @interface EmployeeAssignmentResponseDto
 */
export interface EmployeeAssignmentResponseDto {
    /**
     * 
     * @type {string}
     * @memberof EmployeeAssignmentResponseDto
     */
    'employeeId': string;
    /**
     * 
     * @type {number}
     * @memberof EmployeeAssignmentResponseDto
     */
    'businessId': number;
    /**
     * 
     * @type {string}
     * @memberof EmployeeAssignmentResponseDto
     */
    'roleId': string;
}
/**
 * 
 * @export
 * @interface EmployeeResponseDto
 */
export interface EmployeeResponseDto {
    /**
     * 
     * @type {string}
     * @memberof EmployeeResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EmployeeResponseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EmployeeResponseDto
     */
    'merchantId': string;
    /**
     * 
     * @type {Status}
     * @memberof EmployeeResponseDto
     */
    'status': Status;
    /**
     * The employee\'s plain-text, decrypted PIN
     * @type {string}
     * @memberof EmployeeResponseDto
     */
    'pin': string;
}


/**
 * 
 * @export
 * @interface EmployeeSessionResponseDto
 */
export interface EmployeeSessionResponseDto {
    /**
     * 
     * @type {EmployeeSessionResponseDtoEmployee}
     * @memberof EmployeeSessionResponseDto
     */
    'employee': EmployeeSessionResponseDtoEmployee;
    /**
     * 
     * @type {EmployeeSessionResponseDtoActiveShift}
     * @memberof EmployeeSessionResponseDto
     */
    'activeShift': EmployeeSessionResponseDtoActiveShift | null;
}
/**
 * The active shift, if the user is already clocked in. Null otherwise.
 * @export
 * @interface EmployeeSessionResponseDtoActiveShift
 */
export interface EmployeeSessionResponseDtoActiveShift {
    /**
     * 
     * @type {string}
     * @memberof EmployeeSessionResponseDtoActiveShift
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EmployeeSessionResponseDtoActiveShift
     */
    'employeeId': string;
    /**
     * The orderingBusinessId.
     * @type {number}
     * @memberof EmployeeSessionResponseDtoActiveShift
     */
    'businessId': number;
    /**
     * 
     * @type {string}
     * @memberof EmployeeSessionResponseDtoActiveShift
     */
    'clockInTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeSessionResponseDtoActiveShift
     */
    'clockOutTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeSessionResponseDtoActiveShift
     */
    'activeSessionId': string;
    /**
     * 
     * @type {EmployeeShiftResponseDtoEmployee}
     * @memberof EmployeeSessionResponseDtoActiveShift
     */
    'employee': EmployeeShiftResponseDtoEmployee;
}
/**
 * The full employee profile.
 * @export
 * @interface EmployeeSessionResponseDtoEmployee
 */
export interface EmployeeSessionResponseDtoEmployee {
    /**
     * 
     * @type {string}
     * @memberof EmployeeSessionResponseDtoEmployee
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EmployeeSessionResponseDtoEmployee
     */
    'name': string;
    /**
     * 
     * @type {Status}
     * @memberof EmployeeSessionResponseDtoEmployee
     */
    'status': Status;
    /**
     * 
     * @type {string}
     * @memberof EmployeeSessionResponseDtoEmployee
     */
    'photoUrl': string | null;
}


/**
 * 
 * @export
 * @interface EmployeeShiftResponseDto
 */
export interface EmployeeShiftResponseDto {
    /**
     * 
     * @type {string}
     * @memberof EmployeeShiftResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EmployeeShiftResponseDto
     */
    'employeeId': string;
    /**
     * The orderingBusinessId.
     * @type {number}
     * @memberof EmployeeShiftResponseDto
     */
    'businessId': number;
    /**
     * 
     * @type {string}
     * @memberof EmployeeShiftResponseDto
     */
    'clockInTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeShiftResponseDto
     */
    'clockOutTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof EmployeeShiftResponseDto
     */
    'activeSessionId': string;
    /**
     * 
     * @type {EmployeeShiftResponseDtoEmployee}
     * @memberof EmployeeShiftResponseDto
     */
    'employee': EmployeeShiftResponseDtoEmployee;
}
/**
 * Nested employee details.
 * @export
 * @interface EmployeeShiftResponseDtoEmployee
 */
export interface EmployeeShiftResponseDtoEmployee {
    /**
     * 
     * @type {string}
     * @memberof EmployeeShiftResponseDtoEmployee
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EmployeeShiftResponseDtoEmployee
     */
    'name': string;
    /**
     * 
     * @type {Status}
     * @memberof EmployeeShiftResponseDtoEmployee
     */
    'status': Status;
    /**
     * 
     * @type {string}
     * @memberof EmployeeShiftResponseDtoEmployee
     */
    'photoUrl': string | null;
}


/**
 * 
 * @export
 * @interface EndOfDayReportDto
 */
export interface EndOfDayReportDto {
    /**
     * Report generated at
     * @type {string}
     * @memberof EndOfDayReportDto
     */
    'reportGeneratedAt': string;
    /**
     * Report date start
     * @type {string}
     * @memberof EndOfDayReportDto
     */
    'reportDateStart': string;
    /**
     * Report date end
     * @type {string}
     * @memberof EndOfDayReportDto
     */
    'reportDateEnd': string;
    /**
     * Business ID
     * @type {number}
     * @memberof EndOfDayReportDto
     */
    'businessId': number;
    /**
     * Payment reconciliation
     * @type {Array<PaymentDetailsDto>}
     * @memberof EndOfDayReportDto
     */
    'paymentMethodDetails': Array<PaymentDetailsDto>;
    /**
     * 
     * @type {EndOfDayReportDtoSalesSummary}
     * @memberof EndOfDayReportDto
     */
    'salesSummary': EndOfDayReportDtoSalesSummary;
    /**
     * 
     * @type {EndOfDayReportDtoTaxBreakdown}
     * @memberof EndOfDayReportDto
     */
    'taxBreakdown': EndOfDayReportDtoTaxBreakdown;
    /**
     * Item breakdown
     * @type {Array<ItemBreakdownDto>}
     * @memberof EndOfDayReportDto
     */
    'itemBreakdown': Array<ItemBreakdownDto>;
}
/**
 * Sales summary
 * @export
 * @interface EndOfDayReportDtoSalesSummary
 */
export interface EndOfDayReportDtoSalesSummary {
    /**
     * Total number of orders
     * @type {number}
     * @memberof EndOfDayReportDtoSalesSummary
     */
    'totalOrders': number;
    /**
     * Total sales amount
     * @type {number}
     * @memberof EndOfDayReportDtoSalesSummary
     */
    'totalSales': number;
    /**
     * Net sales amount after adjustments
     * @type {number}
     * @memberof EndOfDayReportDtoSalesSummary
     */
    'netSales': number;
    /**
     * Total amount actually paid
     * @type {number}
     * @memberof EndOfDayReportDtoSalesSummary
     */
    'totalPaid': number;
    /**
     * Total difference
     * @type {number}
     * @memberof EndOfDayReportDtoSalesSummary
     */
    'totalDifference': number;
    /**
     * Total transactions
     * @type {number}
     * @memberof EndOfDayReportDtoSalesSummary
     */
    'totalTransactions': number;
    /**
     * Number of rejected orders
     * @type {number}
     * @memberof EndOfDayReportDtoSalesSummary
     */
    'rejectedOrders': number;
    /**
     * Total rejected sales amount
     * @type {number}
     * @memberof EndOfDayReportDtoSalesSummary
     */
    'rejectedSales': number;
    /**
     * Average sales per order
     * @type {number}
     * @memberof EndOfDayReportDtoSalesSummary
     */
    'averageSales': number;
    /**
     * Total number of items sold
     * @type {number}
     * @memberof EndOfDayReportDtoSalesSummary
     */
    'totalItemsCount': number;
    /**
     * Total refund amount
     * @type {number}
     * @memberof EndOfDayReportDtoSalesSummary
     */
    'totalRefunds': number;
    /**
     * Total discount amount given
     * @type {number}
     * @memberof EndOfDayReportDtoSalesSummary
     */
    'totalDiscounts': number;
    /**
     * Total voucher forfeited amount in cents
     * @type {number}
     * @memberof EndOfDayReportDtoSalesSummary
     */
    'totalVoucherForfeited': number;
}
/**
 * Tax breakdown
 * @export
 * @interface EndOfDayReportDtoTaxBreakdown
 */
export interface EndOfDayReportDtoTaxBreakdown {
    /**
     * Standard tax amount
     * @type {number}
     * @memberof EndOfDayReportDtoTaxBreakdown
     */
    'standardTaxAmount': number;
    /**
     * Premium tax amount
     * @type {number}
     * @memberof EndOfDayReportDtoTaxBreakdown
     */
    'premiumTaxAmount': number;
    /**
     * Total tax amount
     * @type {number}
     * @memberof EndOfDayReportDtoTaxBreakdown
     */
    'totalTaxAmount': number;
    /**
     * Standard tax rate %
     * @type {number}
     * @memberof EndOfDayReportDtoTaxBreakdown
     */
    'standardTaxRate': number;
    /**
     * Premium tax rate %
     * @type {number}
     * @memberof EndOfDayReportDtoTaxBreakdown
     */
    'premiumTaxRate': number;
}
/**
 * 
 * @export
 * @interface EndOfDayReportDtoV3
 */
export interface EndOfDayReportDtoV3 {
    /**
     * Report generated at
     * @type {string}
     * @memberof EndOfDayReportDtoV3
     */
    'reportGeneratedAt': string;
    /**
     * Report date start
     * @type {string}
     * @memberof EndOfDayReportDtoV3
     */
    'reportDateStart': string;
    /**
     * Report date end
     * @type {string}
     * @memberof EndOfDayReportDtoV3
     */
    'reportDateEnd': string;
    /**
     * Business ID
     * @type {number}
     * @memberof EndOfDayReportDtoV3
     */
    'businessId': number;
    /**
     * Payment reconciliation
     * @type {Array<PaymentDetailsDto>}
     * @memberof EndOfDayReportDtoV3
     */
    'paymentMethodDetails': Array<PaymentDetailsDto>;
    /**
     * 
     * @type {EndOfDayReportDtoSalesSummary}
     * @memberof EndOfDayReportDtoV3
     */
    'salesSummary': EndOfDayReportDtoSalesSummary;
    /**
     * 
     * @type {EndOfDayReportDtoV3TaxBreakdown}
     * @memberof EndOfDayReportDtoV3
     */
    'taxBreakdown': EndOfDayReportDtoV3TaxBreakdown;
    /**
     * Item breakdown
     * @type {Array<ItemBreakdownDto>}
     * @memberof EndOfDayReportDtoV3
     */
    'itemBreakdown': Array<ItemBreakdownDto>;
}
/**
 * Tax breakdown
 * @export
 * @interface EndOfDayReportDtoV3TaxBreakdown
 */
export interface EndOfDayReportDtoV3TaxBreakdown {
    /**
     * Tax breakdown by rate
     * @type {Array<TaxRateItem>}
     * @memberof EndOfDayReportDtoV3TaxBreakdown
     */
    'taxRates': Array<TaxRateItem>;
    /**
     * Total tax amount
     * @type {number}
     * @memberof EndOfDayReportDtoV3TaxBreakdown
     */
    'totalTaxAmount': number;
}
/**
 * 
 * @export
 * @interface EndOfDayReportDtoV4
 */
export interface EndOfDayReportDtoV4 {
    /**
     * Report generated at
     * @type {string}
     * @memberof EndOfDayReportDtoV4
     */
    'reportGeneratedAt': string;
    /**
     * Report date start
     * @type {string}
     * @memberof EndOfDayReportDtoV4
     */
    'reportDateStart': string;
    /**
     * Report date end
     * @type {string}
     * @memberof EndOfDayReportDtoV4
     */
    'reportDateEnd': string;
    /**
     * Business ID
     * @type {number}
     * @memberof EndOfDayReportDtoV4
     */
    'businessId': number;
    /**
     * Payment reconciliation
     * @type {Array<PaymentDetailsDto>}
     * @memberof EndOfDayReportDtoV4
     */
    'paymentMethodDetails': Array<PaymentDetailsDto>;
    /**
     * 
     * @type {EndOfDayReportDtoV4SalesSummary}
     * @memberof EndOfDayReportDtoV4
     */
    'salesSummary': EndOfDayReportDtoV4SalesSummary;
    /**
     * 
     * @type {EndOfDayReportDtoV3TaxBreakdown}
     * @memberof EndOfDayReportDtoV4
     */
    'taxBreakdown': EndOfDayReportDtoV3TaxBreakdown;
    /**
     * Item breakdown
     * @type {Array<ItemBreakdownDto>}
     * @memberof EndOfDayReportDtoV4
     */
    'itemBreakdown': Array<ItemBreakdownDto>;
}
/**
 * Sales summary
 * @export
 * @interface EndOfDayReportDtoV4SalesSummary
 */
export interface EndOfDayReportDtoV4SalesSummary {
    /**
     * Total number of orders
     * @type {number}
     * @memberof EndOfDayReportDtoV4SalesSummary
     */
    'totalOrders': number;
    /**
     * Total sales amount
     * @type {number}
     * @memberof EndOfDayReportDtoV4SalesSummary
     */
    'totalSales': number;
    /**
     * Net sales amount after adjustments
     * @type {number}
     * @memberof EndOfDayReportDtoV4SalesSummary
     */
    'netSales': number;
    /**
     * Total amount actually paid
     * @type {number}
     * @memberof EndOfDayReportDtoV4SalesSummary
     */
    'totalPaid': number;
    /**
     * Total difference
     * @type {number}
     * @memberof EndOfDayReportDtoV4SalesSummary
     */
    'totalDifference': number;
    /**
     * Total transactions
     * @type {number}
     * @memberof EndOfDayReportDtoV4SalesSummary
     */
    'totalTransactions': number;
    /**
     * Number of rejected orders
     * @type {number}
     * @memberof EndOfDayReportDtoV4SalesSummary
     */
    'rejectedOrders': number;
    /**
     * Total rejected sales amount
     * @type {number}
     * @memberof EndOfDayReportDtoV4SalesSummary
     */
    'rejectedSales': number;
    /**
     * Average sales per order
     * @type {number}
     * @memberof EndOfDayReportDtoV4SalesSummary
     */
    'averageSales': number;
    /**
     * Total number of items sold
     * @type {number}
     * @memberof EndOfDayReportDtoV4SalesSummary
     */
    'totalItemsCount': number;
    /**
     * Total refund amount
     * @type {number}
     * @memberof EndOfDayReportDtoV4SalesSummary
     */
    'totalRefunds': number;
    /**
     * Total discount amount given
     * @type {number}
     * @memberof EndOfDayReportDtoV4SalesSummary
     */
    'totalDiscounts': number;
    /**
     * Total voucher forfeited amount in cents
     * @type {number}
     * @memberof EndOfDayReportDtoV4SalesSummary
     */
    'totalVoucherForfeited': number;
    /**
     * Total amount of all payment methods
     * @type {number}
     * @memberof EndOfDayReportDtoV4SalesSummary
     */
    'totalPaymentAmount': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EntityType = {
    Product: 'product',
    Menu: 'menu',
    Category: 'category',
    Extra: 'extra',
    Option: 'option',
    Role: 'role',
    Shift: 'shift',
    Employee: 'employee'
} as const;

export type EntityType = typeof EntityType[keyof typeof EntityType];


/**
 * 
 * @export
 * @interface ErrorResponseDto
 */
export interface ErrorResponseDto {
    /**
     * Indicates whether the request was successful
     * @type {boolean}
     * @memberof ErrorResponseDto
     */
    'status': boolean;
    /**
     * Type of error
     * @type {string}
     * @memberof ErrorResponseDto
     */
    'name': string;
    /**
     * Error message
     * @type {string}
     * @memberof ErrorResponseDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ExtendedCategoryDto
 */
export interface ExtendedCategoryDto {
    /**
     * 
     * @type {string}
     * @memberof ExtendedCategoryDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ExtendedCategoryDto
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof ExtendedCategoryDto
     */
    'image': object | null;
    /**
     * 
     * @type {number}
     * @memberof ExtendedCategoryDto
     */
    'rank': number;
    /**
     * 
     * @type {boolean}
     * @memberof ExtendedCategoryDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {object}
     * @memberof ExtendedCategoryDto
     */
    'header': object | null;
    /**
     * 
     * @type {object}
     * @memberof ExtendedCategoryDto
     */
    'description': object | null;
    /**
     * 
     * @type {Array<ExtendedProductDto>}
     * @memberof ExtendedCategoryDto
     */
    'products': Array<ExtendedProductDto>;
    /**
     * 
     * @type {Array<SubcategoryDto>}
     * @memberof ExtendedCategoryDto
     */
    'subcategories': Array<SubcategoryDto>;
    /**
     * Category color code in hex format
     * @type {string}
     * @memberof ExtendedCategoryDto
     */
    'custom_color_code'?: string;
    /**
     * Category color code in hex format
     * @type {string}
     * @memberof ExtendedCategoryDto
     */
    'colorCode'?: string;
}
/**
 * 
 * @export
 * @interface ExtendedProductDto
 */
export interface ExtendedProductDto {
    /**
     * Product ID
     * @type {number}
     * @memberof ExtendedProductDto
     */
    'id': number;
    /**
     * Product name
     * @type {string}
     * @memberof ExtendedProductDto
     */
    'name': string;
    /**
     * Product price
     * @type {number}
     * @memberof ExtendedProductDto
     */
    'price': number;
    /**
     * Product description
     * @type {string}
     * @memberof ExtendedProductDto
     */
    'description': string;
    /**
     * Product image URL
     * @type {string}
     * @memberof ExtendedProductDto
     */
    'images': string;
    /**
     * Category ID the product belongs to
     * @type {number}
     * @memberof ExtendedProductDto
     */
    'category_id': number;
    /**
     * Whether the product is tracked for inventory
     * @type {boolean}
     * @memberof ExtendedProductDto
     */
    'inventoried': boolean;
    /**
     * Available quantity if inventoried
     * @type {number}
     * @memberof ExtendedProductDto
     */
    'quantity': number;
    /**
     * Whether the product is marked as featured
     * @type {boolean}
     * @memberof ExtendedProductDto
     */
    'featured': boolean;
    /**
     * Whether the product is currently enabled
     * @type {boolean}
     * @memberof ExtendedProductDto
     */
    'enabled': boolean;
    /**
     * Whether upselling is enabled for this product
     * @type {boolean}
     * @memberof ExtendedProductDto
     */
    'upselling': boolean;
    /**
     * Whether the product is part of an offer
     * @type {boolean}
     * @memberof ExtendedProductDto
     */
    'in_offer': boolean;
    /**
     * Offer price if applicable
     * @type {object}
     * @memberof ExtendedProductDto
     */
    'offer_price': object | null;
    /**
     * Display order rank of the product
     * @type {number}
     * @memberof ExtendedProductDto
     */
    'rank': number;
    /**
     * Weight unit (e.g., g, kg, ml)
     * @type {object}
     * @memberof ExtendedProductDto
     */
    'weight_unit': object;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof ExtendedProductDto
     */
    'updated_at': string;
    /**
     * Product creation timestamp
     * @type {string}
     * @memberof ExtendedProductDto
     */
    'created_at': string;
    /**
     * Deletion timestamp if soft-deleted
     * @type {object}
     * @memberof ExtendedProductDto
     */
    'deleted_at': object | null;
    /**
     * List of product extras (e.g., toppings, add-ons)
     * @type {Array<OrderingItemExtraDto>}
     * @memberof ExtendedProductDto
     */
    'extras': Array<OrderingItemExtraDto>;
    /**
     * Whether the product is restricted
     * @type {boolean}
     * @memberof ExtendedProductDto
     */
    'is_restricted': boolean;
    /**
     * 
     * @type {BusinessTaxResponseDto}
     * @memberof ExtendedProductDto
     */
    'tax': BusinessTaxResponseDto | null;
    /**
     * Product color code in hex format
     * @type {string}
     * @memberof ExtendedProductDto
     */
    'colorCode'?: string;
    /**
     * 
     * @type {PrinterTypeEnum}
     * @memberof ExtendedProductDto
     */
    'printer_type'?: PrinterTypeEnum;
    /**
     * Custom UI override color in hex, e.g., #RRGGBB
     * @type {string}
     * @memberof ExtendedProductDto
     */
    'custom_color_code'?: string;
    /**
     * Whether the product has a display label
     * @type {boolean}
     * @memberof ExtendedProductDto
     */
    'display_photo'?: boolean;
    /**
     * 
     * @type {PosItemDtoReportingCategory}
     * @memberof ExtendedProductDto
     */
    'reporting_category'?: PosItemDtoReportingCategory | null;
    /**
     * Indicates if the product is inventoried in POS
     * @type {boolean}
     * @memberof ExtendedProductDto
     */
    'pos_inventoried': boolean;
    /**
     * Quantity of the product in POS
     * @type {number}
     * @memberof ExtendedProductDto
     */
    'pos_quantity': number;
    /**
     * Channel config of inventoried per product
     * @type {Array<ChannelConfig>}
     * @memberof ExtendedProductDto
     */
    'channel_configs': Array<ChannelConfig>;
}


/**
 * 
 * @export
 * @interface ExternalBusinessConfigDto
 */
export interface ExternalBusinessConfigDto {
    /**
     * 
     * @type {string}
     * @memberof ExternalBusinessConfigDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalBusinessConfigDto
     */
    'timeZone': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalBusinessConfigDto
     */
    'currency': string;
    /**
     * 
     * @type {BusinessConfigResponseDtoBusiness}
     * @memberof ExternalBusinessConfigDto
     */
    'business': BusinessConfigResponseDtoBusiness;
    /**
     * 
     * @type {string}
     * @memberof ExternalBusinessConfigDto
     */
    'locationId': string;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof ExternalBusinessConfigDto
     */
    'selectedPaymentProvider'?: PaymentProvider | null;
    /**
     * 
     * @type {Array<PaymentProviderResponseDto>}
     * @memberof ExternalBusinessConfigDto
     */
    'paymentProviders': Array<PaymentProviderResponseDto>;
    /**
     * 
     * @type {string}
     * @memberof ExternalBusinessConfigDto
     */
    'companyName'?: string | null;
    /**
     * Indicates if the business has a loyalty program linked
     * @type {boolean}
     * @memberof ExternalBusinessConfigDto
     */
    'hasLoyaltyProgram': boolean;
    /**
     * Indicates if the business has a invoice company linked
     * @type {boolean}
     * @memberof ExternalBusinessConfigDto
     */
    'hasInvoiceCompany': boolean;
}


/**
 * 
 * @export
 * @interface ExternalBusinessConfigResponseDto
 */
export interface ExternalBusinessConfigResponseDto {
    /**
     * Unique identifier of the business
     * @type {string}
     * @memberof ExternalBusinessConfigResponseDto
     */
    'id': string;
    /**
     * Name of the business
     * @type {string}
     * @memberof ExternalBusinessConfigResponseDto
     */
    'name': string;
    /**
     * Logo of the business
     * @type {string}
     * @memberof ExternalBusinessConfigResponseDto
     */
    'logo': string;
    /**
     * Email of the business
     * @type {string}
     * @memberof ExternalBusinessConfigResponseDto
     */
    'email'?: string;
    /**
     * Address of the business
     * @type {string}
     * @memberof ExternalBusinessConfigResponseDto
     */
    'address'?: string;
    /**
     * Creation date of the business
     * @type {string}
     * @memberof ExternalBusinessConfigResponseDto
     */
    'createdAt': string;
    /**
     * Phone number of the business
     * @type {string}
     * @memberof ExternalBusinessConfigResponseDto
     */
    'phone'?: string;
    /**
     * Ordering business identifier
     * @type {number}
     * @memberof ExternalBusinessConfigResponseDto
     */
    'orderingBusinessId': number;
    /**
     * BIC/SWIFT code of the business
     * @type {string}
     * @memberof ExternalBusinessConfigResponseDto
     */
    'bic': string | null;
    /**
     * Whether the business is enabled
     * @type {boolean}
     * @memberof ExternalBusinessConfigResponseDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof ExternalBusinessConfigResponseDto
     */
    'chainId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalBusinessConfigResponseDto
     */
    'merchantId'?: string;
    /**
     * 
     * @type {ExternalBusinessConfigDto}
     * @memberof ExternalBusinessConfigResponseDto
     */
    'config': ExternalBusinessConfigDto;
}
/**
 * 
 * @export
 * @interface FirebasePosOrderResponse
 */
export interface FirebasePosOrderResponse {
    /**
     * 
     * @type {string}
     * @memberof FirebasePosOrderResponse
     */
    'id': string;
    /**
     * Creation time of the order
     * @type {string}
     * @memberof FirebasePosOrderResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {TaxDetailsDto}
     * @memberof FirebasePosOrderResponse
     */
    'taxDetails': TaxDetailsDto;
    /**
     * 
     * @type {CartOrderDto}
     * @memberof FirebasePosOrderResponse
     */
    'cartOrder': CartOrderDto;
    /**
     * 
     * @type {OrderStatusEnum}
     * @memberof FirebasePosOrderResponse
     */
    'status'?: OrderStatusEnum;
    /**
     * 
     * @type {FirebasePosOrderResponseUpdatedAt}
     * @memberof FirebasePosOrderResponse
     */
    'updatedAt'?: FirebasePosOrderResponseUpdatedAt;
}


/**
 * Last update time (original format)
 * @export
 * @interface FirebasePosOrderResponseUpdatedAt
 */
export interface FirebasePosOrderResponseUpdatedAt {
    /**
     * Seconds since Unix epoch
     * @type {number}
     * @memberof FirebasePosOrderResponseUpdatedAt
     */
    '_seconds': number;
    /**
     * Nanoseconds component
     * @type {number}
     * @memberof FirebasePosOrderResponseUpdatedAt
     */
    '_nanoseconds': number;
}
/**
 * 
 * @export
 * @interface FirebaseTimeDto
 */
export interface FirebaseTimeDto {
    /**
     * Seconds since Unix epoch
     * @type {number}
     * @memberof FirebaseTimeDto
     */
    '_seconds': number;
    /**
     * Nanoseconds component
     * @type {number}
     * @memberof FirebaseTimeDto
     */
    '_nanoseconds': number;
}
/**
 * 
 * @export
 * @interface FirebaseTokenDto
 */
export interface FirebaseTokenDto {
    /**
     * A short-lived Firebase custom token for client-side sign-in.
     * @type {string}
     * @memberof FirebaseTokenDto
     */
    'customToken': string;
}
/**
 * 
 * @export
 * @interface GenerateCodeDto
 */
export interface GenerateCodeDto {
    /**
     * User cellphone number
     * @type {string}
     * @memberof GenerateCodeDto
     */
    'cellphone': string;
    /**
     * Country phone code
     * @type {string}
     * @memberof GenerateCodeDto
     */
    'countryPhoneCode': string;
    /**
     * 
     * @type {VerificationType}
     * @memberof GenerateCodeDto
     */
    'verificationType': VerificationType;
    /**
     * 
     * @type {CodeChannel}
     * @memberof GenerateCodeDto
     */
    'channel': CodeChannel;
}


/**
 * 
 * @export
 * @interface GenerateCodeResponseDto
 */
export interface GenerateCodeResponseDto {
    /**
     * 
     * @type {string}
     * @memberof GenerateCodeResponseDto
     */
    'result': string;
}
/**
 * 
 * @export
 * @interface GetPaymentStatusDto
 */
export interface GetPaymentStatusDto {
    /**
     * 
     * @type {PaymentProvider}
     * @memberof GetPaymentStatusDto
     */
    'provider': PaymentProvider;
    /**
     * The session ID or reference ID from the payment provider (e.g., Viva sessionId).
     * @type {string}
     * @memberof GetPaymentStatusDto
     */
    'referenceId': string;
    /**
     * The ordering business ID for this transaction.
     * @type {number}
     * @memberof GetPaymentStatusDto
     */
    'businessId': number;
    /**
     * The order ID associated with this payment (optional, returned in response for convenience).
     * @type {string}
     * @memberof GetPaymentStatusDto
     */
    'orderId'?: string;
}


/**
 * 
 * @export
 * @interface GetStationResponseDto
 */
export interface GetStationResponseDto {
    /**
     * 
     * @type {GetStationResponseDtoStation}
     * @memberof GetStationResponseDto
     */
    'station': GetStationResponseDtoStation | null;
}
/**
 * The station details.
 * @export
 * @interface GetStationResponseDtoStation
 */
export interface GetStationResponseDtoStation {
    /**
     * 
     * @type {string}
     * @memberof GetStationResponseDtoStation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetStationResponseDtoStation
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetStationResponseDtoStation
     */
    'hardwareId': string;
    /**
     * 
     * @type {StationType}
     * @memberof GetStationResponseDtoStation
     */
    'type': StationType;
    /**
     * 
     * @type {Status}
     * @memberof GetStationResponseDtoStation
     */
    'status': Status;
    /**
     * 
     * @type {number}
     * @memberof GetStationResponseDtoStation
     */
    'orderingBusinessId': number;
    /**
     * 
     * @type {string}
     * @memberof GetStationResponseDtoStation
     */
    'prefix': string;
    /**
     * 
     * @type {object}
     * @memberof GetStationResponseDtoStation
     */
    'metadata'?: object;
    /**
     * Timestamp when the station record was created.
     * @type {string}
     * @memberof GetStationResponseDtoStation
     */
    'createdAt': string;
    /**
     * Timestamp when the station record was last updated.
     * @type {string}
     * @memberof GetStationResponseDtoStation
     */
    'updatedAt': string;
    /**
     * 
     * @type {StationDetailsDtoPaymentTerminal}
     * @memberof GetStationResponseDtoStation
     */
    'paymentTerminal'?: StationDetailsDtoPaymentTerminal | null;
}


/**
 * 
 * @export
 * @interface GetSupportedChannelsResponseDto
 */
export interface GetSupportedChannelsResponseDto {
    /**
     * 
     * @type {Array<SupportedChannelDto>}
     * @memberof GetSupportedChannelsResponseDto
     */
    'channels': Array<SupportedChannelDto>;
}
/**
 * 
 * @export
 * @interface GetUserInfoResponseDto
 */
export interface GetUserInfoResponseDto {
    /**
     * 
     * @type {UserInfoResponseDto}
     * @memberof GetUserInfoResponseDto
     */
    'userInfo': UserInfoResponseDto;
    /**
     * 
     * @type {string}
     * @memberof GetUserInfoResponseDto
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserInfoResponseDto
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface GiftCardInfoDto
 */
export interface GiftCardInfoDto {
    /**
     * 
     * @type {string}
     * @memberof GiftCardInfoDto
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof GiftCardInfoDto
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof GiftCardInfoDto
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof GiftCardInfoDto
     */
    'expirationDate': string;
    /**
     * 
     * @type {boolean}
     * @memberof GiftCardInfoDto
     */
    'mustBeFullyRedeemed': boolean;
    /**
     * 
     * @type {string}
     * @memberof GiftCardInfoDto
     */
    'giftCardNumber': string;
}
/**
 * 
 * @export
 * @interface ImageBackgroundConfig
 */
export interface ImageBackgroundConfig {
    /**
     * Opacity of the overlay
     * @type {number}
     * @memberof ImageBackgroundConfig
     */
    'overlayOpacity': number;
    /**
     * Color of the overlay
     * @type {string}
     * @memberof ImageBackgroundConfig
     */
    'overlayColor'?: string;
    /**
     * 
     * @type {BusinessBackgroundType}
     * @memberof ImageBackgroundConfig
     */
    'type': BusinessBackgroundType;
    /**
     * URL of the image
     * @type {string}
     * @memberof ImageBackgroundConfig
     */
    'url': string;
    /**
     * Blur radius in pixels
     * @type {number}
     * @memberof ImageBackgroundConfig
     */
    'blurRadius'?: number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const IntegrationType = {
    Orders: 'ORDERS',
    Menu: 'MENU',
    Venue: 'VENUE'
} as const;

export type IntegrationType = typeof IntegrationType[keyof typeof IntegrationType];


/**
 * 
 * @export
 * @interface InvoiceCompanyResponseDto
 */
export interface InvoiceCompanyResponseDto {
    /**
     * 
     * @type {string}
     * @memberof InvoiceCompanyResponseDto
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceCompanyResponseDto
     */
    'businessId': number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceCompanyResponseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceCompanyResponseDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceCompanyResponseDto
     */
    'countryCode': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceCompanyResponseDto
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceCompanyResponseDto
     */
    'bic'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceCompanyResponseDto
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceCompanyResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceCompanyResponseDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface IsvDetails
 */
export interface IsvDetails {
    /**
     * The amount related to the ISV (Independent Software Vendor).
     * @type {number}
     * @memberof IsvDetails
     */
    'amount'?: number;
    /**
     * The terminal merchant ID associated with the ISV.
     * @type {string}
     * @memberof IsvDetails
     */
    'terminalMerchantId'?: string;
    /**
     * The source code for the ISV.
     * @type {string}
     * @memberof IsvDetails
     */
    'sourceCode'?: string;
    /**
     * The merchant ID for the ISV.
     * @type {string}
     * @memberof IsvDetails
     */
    'merchantId'?: string;
    /**
     * The merchant source code for the ISV.
     * @type {string}
     * @memberof IsvDetails
     */
    'merchantSourceCode'?: string;
}
/**
 * 
 * @export
 * @interface ItemBreakdownDto
 */
export interface ItemBreakdownDto {
    /**
     * Item name
     * @type {string}
     * @memberof ItemBreakdownDto
     */
    'itemName': string;
    /**
     * Quantity sold
     * @type {number}
     * @memberof ItemBreakdownDto
     */
    'quantitySold': number;
    /**
     * Total amount
     * @type {number}
     * @memberof ItemBreakdownDto
     */
    'totalAmount': number;
}
/**
 * 
 * @export
 * @interface ItemPriceBreakdownDto
 */
export interface ItemPriceBreakdownDto {
    /**
     * 
     * @type {MoneyDto}
     * @memberof ItemPriceBreakdownDto
     */
    'totalBeforeDiscounts': MoneyDto;
    /**
     * 
     * @type {MoneyDto}
     * @memberof ItemPriceBreakdownDto
     */
    'subtotalItemDiscounts': MoneyDto;
    /**
     * 
     * @type {MoneyDto}
     * @memberof ItemPriceBreakdownDto
     */
    'subtotalBasketDiscounts': MoneyDto;
    /**
     * 
     * @type {MoneyDto}
     * @memberof ItemPriceBreakdownDto
     */
    'totalDiscounts': MoneyDto;
    /**
     * 
     * @type {MoneyDto}
     * @memberof ItemPriceBreakdownDto
     */
    'basePriceBeforeDiscounts': MoneyDto;
    /**
     * 
     * @type {MoneyDto}
     * @memberof ItemPriceBreakdownDto
     */
    'unitPriceBeforeDiscounts': MoneyDto;
    /**
     * 
     * @type {MoneyDto}
     * @memberof ItemPriceBreakdownDto
     */
    'subtotalOptionsBasketDiscounts': MoneyDto;
    /**
     * 
     * @type {MoneyDto}
     * @memberof ItemPriceBreakdownDto
     */
    'subtotalOptionsItemDiscounts': MoneyDto;
}
/**
 * 
 * @export
 * @interface ItemPriceDto
 */
export interface ItemPriceDto {
    /**
     * 
     * @type {MoneyDto}
     * @memberof ItemPriceDto
     */
    'unitPrice': MoneyDto;
    /**
     * 
     * @type {MoneyDto}
     * @memberof ItemPriceDto
     */
    'basePrice': MoneyDto;
    /**
     * 
     * @type {number}
     * @memberof ItemPriceDto
     */
    'vatPercentage': number;
    /**
     * 
     * @type {MoneyDto}
     * @memberof ItemPriceDto
     */
    'total': MoneyDto;
    /**
     * 
     * @type {ItemPriceBreakdownDto}
     * @memberof ItemPriceDto
     */
    'priceBreakdown': ItemPriceBreakdownDto;
}
/**
 * 
 * @export
 * @interface KioskDetailsDto
 */
export interface KioskDetailsDto {
    /**
     * The unique ID of the Kiosk.
     * @type {string}
     * @memberof KioskDetailsDto
     */
    'id': string;
    /**
     * The unique ID of the Kiosk hardware.
     * @type {string}
     * @memberof KioskDetailsDto
     */
    'hardwareId': string;
    /**
     * The unique ID of the payment terminal connected to this kiosk, or null if unassigned.
     * @type {string}
     * @memberof KioskDetailsDto
     */
    'paymentTerminalId': string | null;
    /**
     * The display name of the Kiosk.
     * @type {string}
     * @memberof KioskDetailsDto
     */
    'name': string;
    /**
     * 
     * @type {Status}
     * @memberof KioskDetailsDto
     */
    'status': Status;
    /**
     * The prefix used by the kiosk when creating orders.
     * @type {string}
     * @memberof KioskDetailsDto
     */
    'prefix': string;
    /**
     * The business ID the kiosk is registered to.
     * @type {number}
     * @memberof KioskDetailsDto
     */
    'orderingBusinessId': number;
    /**
     * Timestamp when the kiosk record was created.
     * @type {string}
     * @memberof KioskDetailsDto
     */
    'createdAt': string;
    /**
     * Timestamp when the kiosk record was last updated.
     * @type {string}
     * @memberof KioskDetailsDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {KioskDetailsDtoPaymentTerminal}
     * @memberof KioskDetailsDto
     */
    'paymentTerminal': KioskDetailsDtoPaymentTerminal | null;
}


/**
 * The payment terminal connected to this kiosk, or null if unassigned.
 * @export
 * @interface KioskDetailsDtoPaymentTerminal
 */
export interface KioskDetailsDtoPaymentTerminal {
    /**
     * The unique ID of the Payment Terminal.
     * @type {string}
     * @memberof KioskDetailsDtoPaymentTerminal
     */
    'id': string;
    /**
     * The unique ID of the Payment Terminal.
     * @type {string}
     * @memberof KioskDetailsDtoPaymentTerminal
     */
    'hardwareId': string;
    /**
     * The unique ID of the Payment Terminal.
     * @type {string}
     * @memberof KioskDetailsDtoPaymentTerminal
     */
    'label': string | null;
    /**
     * The unique ID of the Payment Terminal.
     * @type {string}
     * @memberof KioskDetailsDtoPaymentTerminal
     */
    'orderingBusinessId': string;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof KioskDetailsDtoPaymentTerminal
     */
    'provider': PaymentProvider;
    /**
     * Timestamp when the payment terminal record was last updated.
     * @type {string}
     * @memberof KioskDetailsDtoPaymentTerminal
     */
    'updatedAt': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const KioskEventType = {
    StatusUpdated: 'kiosk.status.updated',
    ConfigUpdated: 'kiosk.config.updated'
} as const;

export type KioskEventType = typeof KioskEventType[keyof typeof KioskEventType];


/**
 * 
 * @export
 * @enum {string}
 */

export const KioskLayout = {
    Vertical: 'VERTICAL',
    Horizontal: 'HORIZONTAL'
} as const;

export type KioskLayout = typeof KioskLayout[keyof typeof KioskLayout];


/**
 * 
 * @export
 * @interface KioskResponseDto
 */
export interface KioskResponseDto {
    /**
     * 
     * @type {KioskResponseDtoKiosk}
     * @memberof KioskResponseDto
     */
    'kiosk': KioskResponseDtoKiosk | null;
}
/**
 * The kiosk details.
 * @export
 * @interface KioskResponseDtoKiosk
 */
export interface KioskResponseDtoKiosk {
    /**
     * The unique ID of the Kiosk.
     * @type {string}
     * @memberof KioskResponseDtoKiosk
     */
    'id': string;
    /**
     * The unique ID of the Kiosk hardware.
     * @type {string}
     * @memberof KioskResponseDtoKiosk
     */
    'hardwareId': string;
    /**
     * The unique ID of the payment terminal connected to this kiosk, or null if unassigned.
     * @type {string}
     * @memberof KioskResponseDtoKiosk
     */
    'paymentTerminalId': string | null;
    /**
     * The display name of the Kiosk.
     * @type {string}
     * @memberof KioskResponseDtoKiosk
     */
    'name': string;
    /**
     * 
     * @type {Status}
     * @memberof KioskResponseDtoKiosk
     */
    'status': Status;
    /**
     * The prefix used by the kiosk when creating orders.
     * @type {string}
     * @memberof KioskResponseDtoKiosk
     */
    'prefix': string;
    /**
     * The business ID the kiosk is registered to.
     * @type {number}
     * @memberof KioskResponseDtoKiosk
     */
    'orderingBusinessId': number;
    /**
     * Timestamp when the kiosk record was created.
     * @type {string}
     * @memberof KioskResponseDtoKiosk
     */
    'createdAt': string;
    /**
     * Timestamp when the kiosk record was last updated.
     * @type {string}
     * @memberof KioskResponseDtoKiosk
     */
    'updatedAt': string;
    /**
     * 
     * @type {KioskDetailsDtoPaymentTerminal}
     * @memberof KioskResponseDtoKiosk
     */
    'paymentTerminal': KioskDetailsDtoPaymentTerminal | null;
}


/**
 * 
 * @export
 * @interface KioskStatusDto
 */
export interface KioskStatusDto {
    /**
     * The open status of the kiosk.
     * @type {boolean}
     * @memberof KioskStatusDto
     */
    'open': boolean;
    /**
     * 
     * @type {BusinessEventType}
     * @memberof KioskStatusDto
     */
    'event': BusinessEventType;
    /**
     * 
     * @type {KioskEventType}
     * @memberof KioskStatusDto
     */
    'kiosk_event': KioskEventType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const KitchenStatus = {
    NotApplicable: 'not_applicable',
    Pending: 'pending',
    OnHold: 'on_hold',
    SentToOm: 'sent_to_om',
    DispatchedToKitchen: 'dispatched_to_kitchen',
    Completed: 'completed',
    Cancelled: 'cancelled'
} as const;

export type KitchenStatus = typeof KitchenStatus[keyof typeof KitchenStatus];


/**
 * 
 * @export
 * @interface LapseDto
 */
export interface LapseDto {
    /**
     * 
     * @type {LapseDtoOpen}
     * @memberof LapseDto
     */
    'open': LapseDtoOpen;
    /**
     * 
     * @type {LapseDtoClose}
     * @memberof LapseDto
     */
    'close': LapseDtoClose;
}
/**
 * Closing time for the lapse
 * @export
 * @interface LapseDtoClose
 */
export interface LapseDtoClose {
    /**
     * Hour component of the time (0-23)
     * @type {number}
     * @memberof LapseDtoClose
     */
    'hour': number;
    /**
     * Minute component of the time (0-59)
     * @type {number}
     * @memberof LapseDtoClose
     */
    'minute': number;
}
/**
 * Opening time for the lapse
 * @export
 * @interface LapseDtoOpen
 */
export interface LapseDtoOpen {
    /**
     * Hour component of the time (0-23)
     * @type {number}
     * @memberof LapseDtoOpen
     */
    'hour': number;
    /**
     * Minute component of the time (0-59)
     * @type {number}
     * @memberof LapseDtoOpen
     */
    'minute': number;
}
/**
 * 
 * @export
 * @interface LocationDto
 */
export interface LocationDto {
    /**
     * Location ID
     * @type {string}
     * @memberof LocationDto
     */
    'id': string;
    /**
     * Formatted address
     * @type {string}
     * @memberof LocationDto
     */
    'formatted_address': string | null;
    /**
     * City
     * @type {string}
     * @memberof LocationDto
     */
    'city': string | null;
    /**
     * Country
     * @type {string}
     * @memberof LocationDto
     */
    'country': string | null;
    /**
     * 
     * @type {LocationDtoCoordinates}
     * @memberof LocationDto
     */
    'coordinates': LocationDtoCoordinates | null;
}
/**
 * Coordinates
 * @export
 * @interface LocationDtoCoordinates
 */
export interface LocationDtoCoordinates {
    /**
     * Coordinate ID
     * @type {string}
     * @memberof LocationDtoCoordinates
     */
    'id': string;
    /**
     * Latitude
     * @type {number}
     * @memberof LocationDtoCoordinates
     */
    'lat': number;
    /**
     * Longitude
     * @type {number}
     * @memberof LocationDtoCoordinates
     */
    'lon': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const LocatorType = {
    Table: 'table',
    Indicator: 'indicator'
} as const;

export type LocatorType = typeof LocatorType[keyof typeof LocatorType];


/**
 * 
 * @export
 * @interface LoginResponseDto
 */
export interface LoginResponseDto {
    /**
     * Access token used for authenticated API requests
     * @type {string}
     * @memberof LoginResponseDto
     */
    'accessToken'?: string;
    /**
     * Refresh token to obtain a new access token
     * @type {string}
     * @memberof LoginResponseDto
     */
    'refreshToken'?: string;
    /**
     * 
     * @type {LoginResponseDtoUserInfo}
     * @memberof LoginResponseDto
     */
    'userInfo': LoginResponseDtoUserInfo;
}
/**
 * Detailed user information after successful login
 * @export
 * @interface LoginResponseDtoUserInfo
 */
export interface LoginResponseDtoUserInfo {
    /**
     * Unique identifier of the user
     * @type {number}
     * @memberof LoginResponseDtoUserInfo
     */
    'id': number;
    /**
     * Full name of the user
     * @type {string}
     * @memberof LoginResponseDtoUserInfo
     */
    'name': string;
    /**
     * Email address of the user
     * @type {string}
     * @memberof LoginResponseDtoUserInfo
     */
    'email': string;
    /**
     * Users cellphone number
     * @type {string}
     * @memberof LoginResponseDtoUserInfo
     */
    'cellphone': string;
    /**
     * Country dialing code for the phone number
     * @type {string}
     * @memberof LoginResponseDtoUserInfo
     */
    'countryPhoneCode': string;
    /**
     * Whether the phone number is verified
     * @type {boolean}
     * @memberof LoginResponseDtoUserInfo
     */
    'phoneVerified': boolean;
    /**
     * Session token used for ordering authorization
     * @type {string}
     * @memberof LoginResponseDtoUserInfo
     */
    'orderingAccessToken': string;
}
/**
 * 
 * @export
 * @interface LogoutResponseDto
 */
export interface LogoutResponseDto {
    /**
     * 
     * @type {string}
     * @memberof LogoutResponseDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface LoyaltyAccountDto
 */
export interface LoyaltyAccountDto {
    /**
     * 
     * @type {number}
     * @memberof LoyaltyAccountDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof LoyaltyAccountDto
     */
    'user_id': number;
    /**
     * 
     * @type {number}
     * @memberof LoyaltyAccountDto
     */
    'lifetime_points': number;
    /**
     * 
     * @type {string}
     * @memberof LoyaltyAccountDto
     */
    'joined_date': string;
    /**
     * 
     * @type {string}
     * @memberof LoyaltyAccountDto
     */
    'last_activity_date': string;
    /**
     * 
     * @type {boolean}
     * @memberof LoyaltyAccountDto
     */
    'is_active': boolean;
    /**
     * 
     * @type {number}
     * @memberof LoyaltyAccountDto
     */
    'venue_id': number;
    /**
     * 
     * @type {string}
     * @memberof LoyaltyAccountDto
     */
    'loyalty_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof LoyaltyAccountDto
     */
    'is_subscribed_to_promotions': boolean;
    /**
     * 
     * @type {string}
     * @memberof LoyaltyAccountDto
     */
    'joined_At': string;
    /**
     * 
     * @type {LoyaltyTierDto}
     * @memberof LoyaltyAccountDto
     */
    'current_tier': LoyaltyTierDto | null;
    /**
     * 
     * @type {NextTierDto}
     * @memberof LoyaltyAccountDto
     */
    'next_tier': NextTierDto;
    /**
     * 
     * @type {boolean}
     * @memberof LoyaltyAccountDto
     */
    'joined': boolean;
    /**
     * 
     * @type {number}
     * @memberof LoyaltyAccountDto
     */
    'current_points': number;
    /**
     * 
     * @type {Array<PointsBreakdownDto>}
     * @memberof LoyaltyAccountDto
     */
    'points_breakdown': Array<PointsBreakdownDto>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const LoyaltyActionKey = {
    Self: 'self',
    GetUserById: 'getUserById',
    SearchUser: 'searchUser',
    AddPoints: 'addPoints',
    GetAdminHistory: 'getAdminHistory'
} as const;

export type LoyaltyActionKey = typeof LoyaltyActionKey[keyof typeof LoyaltyActionKey];


/**
 * 
 * @export
 * @interface LoyaltyInfoResponseDto
 */
export interface LoyaltyInfoResponseDto {
    /**
     * 
     * @type {string}
     * @memberof LoyaltyInfoResponseDto
     */
    'loyaltyId': string;
    /**
     * 
     * @type {number}
     * @memberof LoyaltyInfoResponseDto
     */
    'venueId': number;
    /**
     * 
     * @type {string}
     * @memberof LoyaltyInfoResponseDto
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LoyaltyInfoResponseDto
     */
    'description': Array<string>;
    /**
     * 
     * @type {object}
     * @memberof LoyaltyInfoResponseDto
     */
    'logo_url': object | null;
    /**
     * 
     * @type {object}
     * @memberof LoyaltyInfoResponseDto
     */
    'banner_url': object | null;
    /**
     * 
     * @type {object}
     * @memberof LoyaltyInfoResponseDto
     */
    'expires_at': object | null;
    /**
     * 
     * @type {{ [key: string]: LoyaltyInfoResponseDtoLinksValue; }}
     * @memberof LoyaltyInfoResponseDto
     */
    '_links': { [key: string]: LoyaltyInfoResponseDtoLinksValue; };
}
/**
 * 
 * @export
 * @interface LoyaltyInfoResponseDtoLinksValue
 */
export interface LoyaltyInfoResponseDtoLinksValue {
    /**
     * 
     * @type {string}
     * @memberof LoyaltyInfoResponseDtoLinksValue
     */
    'href'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoyaltyInfoResponseDtoLinksValue
     */
    'method'?: string;
}
/**
 * 
 * @export
 * @interface LoyaltyLinkDto
 */
export interface LoyaltyLinkDto {
    /**
     * Unique identifier for the loyalty link
     * @type {string}
     * @memberof LoyaltyLinkDto
     */
    'id': string;
    /**
     * ID of the associated business
     * @type {number}
     * @memberof LoyaltyLinkDto
     */
    'businessId': number;
    /**
     * ID of the linked loyalty program
     * @type {string}
     * @memberof LoyaltyLinkDto
     */
    'loyaltyProgramId': string;
    /**
     * 
     * @type {LoyaltyLinkDtoMetadata}
     * @memberof LoyaltyLinkDto
     */
    'metadata': LoyaltyLinkDtoMetadata;
    /**
     * Creation date and time in ISO 8601 format
     * @type {string}
     * @memberof LoyaltyLinkDto
     */
    'createdAt': string;
    /**
     * Last update date and time in ISO 8601 format
     * @type {string}
     * @memberof LoyaltyLinkDto
     */
    'updatedAt': string;
}
/**
 * Metadata for the loyalty link
 * @export
 * @interface LoyaltyLinkDtoMetadata
 */
export interface LoyaltyLinkDtoMetadata {
    /**
     * Venue ID within the loyalty program
     * @type {number}
     * @memberof LoyaltyLinkDtoMetadata
     */
    'venueId': number;
}
/**
 * 
 * @export
 * @interface LoyaltyLinkMetadataDto
 */
export interface LoyaltyLinkMetadataDto {
    /**
     * Venue ID within the loyalty program
     * @type {number}
     * @memberof LoyaltyLinkMetadataDto
     */
    'venueId': number;
}
/**
 * 
 * @export
 * @interface LoyaltyTierDto
 */
export interface LoyaltyTierDto {
    /**
     * 
     * @type {number}
     * @memberof LoyaltyTierDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof LoyaltyTierDto
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LoyaltyTierDto
     */
    'description': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof LoyaltyTierDto
     */
    'threshold': number;
}
/**
 * 
 * @export
 * @interface LoyaltyUserDto
 */
export interface LoyaltyUserDto {
    /**
     * The ID of the user
     * @type {number}
     * @memberof LoyaltyUserDto
     */
    'id': number;
    /**
     * The landline phone number of the user
     * @type {object}
     * @memberof LoyaltyUserDto
     */
    'phone': object | null;
    /**
     * The mobile phone number of the user
     * @type {string}
     * @memberof LoyaltyUserDto
     */
    'cellphone': string;
    /**
     * The first name of the user
     * @type {string}
     * @memberof LoyaltyUserDto
     */
    'name': string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof LoyaltyUserDto
     */
    'lastname': string;
    /**
     * The level of the user
     * @type {number}
     * @memberof LoyaltyUserDto
     */
    'level': number;
    /**
     * Whether the user account is enabled
     * @type {boolean}
     * @memberof LoyaltyUserDto
     */
    'enabled': boolean;
    /**
     * The address of the user
     * @type {object}
     * @memberof LoyaltyUserDto
     */
    'address': object | null;
    /**
     * Loyalty points accumulated by the user
     * @type {number}
     * @memberof LoyaltyUserDto
     */
    'loyalty_level_points': number;
    /**
     * Country code of the user
     * @type {string}
     * @memberof LoyaltyUserDto
     */
    'country_code': string;
    /**
     * Number of orders placed by the user
     * @type {number}
     * @memberof LoyaltyUserDto
     */
    'orders_count': number;
    /**
     * URL to the user\'s profile photo
     * @type {object}
     * @memberof LoyaltyUserDto
     */
    'photo': object | null;
    /**
     * List of wallets associated with the user
     * @type {Array<WalletDto>}
     * @memberof LoyaltyUserDto
     */
    'wallets': Array<WalletDto>;
}
/**
 * 
 * @export
 * @interface LoyaltyUserInfoResponseDto
 */
export interface LoyaltyUserInfoResponseDto {
    /**
     * 
     * @type {ProgramUserDto}
     * @memberof LoyaltyUserInfoResponseDto
     */
    'user': ProgramUserDto;
    /**
     * 
     * @type {LoyaltyAccountDto}
     * @memberof LoyaltyUserInfoResponseDto
     */
    'loyaltyAccount': LoyaltyAccountDto;
    /**
     * 
     * @type {{ [key: string]: LoyaltyInfoResponseDtoLinksValue; }}
     * @memberof LoyaltyUserInfoResponseDto
     */
    '_links': { [key: string]: LoyaltyInfoResponseDtoLinksValue; };
}
/**
 * 
 * @export
 * @interface ManualRefundPayload
 */
export interface ManualRefundPayload {
    /**
     * Unique internal ID for this refund transaction
     * @type {string}
     * @memberof ManualRefundPayload
     */
    'id': string;
    /**
     * Unique internal ID for this refund transaction
     * @type {string}
     * @memberof ManualRefundPayload
     */
    'refundId': string;
    /**
     * Refund ID from the payment provider (e.g., Stripe refund ID). Deprecated soon
     * @type {string}
     * @memberof ManualRefundPayload
     */
    'providerRefundId': string;
    /**
     * Refund ID from the payment provider V2 (e.g., Stripe refund ID)
     * @type {string}
     * @memberof ManualRefundPayload
     */
    'sourceTransactionId': string | null;
    /**
     * ID of the original payment being refunded
     * @type {string}
     * @memberof ManualRefundPayload
     * @deprecated
     */
    'originalPaymentId'?: string | null;
    /**
     * ID of the original payment being refunded
     * @type {string}
     * @memberof ManualRefundPayload
     */
    'originalPaymentEventId'?: string | null;
    /**
     * 
     * @type {PaymentProviderEnum}
     * @memberof ManualRefundPayload
     */
    'paymentProvider': PaymentProviderEnum;
    /**
     * The amount refunded
     * @type {number}
     * @memberof ManualRefundPayload
     */
    'amount': number;
    /**
     * Currency of the refund (ISO 4217 code, e.g., EUR)
     * @type {string}
     * @memberof ManualRefundPayload
     */
    'currency': string;
    /**
     * 
     * @type {RefundStatusEnum}
     * @memberof ManualRefundPayload
     */
    'status': RefundStatusEnum;
    /**
     * Timestamp when the refund was processed
     * @type {string}
     * @memberof ManualRefundPayload
     */
    'processedAt': string;
    /**
     * Reason for the refund
     * @type {string}
     * @memberof ManualRefundPayload
     */
    'reason'?: string | null;
    /**
     * Specific items refunded
     * @type {Array<RefundedItemDto>}
     * @memberof ManualRefundPayload
     */
    'items'?: Array<RefundedItemDto>;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof ManualRefundPayload
     */
    'type'?: PaymentMethod;
    /**
     * Additional metadata from the payment provider or system
     * @type {{ [key: string]: any; }}
     * @memberof ManualRefundPayload
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The ordering business ID for this transaction.
     * @type {number}
     * @memberof ManualRefundPayload
     */
    'orderingBusinessId': number;
    /**
     * The POS order id for this transaction.
     * @type {string}
     * @memberof ManualRefundPayload
     */
    'posOrderId': string;
}


/**
 * 
 * @export
 * @interface MenuDto
 */
export interface MenuDto {
    /**
     * 
     * @type {string}
     * @memberof MenuDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MenuDto
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MenuDto
     */
    'cid': Array<string>;
}
/**
 * 
 * @export
 * @interface MenuProductDto
 */
export interface MenuProductDto {
    /**
     * Product ID from Ordering
     * @type {number}
     * @memberof MenuProductDto
     */
    'id': number;
    /**
     * Category ID in Ordering
     * @type {number}
     * @memberof MenuProductDto
     */
    'categoryId': number;
    /**
     * Visibility flag
     * @type {boolean}
     * @memberof MenuProductDto
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface MenuProductDtoV2
 */
export interface MenuProductDtoV2 {
    /**
     * Product ID from Ordering
     * @type {number}
     * @memberof MenuProductDtoV2
     */
    'id': number;
    /**
     * Category ID in Ordering
     * @type {number}
     * @memberof MenuProductDtoV2
     */
    'categoryId': number;
    /**
     * Visibility flag
     * @type {boolean}
     * @memberof MenuProductDtoV2
     */
    'enabled': boolean;
    /**
     * 
     * @type {ProductAvailability}
     * @memberof MenuProductDtoV2
     */
    'availabilityStatus': ProductAvailability;
}


/**
 * 
 * @export
 * @interface MenuProductExtraDto
 */
export interface MenuProductExtraDto {
    /**
     * 
     * @type {number}
     * @memberof MenuProductExtraDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof MenuProductExtraDto
     */
    'business_id': number;
    /**
     * 
     * @type {string}
     * @memberof MenuProductExtraDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MenuProductExtraDto
     */
    'description': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MenuProductExtraDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof MenuProductExtraDto
     */
    'external_id': string | null;
    /**
     * 
     * @type {number}
     * @memberof MenuProductExtraDto
     */
    'rank': number;
    /**
     * 
     * @type {string}
     * @memberof MenuProductExtraDto
     */
    'snooze_until': string | null;
    /**
     * 
     * @type {string}
     * @memberof MenuProductExtraDto
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof MenuProductExtraDto
     */
    'created_at': string | null;
    /**
     * 
     * @type {Array<MenuProductExtraOptionDto>}
     * @memberof MenuProductExtraDto
     */
    'options': Array<MenuProductExtraOptionDto>;
    /**
     * 
     * @type {Array<string>}
     * @memberof MenuProductExtraDto
     */
    'metafields': Array<string>;
}
/**
 * 
 * @export
 * @interface MenuProductExtraOptionDto
 */
export interface MenuProductExtraOptionDto {
    /**
     * 
     * @type {number}
     * @memberof MenuProductExtraOptionDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof MenuProductExtraOptionDto
     */
    'extra_id': number;
    /**
     * 
     * @type {string}
     * @memberof MenuProductExtraOptionDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MenuProductExtraOptionDto
     */
    'image': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MenuProductExtraOptionDto
     */
    'conditioned': boolean;
    /**
     * 
     * @type {number}
     * @memberof MenuProductExtraOptionDto
     */
    'respect_to': number | null;
    /**
     * 
     * @type {number}
     * @memberof MenuProductExtraOptionDto
     */
    'min': number;
    /**
     * 
     * @type {number}
     * @memberof MenuProductExtraOptionDto
     */
    'max': number;
    /**
     * 
     * @type {number}
     * @memberof MenuProductExtraOptionDto
     */
    'rank': number;
    /**
     * 
     * @type {boolean}
     * @memberof MenuProductExtraOptionDto
     */
    'with_half_option': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MenuProductExtraOptionDto
     */
    'allow_suboption_quantity': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MenuProductExtraOptionDto
     */
    'limit_suboptions_by_max': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MenuProductExtraOptionDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof MenuProductExtraOptionDto
     */
    'external_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof MenuProductExtraOptionDto
     */
    'snooze_until': string | null;
    /**
     * 
     * @type {Array<MenuProductExtraSuboptionDto>}
     * @memberof MenuProductExtraOptionDto
     */
    'suboptions': Array<MenuProductExtraSuboptionDto>;
}
/**
 * 
 * @export
 * @interface MenuProductExtraSuboptionDto
 */
export interface MenuProductExtraSuboptionDto {
    /**
     * 
     * @type {number}
     * @memberof MenuProductExtraSuboptionDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof MenuProductExtraSuboptionDto
     */
    'extra_option_id': number;
    /**
     * 
     * @type {string}
     * @memberof MenuProductExtraSuboptionDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof MenuProductExtraSuboptionDto
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof MenuProductExtraSuboptionDto
     */
    'image': string | null;
    /**
     * 
     * @type {string}
     * @memberof MenuProductExtraSuboptionDto
     */
    'sku': string | null;
    /**
     * 
     * @type {number}
     * @memberof MenuProductExtraSuboptionDto
     */
    'rank': number;
    /**
     * 
     * @type {string}
     * @memberof MenuProductExtraSuboptionDto
     */
    'description': string | null;
    /**
     * 
     * @type {number}
     * @memberof MenuProductExtraSuboptionDto
     */
    'max': number;
    /**
     * 
     * @type {number}
     * @memberof MenuProductExtraSuboptionDto
     */
    'half_price': number | null;
    /**
     * 
     * @type {boolean}
     * @memberof MenuProductExtraSuboptionDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof MenuProductExtraSuboptionDto
     */
    'external_id': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MenuProductExtraSuboptionDto
     */
    'preselected': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MenuProductExtraSuboptionDto
     */
    'is_alcohol': boolean;
    /**
     * 
     * @type {string}
     * @memberof MenuProductExtraSuboptionDto
     */
    'snooze_until': string | null;
}
/**
 * 
 * @export
 * @interface MenuReponseDto
 */
export interface MenuReponseDto {
    /**
     * Array of menu data
     * @type {Array<MenuDto>}
     * @memberof MenuReponseDto
     */
    'menus': Array<MenuDto>;
    /**
     * Array of integrations aligned with that business
     * @type {Array<ProviderIntegrationDto>}
     * @memberof MenuReponseDto
     */
    'integrations': Array<ProviderIntegrationDto>;
}
/**
 * 
 * @export
 * @interface MerchantResponseDto
 */
export interface MerchantResponseDto {
    /**
     * 
     * @type {string}
     * @memberof MerchantResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MerchantResponseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MerchantResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MerchantResponseDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface MoneyDto
 */
export interface MoneyDto {
    /**
     * Amount in the smallest currency unit (e.g., cents)
     * @type {number}
     * @memberof MoneyDto
     */
    'amount': number;
    /**
     * The ISO 4217 currency code
     * @type {string}
     * @memberof MoneyDto
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface MunchiThemesDto
 */
export interface MunchiThemesDto {
    /**
     * 
     * @type {ThemeTokensDto}
     * @memberof MunchiThemesDto
     */
    'light': ThemeTokensDto;
    /**
     * 
     * @type {ThemeTokensDto}
     * @memberof MunchiThemesDto
     */
    'dark': ThemeTokensDto;
}
/**
 * 
 * @export
 * @interface NetsCancelPayloadDto
 */
export interface NetsCancelPayloadDto {
    /**
     * The unique identifier for the payment terminal.
     * @type {string}
     * @memberof NetsCancelPayloadDto
     */
    'terminalId': string;
    /**
     * The unique request identifier for the request.
     * @type {string}
     * @memberof NetsCancelPayloadDto
     */
    'requestId': string | null;
    /**
     * The ID of the business that owns the terminal.
     * @type {number}
     * @memberof NetsCancelPayloadDto
     */
    'orderingBusinessId': number;
}
/**
 * 
 * @export
 * @interface NetsPaymentMessageDto
 */
export interface NetsPaymentMessageDto {
    /**
     * Indicates if the payment transaction was successful.
     * @type {boolean}
     * @memberof NetsPaymentMessageDto
     */
    'success': boolean;
    /**
     * Error message if the transaction failed.
     * @type {string}
     * @memberof NetsPaymentMessageDto
     */
    'error'?: string;
    /**
     * The detailed, human-readable error string provided by the payment service provider (PSP) if the transaction failed.
     * @type {string}
     * @memberof NetsPaymentMessageDto
     */
    'errorCode'?: string;
    /**
     * The terminal ID where the transaction was processed.
     * @type {object}
     * @memberof NetsPaymentMessageDto
     */
    'terminalId'?: object | null;
    /**
     * The raw, unparsed response object received from the payment provider.
     * @type {object}
     * @memberof NetsPaymentMessageDto
     */
    'rawData': object;
    /**
     * A unique identifier for the request, used for tracking.
     * @type {string}
     * @memberof NetsPaymentMessageDto
     */
    'requestId'?: string;
    /**
     * 
     * @type {NetsPaymentMessageDtoData}
     * @memberof NetsPaymentMessageDto
     */
    'data'?: NetsPaymentMessageDtoData;
}
/**
 * Transaction details if the payment was successful.
 * @export
 * @interface NetsPaymentMessageDtoData
 */
export interface NetsPaymentMessageDtoData {
    /**
     * A unique identifier for the transaction.
     * @type {string}
     * @memberof NetsPaymentMessageDtoData
     */
    'transactionId': string;
    /**
     * The truncated/masked PAN of the payment card used.
     * @type {string}
     * @memberof NetsPaymentMessageDtoData
     */
    'cardNumber': string;
    /**
     * The issuer or card scheme identifier.
     * @type {string}
     * @memberof NetsPaymentMessageDtoData
     */
    'cardType': string;
    /**
     * The unique order ID for this transaction.
     * @type {string}
     * @memberof NetsPaymentMessageDtoData
     */
    'orderId': string;
    /**
     * An RFC3339 formatted timestamp of the transaction.
     * @type {string}
     * @memberof NetsPaymentMessageDtoData
     */
    'timeStamp': string;
    /**
     * The transaction receipt to be stored by the merchant.
     * @type {string}
     * @memberof NetsPaymentMessageDtoData
     */
    'merchantReceipt': string;
    /**
     * The transaction receipt to be printed for the customer.
     * @type {string}
     * @memberof NetsPaymentMessageDtoData
     */
    'customerReceipt': string;
    /**
     * The type of transaction that was performed.
     * @type {string}
     * @memberof NetsPaymentMessageDtoData
     */
    'transactionType': string;
    /**
     * Full LocalMode arguments as sent by the terminal.
     * @type {{ [key: string]: any; }}
     * @memberof NetsPaymentMessageDtoData
     */
    'localModeEventArgs': { [key: string]: any; };
    /**
     * A token for the card number to be used with Storebox services.
     * @type {string}
     * @memberof NetsPaymentMessageDtoData
     */
    'storeboxToken'?: string;
}
/**
 * 
 * @export
 * @interface NetsRemoveFailedTransactionPayloadDto
 */
export interface NetsRemoveFailedTransactionPayloadDto {
    /**
     * The unique request identifier for the request.
     * @type {string}
     * @memberof NetsRemoveFailedTransactionPayloadDto
     */
    'requestId': string | null;
    /**
     * The ID of the business that owns the terminal.
     * @type {number}
     * @memberof NetsRemoveFailedTransactionPayloadDto
     */
    'orderingBusinessId': number;
}
/**
 * 
 * @export
 * @interface NetsTransactionFailureDetailsDto
 */
export interface NetsTransactionFailureDetailsDto {
    /**
     * A description of the error that occurred.
     * @type {string}
     * @memberof NetsTransactionFailureDetailsDto
     */
    'error': string;
    /**
     * A unique identifier for the failed transaction.
     * @type {object}
     * @memberof NetsTransactionFailureDetailsDto
     */
    'transactionId': object | null;
    /**
     * The truncated/masked PAN of the payment card used (if available).
     * @type {object}
     * @memberof NetsTransactionFailureDetailsDto
     */
    'cardNumber': object | null;
    /**
     * The issuer or card scheme identifier (if available).
     * @type {object}
     * @memberof NetsTransactionFailureDetailsDto
     */
    'cardType': object | null;
    /**
     * An RFC3339 formatted timestamp of the transaction attempt.
     * @type {object}
     * @memberof NetsTransactionFailureDetailsDto
     */
    'timestamp': object | null;
    /**
     * The transaction receipt to be stored by the merchant for the failure.
     * @type {string}
     * @memberof NetsTransactionFailureDetailsDto
     */
    'merchantReceipt': string;
    /**
     * The transaction receipt to be printed for the customer for the failure.
     * @type {string}
     * @memberof NetsTransactionFailureDetailsDto
     */
    'customerReceipt': string;
    /**
     * The type of transaction that was attempted.
     * @type {object}
     * @memberof NetsTransactionFailureDetailsDto
     */
    'transactionType': object | null;
    /**
     * Full LocalMode arguments as sent by the terminal detailing the failure.
     * @type {{ [key: string]: any; }}
     * @memberof NetsTransactionFailureDetailsDto
     */
    'localModeEventArgs': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface NetsTransactionFailureResponseDto
 */
export interface NetsTransactionFailureResponseDto {
    /**
     * 
     * @type {NetsTransactionFailureResponseDtoFailure}
     * @memberof NetsTransactionFailureResponseDto
     */
    'failure': NetsTransactionFailureResponseDtoFailure;
}
/**
 * Details of the failed transaction.
 * @export
 * @interface NetsTransactionFailureResponseDtoFailure
 */
export interface NetsTransactionFailureResponseDtoFailure {
    /**
     * A description of the error that occurred.
     * @type {string}
     * @memberof NetsTransactionFailureResponseDtoFailure
     */
    'error': string;
    /**
     * A unique identifier for the failed transaction.
     * @type {object}
     * @memberof NetsTransactionFailureResponseDtoFailure
     */
    'transactionId': object | null;
    /**
     * The truncated/masked PAN of the payment card used (if available).
     * @type {object}
     * @memberof NetsTransactionFailureResponseDtoFailure
     */
    'cardNumber': object | null;
    /**
     * The issuer or card scheme identifier (if available).
     * @type {object}
     * @memberof NetsTransactionFailureResponseDtoFailure
     */
    'cardType': object | null;
    /**
     * An RFC3339 formatted timestamp of the transaction attempt.
     * @type {object}
     * @memberof NetsTransactionFailureResponseDtoFailure
     */
    'timestamp': object | null;
    /**
     * The transaction receipt to be stored by the merchant for the failure.
     * @type {string}
     * @memberof NetsTransactionFailureResponseDtoFailure
     */
    'merchantReceipt': string;
    /**
     * The transaction receipt to be printed for the customer for the failure.
     * @type {string}
     * @memberof NetsTransactionFailureResponseDtoFailure
     */
    'customerReceipt': string;
    /**
     * The type of transaction that was attempted.
     * @type {object}
     * @memberof NetsTransactionFailureResponseDtoFailure
     */
    'transactionType': object | null;
    /**
     * Full LocalMode arguments as sent by the terminal detailing the failure.
     * @type {{ [key: string]: any; }}
     * @memberof NetsTransactionFailureResponseDtoFailure
     */
    'localModeEventArgs': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface NetsTransactionResultDto
 */
export interface NetsTransactionResultDto {
    /**
     * A unique identifier for the transaction.
     * @type {string}
     * @memberof NetsTransactionResultDto
     */
    'transactionId': string;
    /**
     * The truncated/masked PAN of the payment card used.
     * @type {string}
     * @memberof NetsTransactionResultDto
     */
    'cardNumber': string;
    /**
     * The issuer or card scheme identifier.
     * @type {string}
     * @memberof NetsTransactionResultDto
     */
    'cardType': string;
    /**
     * The unique order ID for this transaction.
     * @type {string}
     * @memberof NetsTransactionResultDto
     */
    'orderId': string;
    /**
     * An RFC3339 formatted timestamp of the transaction.
     * @type {string}
     * @memberof NetsTransactionResultDto
     */
    'timeStamp': string;
    /**
     * The transaction receipt to be stored by the merchant.
     * @type {string}
     * @memberof NetsTransactionResultDto
     */
    'merchantReceipt': string;
    /**
     * The transaction receipt to be printed for the customer.
     * @type {string}
     * @memberof NetsTransactionResultDto
     */
    'customerReceipt': string;
    /**
     * The type of transaction that was performed.
     * @type {string}
     * @memberof NetsTransactionResultDto
     */
    'transactionType': string;
    /**
     * Full LocalMode arguments as sent by the terminal.
     * @type {{ [key: string]: any; }}
     * @memberof NetsTransactionResultDto
     */
    'localModeEventArgs': { [key: string]: any; };
    /**
     * A token for the card number to be used with Storebox services.
     * @type {string}
     * @memberof NetsTransactionResultDto
     */
    'storeboxToken'?: string;
}
/**
 * 
 * @export
 * @interface NetsTransactionSuccessResponseDto
 */
export interface NetsTransactionSuccessResponseDto {
    /**
     * An array of transaction result objects.
     * @type {Array<NetsTransactionResultDto>}
     * @memberof NetsTransactionSuccessResponseDto
     */
    'result': Array<NetsTransactionResultDto>;
}
/**
 * 
 * @export
 * @interface NextTierDto
 */
export interface NextTierDto {
    /**
     * 
     * @type {number}
     * @memberof NextTierDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NextTierDto
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NextTierDto
     */
    'description': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof NextTierDto
     */
    'points_to_next_tier': number;
    /**
     * 
     * @type {number}
     * @memberof NextTierDto
     */
    'threshold': number;
}
/**
 * 
 * @export
 * @interface OfflineCardPresentDetailsDto
 */
export interface OfflineCardPresentDetailsDto {
    /**
     * Card brand
     * @type {string}
     * @memberof OfflineCardPresentDetailsDto
     */
    'brand': string;
    /**
     * Cardholder name
     * @type {string}
     * @memberof OfflineCardPresentDetailsDto
     */
    'cardholderName': string;
    /**
     * Card expiration month
     * @type {number}
     * @memberof OfflineCardPresentDetailsDto
     */
    'expMonth': number;
    /**
     * Card expiration year
     * @type {number}
     * @memberof OfflineCardPresentDetailsDto
     */
    'expYear': number;
    /**
     * Last 4 digits of the card
     * @type {string}
     * @memberof OfflineCardPresentDetailsDto
     */
    'last4': string;
    /**
     * Card read method
     * @type {string}
     * @memberof OfflineCardPresentDetailsDto
     */
    'readMethod': string;
    /**
     * 
     * @type {OfflineCardPresentDetailsDtoReceiptDetails}
     * @memberof OfflineCardPresentDetailsDto
     */
    'receiptDetails': OfflineCardPresentDetailsDtoReceiptDetails;
}
/**
 * Receipt details
 * @export
 * @interface OfflineCardPresentDetailsDtoReceiptDetails
 */
export interface OfflineCardPresentDetailsDtoReceiptDetails {
    /**
     * Account type
     * @type {string}
     * @memberof OfflineCardPresentDetailsDtoReceiptDetails
     */
    'accountType': string;
    /**
     * Application cryptogram
     * @type {string}
     * @memberof OfflineCardPresentDetailsDtoReceiptDetails
     */
    'applicationCryptogram': string;
    /**
     * Application preferred name
     * @type {string}
     * @memberof OfflineCardPresentDetailsDtoReceiptDetails
     */
    'applicationPreferredName': string;
    /**
     * Authorization code
     * @type {string}
     * @memberof OfflineCardPresentDetailsDtoReceiptDetails
     */
    'authorizationCode': string;
    /**
     * Authorization response code
     * @type {string}
     * @memberof OfflineCardPresentDetailsDtoReceiptDetails
     */
    'authorizationResponseCode': string;
    /**
     * Cardholder verification method
     * @type {string}
     * @memberof OfflineCardPresentDetailsDtoReceiptDetails
     */
    'cvm': string;
    /**
     * Dedicated file name
     * @type {string}
     * @memberof OfflineCardPresentDetailsDtoReceiptDetails
     */
    'dedicatedFileName': string;
    /**
     * Terminal verification result
     * @type {string}
     * @memberof OfflineCardPresentDetailsDtoReceiptDetails
     */
    'terminalVerificationResult': string;
    /**
     * Transaction status information
     * @type {string}
     * @memberof OfflineCardPresentDetailsDtoReceiptDetails
     */
    'transactionStatusInformation': string;
}
/**
 * 
 * @export
 * @interface OfflineDetailsDto
 */
export interface OfflineDetailsDto {
    /**
     * Timestamp when stored offline (in milliseconds)
     * @type {string}
     * @memberof OfflineDetailsDto
     */
    'storedAtMs': string;
    /**
     * Whether the payment requires upload to complete
     * @type {boolean}
     * @memberof OfflineDetailsDto
     */
    'requiresUpload': boolean;
    /**
     * 
     * @type {OfflineDetailsDtoCardPresentDetails}
     * @memberof OfflineDetailsDto
     */
    'cardPresentDetails': OfflineDetailsDtoCardPresentDetails;
    /**
     * 
     * @type {OfflineDetailsDtoAmountDetails}
     * @memberof OfflineDetailsDto
     */
    'amountDetails': OfflineDetailsDtoAmountDetails;
}
/**
 * Amount details for offline payment
 * @export
 * @interface OfflineDetailsDtoAmountDetails
 */
export interface OfflineDetailsDtoAmountDetails {
    /**
     * 
     * @type {AmountDetailsDtoTip}
     * @memberof OfflineDetailsDtoAmountDetails
     */
    'tip': AmountDetailsDtoTip;
}
/**
 * Card present details for offline payment
 * @export
 * @interface OfflineDetailsDtoCardPresentDetails
 */
export interface OfflineDetailsDtoCardPresentDetails {
    /**
     * Card brand
     * @type {string}
     * @memberof OfflineDetailsDtoCardPresentDetails
     */
    'brand': string;
    /**
     * Cardholder name
     * @type {string}
     * @memberof OfflineDetailsDtoCardPresentDetails
     */
    'cardholderName': string;
    /**
     * Card expiration month
     * @type {number}
     * @memberof OfflineDetailsDtoCardPresentDetails
     */
    'expMonth': number;
    /**
     * Card expiration year
     * @type {number}
     * @memberof OfflineDetailsDtoCardPresentDetails
     */
    'expYear': number;
    /**
     * Last 4 digits of the card
     * @type {string}
     * @memberof OfflineDetailsDtoCardPresentDetails
     */
    'last4': string;
    /**
     * Card read method
     * @type {string}
     * @memberof OfflineDetailsDtoCardPresentDetails
     */
    'readMethod': string;
    /**
     * 
     * @type {OfflineCardPresentDetailsDtoReceiptDetails}
     * @memberof OfflineDetailsDtoCardPresentDetails
     */
    'receiptDetails': OfflineCardPresentDetailsDtoReceiptDetails;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OperatingMode = {
    Standard: 'STANDARD',
    Team: 'TEAM',
    Pinlock: 'PINLOCK'
} as const;

export type OperatingMode = typeof OperatingMode[keyof typeof OperatingMode];


/**
 * 
 * @export
 * @interface OptionDto
 */
export interface OptionDto {
    /**
     * Option ID
     * @type {string}
     * @memberof OptionDto
     */
    'id': string;
    /**
     * Option external ID
     * @type {string}
     * @memberof OptionDto
     */
    'externalId': string;
    /**
     * Option name
     * @type {string}
     * @memberof OptionDto
     */
    'name': string;
    /**
     * Option image
     * @type {string}
     * @memberof OptionDto
     */
    'image': string | null;
    /**
     * List of sub options
     * @type {Array<SubOptionDto>}
     * @memberof OptionDto
     */
    'subOptions': Array<SubOptionDto>;
}
/**
 * 
 * @export
 * @interface OrderActionDataDto
 */
export interface OrderActionDataDto {
    /**
     * Order ID
     * @type {string}
     * @memberof OrderActionDataDto
     */
    'orderId': string;
    /**
     * Business ID
     * @type {string}
     * @memberof OrderActionDataDto
     */
    'businessId': string;
    /**
     * Array of cancelled line item IDs
     * @type {Array<string>}
     * @memberof OrderActionDataDto
     */
    'cancelledItems': Array<string>;
    /**
     * targetUserId
     * @type {number}
     * @memberof OrderActionDataDto
     */
    'targetUserId'?: number;
}
/**
 * 
 * @export
 * @interface OrderEventDto
 */
export interface OrderEventDto {
    /**
     * Unique identifier for the order
     * @type {string}
     * @memberof OrderEventDto
     */
    'orderId': string;
    /**
     * Order number shown to the customer
     * @type {string}
     * @memberof OrderEventDto
     */
    'orderNumber': string;
    /**
     * Business ID that placed the order
     * @type {number}
     * @memberof OrderEventDto
     */
    'orderingBusinessId': number;
    /**
     * Current status of the order
     * @type {string}
     * @memberof OrderEventDto
     */
    'status': string;
    /**
     * Provider name
     * @type {string}
     * @memberof OrderEventDto
     */
    'provider': string;
    /**
     * ISO timestamp of the event
     * @type {string}
     * @memberof OrderEventDto
     */
    'timestamp': string;
    /**
     * Type of order
     * @type {string}
     * @memberof OrderEventDto
     */
    'orderType': string;
    /**
     * 
     * @type {OrderEventDtoItemSummary}
     * @memberof OrderEventDto
     */
    'itemSummary': OrderEventDtoItemSummary;
    /**
     * Expiry date of the order
     * @type {string}
     * @memberof OrderEventDto
     */
    'expiryDate'?: string | null;
    /**
     * Estimated pickup time
     * @type {string}
     * @memberof OrderEventDto
     */
    'pickUpEta'?: string | null;
    /**
     * Preparation time in minutes
     * @type {number}
     * @memberof OrderEventDto
     */
    'preparedIn'?: number | null;
    /**
     * order data
     * @type {object}
     * @memberof OrderEventDto
     */
    'order': object;
    /**
     * Flag to indicate if only cancelled items are included
     * @type {boolean}
     * @memberof OrderEventDto
     */
    'only_cancelled_items'?: boolean;
}
/**
 * Summary of the order items
 * @export
 * @interface OrderEventDtoItemSummary
 */
export interface OrderEventDtoItemSummary {
    /**
     * Total net amount
     * @type {number}
     * @memberof OrderEventDtoItemSummary
     */
    'sum'?: number;
    /**
     * Number of products
     * @type {number}
     * @memberof OrderEventDtoItemSummary
     */
    'size'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OrderFormat = {
    Open: 'OPEN',
    Instant: 'INSTANT'
} as const;

export type OrderFormat = typeof OrderFormat[keyof typeof OrderFormat];


/**
 * 
 * @export
 * @interface OrderHistoryPosDto
 */
export interface OrderHistoryPosDto {
    /**
     * 
     * @type {OrderHistoryPosDtoCartOrder}
     * @memberof OrderHistoryPosDto
     */
    'cartOrder': OrderHistoryPosDtoCartOrder;
    /**
     * 
     * @type {OrderHistoryPosDtoTaxDetails}
     * @memberof OrderHistoryPosDto
     */
    'taxDetails': OrderHistoryPosDtoTaxDetails;
    /**
     * Creation date of the order
     * @type {string}
     * @memberof OrderHistoryPosDto
     */
    'createdAt': string;
}
/**
 * Order history details
 * @export
 * @interface OrderHistoryPosDtoCartOrder
 */
export interface OrderHistoryPosDtoCartOrder {
    /**
     * Cart ID
     * @type {string}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'cartId': string;
    /**
     * Document id
     * @type {string}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'documentId': string;
    /**
     * Order number
     * @type {string}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'orderNumber': string;
    /**
     * Table value or number
     * @type {string}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'tableValue': string | null;
    /**
     * 
     * @type {OrderTypePOS}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'orderType': OrderTypePOS;
    /**
     * 
     * @type {ServiceType}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'serviceType': ServiceType;
    /**
     * 
     * @type {LocatorType}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'locatorType': LocatorType;
    /**
     * Order items
     * @type {Array<PosItemDto>}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'items': Array<PosItemDto>;
    /**
     * 
     * @type {CartOrderDtoDiscount}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'discount': CartOrderDtoDiscount | null;
    /**
     * Additional comments for the order
     * @type {string}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'comments': string | null;
    /**
     * Total order amount
     * @type {number}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'total': number;
    /**
     * Subtotal before discounts and taxes
     * @type {number}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'subtotal': number;
    /**
     * Amount left to pay
     * @type {number}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'leftToPay': number;
    /**
     * Amount already paid
     * @type {number}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'paid': number;
    /**
     * Available payment methods
     * @type {Array<PaymentMethod>}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'paymentMethods': Array<PaymentMethod>;
    /**
     * Payments made with different methods
     * @type {Array<PaymentMethodTypeDto>}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'paidByPaymentMethods': Array<PaymentMethodTypeDto>;
    /**
     * Start date
     * @type {string}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'savedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'currentlyPaidSplitPartId': string;
    /**
     * 
     * @type {CartOrderDtoCustomer}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'customer': CartOrderDtoCustomer | null;
    /**
     * Split bill parts if applicable
     * @type {Array<SplitPartDto>}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'splitParts': Array<SplitPartDto>;
    /**
     * Details of any refunds processed for this order.
     * @type {Array<PaymentRefundDto>}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'refunds'?: Array<PaymentRefundDto>;
    /**
     * 
     * @type {OrderRefundStatus}
     * @memberof OrderHistoryPosDtoCartOrder
     */
    'orderRefundStatus': OrderRefundStatus;
}


/**
 * Tax details for the order
 * @export
 * @interface OrderHistoryPosDtoTaxDetails
 */
export interface OrderHistoryPosDtoTaxDetails {
    /**
     * Array of alcohol items
     * @type {Array<PosItemDto>}
     * @memberof OrderHistoryPosDtoTaxDetails
     */
    'alcoholItems': Array<PosItemDto>;
    /**
     * Total amount for alcohol items without tax
     * @type {number}
     * @memberof OrderHistoryPosDtoTaxDetails
     */
    'alcoholTotalWithoutTax': number;
    /**
     * Total amount for non-alcohol items
     * @type {number}
     * @memberof OrderHistoryPosDtoTaxDetails
     */
    'totalWithouAlcohol': number;
    /**
     * Tax amount for alcohol items
     * @type {number}
     * @memberof OrderHistoryPosDtoTaxDetails
     */
    'alcoholTaxAmount': number;
    /**
     * Total tax amount
     * @type {number}
     * @memberof OrderHistoryPosDtoTaxDetails
     */
    'taxAmount': number;
    /**
     * Total amount for alcohol items including tax
     * @type {number}
     * @memberof OrderHistoryPosDtoTaxDetails
     */
    'alcoholTotal': number;
    /**
     * Total amount without tax
     * @type {number}
     * @memberof OrderHistoryPosDtoTaxDetails
     */
    'totalWithoutTax': number;
    /**
     * 
     * @type {TaxDetailsDtoSelectedTax}
     * @memberof OrderHistoryPosDtoTaxDetails
     */
    'selectedTax': TaxDetailsDtoSelectedTax;
    /**
     * 
     * @type {TaxDetailsDtoSelectedTax}
     * @memberof OrderHistoryPosDtoTaxDetails
     */
    'alcoholTax'?: TaxDetailsDtoSelectedTax;
}
/**
 * 
 * @export
 * @interface OrderHistoryPosResponseDto
 */
export interface OrderHistoryPosResponseDto {
    /**
     * Cart order data
     * @type {Array<OrderHistoryPosDto>}
     * @memberof OrderHistoryPosResponseDto
     */
    'orders': Array<OrderHistoryPosDto>;
    /**
     * 
     * @type {OrderHistoryPosResponseDtoSummary}
     * @memberof OrderHistoryPosResponseDto
     */
    'summary': OrderHistoryPosResponseDtoSummary;
    /**
     * 
     * @type {OrderHistoryResponseDtoPagination}
     * @memberof OrderHistoryPosResponseDto
     */
    'pagination': OrderHistoryResponseDtoPagination;
}
/**
 * Order summary
 * @export
 * @interface OrderHistoryPosResponseDtoSummary
 */
export interface OrderHistoryPosResponseDtoSummary {
    /**
     * Total orders
     * @type {number}
     * @memberof OrderHistoryPosResponseDtoSummary
     */
    'totalOrders': number;
    /**
     * Rejected orders
     * @type {number}
     * @memberof OrderHistoryPosResponseDtoSummary
     */
    'rejectedOrders': number;
    /**
     * Total sales
     * @type {number}
     * @memberof OrderHistoryPosResponseDtoSummary
     */
    'totalSales': number;
    /**
     * Rejected sales
     * @type {number}
     * @memberof OrderHistoryPosResponseDtoSummary
     */
    'rejectedSales': number;
}
/**
 * 
 * @export
 * @interface OrderHistoryPosResponseDtoV2
 */
export interface OrderHistoryPosResponseDtoV2 {
    /**
     * Cart order data
     * @type {Array<PosOrderDto>}
     * @memberof OrderHistoryPosResponseDtoV2
     */
    'orders': Array<PosOrderDto>;
    /**
     * 
     * @type {OrderHistoryPosResponseDtoSummary}
     * @memberof OrderHistoryPosResponseDtoV2
     */
    'summary': OrderHistoryPosResponseDtoSummary;
    /**
     * 
     * @type {OrderHistoryResponseDtoPagination}
     * @memberof OrderHistoryPosResponseDtoV2
     */
    'pagination': OrderHistoryResponseDtoPagination;
}
/**
 * 
 * @export
 * @interface OrderHistoryResponseDto
 */
export interface OrderHistoryResponseDto {
    /**
     * Order details
     * @type {Array<OrderResponseDto>}
     * @memberof OrderHistoryResponseDto
     */
    'orders': Array<OrderResponseDto>;
    /**
     * 
     * @type {OrderHistoryResponseDtoSummary}
     * @memberof OrderHistoryResponseDto
     */
    'summary': OrderHistoryResponseDtoSummary;
    /**
     * 
     * @type {OrderHistoryResponseDtoPagination}
     * @memberof OrderHistoryResponseDto
     */
    'pagination': OrderHistoryResponseDtoPagination;
}
/**
 * Pagination details
 * @export
 * @interface OrderHistoryResponseDtoPagination
 */
export interface OrderHistoryResponseDtoPagination {
    /**
     * Page number
     * @type {number}
     * @memberof OrderHistoryResponseDtoPagination
     */
    'page': number;
    /**
     * Row per page
     * @type {number}
     * @memberof OrderHistoryResponseDtoPagination
     */
    'rowPerPage': number;
    /**
     * Total pages
     * @type {number}
     * @memberof OrderHistoryResponseDtoPagination
     */
    'totalPages': number;
}
/**
 * Order status
 * @export
 * @interface OrderHistoryResponseDtoSummary
 */
export interface OrderHistoryResponseDtoSummary {
    /**
     * Total orders
     * @type {number}
     * @memberof OrderHistoryResponseDtoSummary
     */
    'totalOrders': number;
    /**
     * Rejected orders
     * @type {number}
     * @memberof OrderHistoryResponseDtoSummary
     */
    'rejectedOrders': number;
    /**
     * Total sales
     * @type {number}
     * @memberof OrderHistoryResponseDtoSummary
     */
    'totalSales': number;
    /**
     * Rejected sales
     * @type {number}
     * @memberof OrderHistoryResponseDtoSummary
     */
    'rejectedSales': number;
}
/**
 * 
 * @export
 * @interface OrderPaginationDto
 */
export interface OrderPaginationDto {
    /**
     * Page number (starts from 1)
     * @type {number}
     * @memberof OrderPaginationDto
     */
    'page'?: number;
    /**
     * Number of items per page (max 100)
     * @type {number}
     * @memberof OrderPaginationDto
     */
    'limit'?: number;
    /**
     * Total number of items
     * @type {number}
     * @memberof OrderPaginationDto
     */
    'total': number;
    /**
     * Total number of pages
     * @type {number}
     * @memberof OrderPaginationDto
     */
    'totalPages': number;
    /**
     * Whether there is a next page
     * @type {boolean}
     * @memberof OrderPaginationDto
     */
    'hasNext': boolean;
    /**
     * Whether there is a previous page
     * @type {boolean}
     * @memberof OrderPaginationDto
     */
    'hasPrevious': boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OrderRefundStatus = {
    None: 'NONE',
    Partial: 'PARTIAL',
    Full: 'FULL'
} as const;

export type OrderRefundStatus = typeof OrderRefundStatus[keyof typeof OrderRefundStatus];


/**
 * 
 * @export
 * @interface OrderResponseDto
 */
export interface OrderResponseDto {
    /**
     * Order ID
     * @type {string}
     * @memberof OrderResponseDto
     */
    'id': string;
    /**
     * External order identifier
     * @type {string}
     * @memberof OrderResponseDto
     */
    'externalId': string;
    /**
     * Creation date of the order
     * @type {string}
     * @memberof OrderResponseDto
     */
    'createdAt': string;
    /**
     * Accepted time of the order
     * @type {string}
     * @memberof OrderResponseDto
     */
    'acceptedAt': string | null;
    /**
     * 
     * @type {PaymentTypeEnum}
     * @memberof OrderResponseDto
     */
    'paymentType'?: PaymentTypeEnum;
    /**
     * Estimated pickup time
     * @type {string}
     * @memberof OrderResponseDto
     */
    'pickupEta': string | null;
    /**
     * Estimated delivery time
     * @type {string}
     * @memberof OrderResponseDto
     */
    'deliveryEta': string | null;
    /**
     * Additional comment from the customer
     * @type {string}
     * @memberof OrderResponseDto
     */
    'customerComment': string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderResponseDto
     */
    'dineInNumber': string | null;
    /**
     * Preparation time in minutes
     * @type {number}
     * @memberof OrderResponseDto
     */
    'preparedIn': number | null;
    /**
     * 
     * @type {OrderStatusEnum}
     * @memberof OrderResponseDto
     */
    'status': OrderStatusEnum;
    /**
     * Order Number
     * @type {string}
     * @memberof OrderResponseDto
     */
    'orderNumber': string;
    /**
     * 
     * @type {Type}
     * @memberof OrderResponseDto
     */
    'type': Type;
    /**
     * Expiry date of the order
     * @type {string}
     * @memberof OrderResponseDto
     */
    'expiryDate': string | null;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof OrderResponseDto
     */
    'paymentStatus': PaymentStatus;
    /**
     * 
     * @type {OrderType}
     * @memberof OrderResponseDto
     */
    'orderType': OrderType;
    /**
     * Last update date of the order
     * @type {string}
     * @memberof OrderResponseDto
     */
    'updatedAt': string;
    /**
     * Reason for rejection if applicable
     * @type {string}
     * @memberof OrderResponseDto
     */
    'rejectedReason': string | null;
    /**
     * 
     * @type {ProviderEnum}
     * @memberof OrderResponseDto
     */
    'provider': ProviderEnum;
    /**
     * Ordering business identifier
     * @type {number}
     * @memberof OrderResponseDto
     */
    'orderingBusinessId': number;
    /**
     * 
     * @type {OrderResponseDtoCustomer}
     * @memberof OrderResponseDto
     */
    'customer': OrderResponseDtoCustomer | null;
    /**
     * 
     * @type {OrderResponseDtoDelivery}
     * @memberof OrderResponseDto
     */
    'delivery': OrderResponseDtoDelivery | null;
    /**
     * List of discounts
     * @type {Array<DiscountDto>}
     * @memberof OrderResponseDto
     */
    'discounts': Array<DiscountDto> | null;
    /**
     * 
     * @type {OrderResponseDtoPreorder}
     * @memberof OrderResponseDto
     */
    'preorder': OrderResponseDtoPreorder | null;
    /**
     * 
     * @type {OrderResponseDtoPriceSummary}
     * @memberof OrderResponseDto
     */
    'priceSummary': OrderResponseDtoPriceSummary | null;
    /**
     * List of products
     * @type {Array<ProductDto>}
     * @memberof OrderResponseDto
     */
    'products': Array<ProductDto>;
    /**
     * 
     * @type {OrderResponseDtoBusiness}
     * @memberof OrderResponseDto
     */
    'business': OrderResponseDtoBusiness | null;
    /**
     * List of refunds associated with the order
     * @type {Array<RefundDto>}
     * @memberof OrderResponseDto
     */
    'refunds'?: Array<RefundDto>;
}


/**
 * Business details
 * @export
 * @interface OrderResponseDtoBusiness
 */
export interface OrderResponseDtoBusiness {
    /**
     * Unique identifier of the business
     * @type {string}
     * @memberof OrderResponseDtoBusiness
     */
    'id': string;
    /**
     * Name of the business
     * @type {string}
     * @memberof OrderResponseDtoBusiness
     */
    'name': string;
    /**
     * Logo of the business
     * @type {string}
     * @memberof OrderResponseDtoBusiness
     */
    'logo': string;
    /**
     * Email of the business
     * @type {string}
     * @memberof OrderResponseDtoBusiness
     */
    'email'?: string;
    /**
     * Address of the business
     * @type {string}
     * @memberof OrderResponseDtoBusiness
     */
    'address'?: string;
    /**
     * Creation date of the business
     * @type {string}
     * @memberof OrderResponseDtoBusiness
     */
    'createdAt': string;
    /**
     * Time zone of the business
     * @type {string}
     * @memberof OrderResponseDtoBusiness
     */
    'timeZone': string;
    /**
     * Currency used by the business
     * @type {string}
     * @memberof OrderResponseDtoBusiness
     */
    'currency': string;
    /**
     * Phone number of the business
     * @type {string}
     * @memberof OrderResponseDtoBusiness
     */
    'phone'?: string;
    /**
     * Ordering business identifier
     * @type {number}
     * @memberof OrderResponseDtoBusiness
     */
    'orderingBusinessId': number;
    /**
     * BIC/SWIFT code of the business
     * @type {string}
     * @memberof OrderResponseDtoBusiness
     */
    'bic': string | null;
    /**
     * Whether the business is enabled
     * @type {boolean}
     * @memberof OrderResponseDtoBusiness
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderResponseDtoBusiness
     */
    'chainId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderResponseDtoBusiness
     */
    'merchantId'?: string;
}
/**
 * Customer details
 * @export
 * @interface OrderResponseDtoCustomer
 */
export interface OrderResponseDtoCustomer {
    /**
     * Customer ID
     * @type {string}
     * @memberof OrderResponseDtoCustomer
     */
    'id': string;
    /**
     * Customer email
     * @type {string}
     * @memberof OrderResponseDtoCustomer
     */
    'email': string | null;
    /**
     * Customer name
     * @type {string}
     * @memberof OrderResponseDtoCustomer
     */
    'name': string;
    /**
     * Customer phone
     * @type {string}
     * @memberof OrderResponseDtoCustomer
     */
    'phone': string | null;
}
/**
 * Delivery details
 * @export
 * @interface OrderResponseDtoDelivery
 */
export interface OrderResponseDtoDelivery {
    /**
     * Delivery ID
     * @type {string}
     * @memberof OrderResponseDtoDelivery
     */
    'id': string;
    /**
     * Self delivery flag
     * @type {boolean}
     * @memberof OrderResponseDtoDelivery
     */
    'selfDelivery': boolean | null;
    /**
     * Delivery note
     * @type {string}
     * @memberof OrderResponseDtoDelivery
     */
    'note': string | null;
    /**
     * 
     * @type {DeliveryStatus}
     * @memberof OrderResponseDtoDelivery
     */
    'status': DeliveryStatus;
    /**
     * 
     * @type {DeliveryType}
     * @memberof OrderResponseDtoDelivery
     */
    'type': DeliveryType;
    /**
     * 
     * @type {DeliveryDtoLocation}
     * @memberof OrderResponseDtoDelivery
     */
    'location': DeliveryDtoLocation | null;
    /**
     * Delivery fee
     * @type {number}
     * @memberof OrderResponseDtoDelivery
     */
    'deliveryFee': number;
}


/**
 * Preorder details
 * @export
 * @interface OrderResponseDtoPreorder
 */
export interface OrderResponseDtoPreorder {
    /**
     * Preorder ID
     * @type {string}
     * @memberof OrderResponseDtoPreorder
     */
    'id': string;
    /**
     * 
     * @type {PreorderStatus}
     * @memberof OrderResponseDtoPreorder
     */
    'status': PreorderStatus;
    /**
     * Preorder time
     * @type {string}
     * @memberof OrderResponseDtoPreorder
     */
    'preorderTime': string | null;
}


/**
 * Price summary details
 * @export
 * @interface OrderResponseDtoPriceSummary
 */
export interface OrderResponseDtoPriceSummary {
    /**
     * Price summary ID
     * @type {string}
     * @memberof OrderResponseDtoPriceSummary
     */
    'id': string;
    /**
     * Total net amount
     * @type {number}
     * @memberof OrderResponseDtoPriceSummary
     */
    'totalNet': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OrderStatusEnum = {
    Pending: 'pending',
    InProgress: 'in_progress',
    Ready: 'ready',
    Delivered: 'delivered',
    Rejected: 'rejected',
    PickUpByDriver: 'pick_up_by_driver',
    Preorder: 'preorder',
    AcceptByDriver: 'accept_by_driver',
    Parked: 'parked',
    Refunded: 'refunded',
    Draft: 'draft'
} as const;

export type OrderStatusEnum = typeof OrderStatusEnum[keyof typeof OrderStatusEnum];


/**
 * 
 * @export
 * @interface OrderStatusResponseDto
 */
export interface OrderStatusResponseDto {
    /**
     * Message indicating order status accepted
     * @type {string}
     * @memberof OrderStatusResponseDto
     */
    'message': string;
    /**
     * Indicates if there was an error processing the order
     * @type {boolean}
     * @memberof OrderStatusResponseDto
     */
    'error': boolean;
    /**
     * 
     * @type {OrderStatusResponseDtoOrder}
     * @memberof OrderStatusResponseDto
     */
    'order': OrderStatusResponseDtoOrder;
}
/**
 * order data
 * @export
 * @interface OrderStatusResponseDtoOrder
 */
export interface OrderStatusResponseDtoOrder {
    /**
     * Order ID
     * @type {string}
     * @memberof OrderStatusResponseDtoOrder
     */
    'id': string;
    /**
     * External order identifier
     * @type {string}
     * @memberof OrderStatusResponseDtoOrder
     */
    'externalId': string;
    /**
     * Creation date of the order
     * @type {string}
     * @memberof OrderStatusResponseDtoOrder
     */
    'createdAt': string;
    /**
     * Accepted time of the order
     * @type {string}
     * @memberof OrderStatusResponseDtoOrder
     */
    'acceptedAt': string | null;
    /**
     * 
     * @type {PaymentTypeEnum}
     * @memberof OrderStatusResponseDtoOrder
     */
    'paymentType'?: PaymentTypeEnum;
    /**
     * Estimated pickup time
     * @type {string}
     * @memberof OrderStatusResponseDtoOrder
     */
    'pickupEta': string | null;
    /**
     * Estimated delivery time
     * @type {string}
     * @memberof OrderStatusResponseDtoOrder
     */
    'deliveryEta': string | null;
    /**
     * Additional comment from the customer
     * @type {string}
     * @memberof OrderStatusResponseDtoOrder
     */
    'customerComment': string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderStatusResponseDtoOrder
     */
    'dineInNumber': string | null;
    /**
     * Preparation time in minutes
     * @type {number}
     * @memberof OrderStatusResponseDtoOrder
     */
    'preparedIn': number | null;
    /**
     * 
     * @type {OrderStatusEnum}
     * @memberof OrderStatusResponseDtoOrder
     */
    'status': OrderStatusEnum;
    /**
     * Order Number
     * @type {string}
     * @memberof OrderStatusResponseDtoOrder
     */
    'orderNumber': string;
    /**
     * 
     * @type {Type}
     * @memberof OrderStatusResponseDtoOrder
     */
    'type': Type;
    /**
     * Expiry date of the order
     * @type {string}
     * @memberof OrderStatusResponseDtoOrder
     */
    'expiryDate': string | null;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof OrderStatusResponseDtoOrder
     */
    'paymentStatus': PaymentStatus;
    /**
     * 
     * @type {OrderType}
     * @memberof OrderStatusResponseDtoOrder
     */
    'orderType': OrderType;
    /**
     * Last update date of the order
     * @type {string}
     * @memberof OrderStatusResponseDtoOrder
     */
    'updatedAt': string;
    /**
     * Reason for rejection if applicable
     * @type {string}
     * @memberof OrderStatusResponseDtoOrder
     */
    'rejectedReason': string | null;
    /**
     * 
     * @type {ProviderEnum}
     * @memberof OrderStatusResponseDtoOrder
     */
    'provider': ProviderEnum;
    /**
     * Ordering business identifier
     * @type {number}
     * @memberof OrderStatusResponseDtoOrder
     */
    'orderingBusinessId': number;
    /**
     * 
     * @type {OrderResponseDtoCustomer}
     * @memberof OrderStatusResponseDtoOrder
     */
    'customer': OrderResponseDtoCustomer | null;
    /**
     * 
     * @type {OrderResponseDtoDelivery}
     * @memberof OrderStatusResponseDtoOrder
     */
    'delivery': OrderResponseDtoDelivery | null;
    /**
     * List of discounts
     * @type {Array<DiscountDto>}
     * @memberof OrderStatusResponseDtoOrder
     */
    'discounts': Array<DiscountDto> | null;
    /**
     * 
     * @type {OrderResponseDtoPreorder}
     * @memberof OrderStatusResponseDtoOrder
     */
    'preorder': OrderResponseDtoPreorder | null;
    /**
     * 
     * @type {OrderResponseDtoPriceSummary}
     * @memberof OrderStatusResponseDtoOrder
     */
    'priceSummary': OrderResponseDtoPriceSummary | null;
    /**
     * List of products
     * @type {Array<ProductDto>}
     * @memberof OrderStatusResponseDtoOrder
     */
    'products': Array<ProductDto>;
    /**
     * 
     * @type {OrderResponseDtoBusiness}
     * @memberof OrderStatusResponseDtoOrder
     */
    'business': OrderResponseDtoBusiness | null;
    /**
     * List of refunds associated with the order
     * @type {Array<RefundDto>}
     * @memberof OrderStatusResponseDtoOrder
     */
    'refunds'?: Array<RefundDto>;
}


/**
 * 
 * @export
 * @interface OrderSummaryDto
 */
export interface OrderSummaryDto {
    /**
     * Total orders
     * @type {number}
     * @memberof OrderSummaryDto
     */
    'totalOrders': number;
    /**
     * Rejected orders
     * @type {number}
     * @memberof OrderSummaryDto
     */
    'rejectedOrders': number;
    /**
     * Total sales
     * @type {number}
     * @memberof OrderSummaryDto
     */
    'totalSales': number;
    /**
     * Rejected sales
     * @type {number}
     * @memberof OrderSummaryDto
     */
    'rejectedSales': number;
}
/**
 * 
 * @export
 * @interface OrderTaxSummaryDetailedDto
 */
export interface OrderTaxSummaryDetailedDto {
    /**
     * Tax breakdown by rate
     * @type {Array<OrderTaxSummaryDto>}
     * @memberof OrderTaxSummaryDetailedDto
     */
    'taxSummaries': Array<OrderTaxSummaryDto>;
    /**
     * Total without tax in cents
     * @type {number}
     * @memberof OrderTaxSummaryDetailedDto
     */
    'totalWithoutTax': number;
    /**
     * Total tax amount in cents
     * @type {number}
     * @memberof OrderTaxSummaryDetailedDto
     */
    'totalTax': number;
    /**
     * Grand total in cents
     * @type {number}
     * @memberof OrderTaxSummaryDetailedDto
     */
    'grandTotal': number;
}
/**
 * 
 * @export
 * @interface OrderTaxSummaryDto
 */
export interface OrderTaxSummaryDto {
    /**
     * Tax rate percentage
     * @type {number}
     * @memberof OrderTaxSummaryDto
     */
    'taxRate': number;
    /**
     * Total without tax in cents
     * @type {number}
     * @memberof OrderTaxSummaryDto
     */
    'totalWithoutTax': number;
    /**
     * Total tax amount in cents
     * @type {number}
     * @memberof OrderTaxSummaryDto
     */
    'totalTax': number;
    /**
     * Total with tax in cents
     * @type {number}
     * @memberof OrderTaxSummaryDto
     */
    'totalWithTax': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OrderType = {
    Delivery: 'delivery',
    PickUp: 'pick_up',
    DineIn: 'dine_in'
} as const;

export type OrderType = typeof OrderType[keyof typeof OrderType];


/**
 * 
 * @export
 * @enum {string}
 */

export const OrderTypePOS = {
    DineIn: 'dine_in',
    PickUp: 'pick_up'
} as const;

export type OrderTypePOS = typeof OrderTypePOS[keyof typeof OrderTypePOS];


/**
 * 
 * @export
 * @interface OrderUpdateDto
 */
export interface OrderUpdateDto {
    /**
     * External ID of the order
     * @type {string}
     * @memberof OrderUpdateDto
     */
    'externalId': string;
    /**
     * ID of the business that placed the order
     * @type {number}
     * @memberof OrderUpdateDto
     */
    'orderingBusinessId': number;
    /**
     * 
     * @type {OrderStatusEnum}
     * @memberof OrderUpdateDto
     */
    'status': OrderStatusEnum;
}


/**
 * 
 * @export
 * @interface OrderingCoProductDto
 */
export interface OrderingCoProductDto {
    /**
     * Product ID
     * @type {number}
     * @memberof OrderingCoProductDto
     */
    'id': number;
    /**
     * Product name
     * @type {string}
     * @memberof OrderingCoProductDto
     */
    'name': string;
    /**
     * Product price
     * @type {number}
     * @memberof OrderingCoProductDto
     */
    'price': number;
    /**
     * Product description
     * @type {string}
     * @memberof OrderingCoProductDto
     */
    'description': string;
    /**
     * Product image URL
     * @type {string}
     * @memberof OrderingCoProductDto
     */
    'images': string;
    /**
     * Category ID the product belongs to
     * @type {number}
     * @memberof OrderingCoProductDto
     */
    'category_id': number;
    /**
     * Whether the product is tracked for inventory
     * @type {boolean}
     * @memberof OrderingCoProductDto
     */
    'inventoried': boolean;
    /**
     * Available quantity if inventoried
     * @type {number}
     * @memberof OrderingCoProductDto
     */
    'quantity': number;
    /**
     * Whether the product is marked as featured
     * @type {boolean}
     * @memberof OrderingCoProductDto
     */
    'featured': boolean;
    /**
     * Whether the product is currently enabled
     * @type {boolean}
     * @memberof OrderingCoProductDto
     */
    'enabled': boolean;
    /**
     * Whether upselling is enabled for this product
     * @type {boolean}
     * @memberof OrderingCoProductDto
     */
    'upselling': boolean;
    /**
     * Whether the product is part of an offer
     * @type {boolean}
     * @memberof OrderingCoProductDto
     */
    'in_offer': boolean;
    /**
     * Offer price if applicable
     * @type {object}
     * @memberof OrderingCoProductDto
     */
    'offer_price': object | null;
    /**
     * Display order rank of the product
     * @type {number}
     * @memberof OrderingCoProductDto
     */
    'rank': number;
    /**
     * Weight unit (e.g., g, kg, ml)
     * @type {object}
     * @memberof OrderingCoProductDto
     */
    'weight_unit': object;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof OrderingCoProductDto
     */
    'updated_at': string;
    /**
     * Product creation timestamp
     * @type {string}
     * @memberof OrderingCoProductDto
     */
    'created_at': string;
    /**
     * Deletion timestamp if soft-deleted
     * @type {object}
     * @memberof OrderingCoProductDto
     */
    'deleted_at': object | null;
    /**
     * List of product extras (e.g., toppings, add-ons)
     * @type {Array<OrderingItemExtraDto>}
     * @memberof OrderingCoProductDto
     */
    'extras': Array<OrderingItemExtraDto>;
    /**
     * Whether the product is restricted
     * @type {boolean}
     * @memberof OrderingCoProductDto
     */
    'is_restricted': boolean;
    /**
     * 
     * @type {BusinessTaxResponseDto}
     * @memberof OrderingCoProductDto
     */
    'tax': BusinessTaxResponseDto | null;
}
/**
 * 
 * @export
 * @interface OrderingItemExtraDto
 */
export interface OrderingItemExtraDto {
    /**
     * 
     * @type {number}
     * @memberof OrderingItemExtraDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OrderingItemExtraDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrderingItemExtraDto
     */
    'description': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof OrderingItemExtraDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof OrderingItemExtraDto
     */
    'rank': number;
    /**
     * 
     * @type {Array<OrderingItemExtraOptionDto>}
     * @memberof OrderingItemExtraDto
     */
    'options': Array<OrderingItemExtraOptionDto>;
}
/**
 * 
 * @export
 * @interface OrderingItemExtraOptionDto
 */
export interface OrderingItemExtraOptionDto {
    /**
     * 
     * @type {number}
     * @memberof OrderingItemExtraOptionDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OrderingItemExtraOptionDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrderingItemExtraOptionDto
     */
    'image': string | null;
    /**
     * 
     * @type {number}
     * @memberof OrderingItemExtraOptionDto
     */
    'min': number;
    /**
     * 
     * @type {number}
     * @memberof OrderingItemExtraOptionDto
     */
    'max': number;
    /**
     * 
     * @type {number}
     * @memberof OrderingItemExtraOptionDto
     */
    'rank': number;
    /**
     * 
     * @type {boolean}
     * @memberof OrderingItemExtraOptionDto
     */
    'allow_suboption_quantity': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrderingItemExtraOptionDto
     */
    'limit_suboptions_by_max': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrderingItemExtraOptionDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {Array<OrderingItemExtraSubOptionDto>}
     * @memberof OrderingItemExtraOptionDto
     */
    'suboptions': Array<OrderingItemExtraSubOptionDto>;
}
/**
 * 
 * @export
 * @interface OrderingItemExtraSubOptionDto
 */
export interface OrderingItemExtraSubOptionDto {
    /**
     * 
     * @type {number}
     * @memberof OrderingItemExtraSubOptionDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OrderingItemExtraSubOptionDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof OrderingItemExtraSubOptionDto
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof OrderingItemExtraSubOptionDto
     */
    'image': string | null;
    /**
     * 
     * @type {number}
     * @memberof OrderingItemExtraSubOptionDto
     */
    'rank': number;
    /**
     * 
     * @type {string}
     * @memberof OrderingItemExtraSubOptionDto
     */
    'description': string | null;
    /**
     * 
     * @type {number}
     * @memberof OrderingItemExtraSubOptionDto
     */
    'max': number;
    /**
     * 
     * @type {boolean}
     * @memberof OrderingItemExtraSubOptionDto
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface PaginatedEmployeesResponseDto
 */
export interface PaginatedEmployeesResponseDto {
    /**
     * 
     * @type {Array<EmployeeResponseDto>}
     * @memberof PaginatedEmployeesResponseDto
     */
    'data': Array<EmployeeResponseDto>;
    /**
     * 
     * @type {PaginationMetaDto}
     * @memberof PaginatedEmployeesResponseDto
     */
    'pagination': PaginationMetaDto;
}
/**
 * 
 * @export
 * @interface PaginatedOrderResponseDto
 */
export interface PaginatedOrderResponseDto {
    /**
     * Order details
     * @type {Array<OrderResponseDto>}
     * @memberof PaginatedOrderResponseDto
     */
    'orders': Array<OrderResponseDto>;
    /**
     * 
     * @type {PaginatedOrderResponseDtoPagination}
     * @memberof PaginatedOrderResponseDto
     */
    'pagination': PaginatedOrderResponseDtoPagination;
}
/**
 * Pagination details
 * @export
 * @interface PaginatedOrderResponseDtoPagination
 */
export interface PaginatedOrderResponseDtoPagination {
    /**
     * Page number (starts from 1)
     * @type {number}
     * @memberof PaginatedOrderResponseDtoPagination
     */
    'page'?: number;
    /**
     * Number of items per page (max 100)
     * @type {number}
     * @memberof PaginatedOrderResponseDtoPagination
     */
    'limit'?: number;
    /**
     * Total number of items
     * @type {number}
     * @memberof PaginatedOrderResponseDtoPagination
     */
    'total': number;
    /**
     * Total number of pages
     * @type {number}
     * @memberof PaginatedOrderResponseDtoPagination
     */
    'totalPages': number;
    /**
     * Whether there is a next page
     * @type {boolean}
     * @memberof PaginatedOrderResponseDtoPagination
     */
    'hasNext': boolean;
    /**
     * Whether there is a previous page
     * @type {boolean}
     * @memberof PaginatedOrderResponseDtoPagination
     */
    'hasPrevious': boolean;
}
/**
 * 
 * @export
 * @interface PaginatedResponseDto
 */
export interface PaginatedResponseDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof PaginatedResponseDto
     */
    'data': Array<string>;
    /**
     * 
     * @type {object}
     * @memberof PaginatedResponseDto
     */
    'pagination': object;
}
/**
 * 
 * @export
 * @interface PaginationDto
 */
export interface PaginationDto {
    /**
     * Page number
     * @type {number}
     * @memberof PaginationDto
     */
    'page': number;
    /**
     * Row per page
     * @type {number}
     * @memberof PaginationDto
     */
    'rowPerPage': number;
    /**
     * Total pages
     * @type {number}
     * @memberof PaginationDto
     */
    'totalPages': number;
}
/**
 * 
 * @export
 * @interface PaginationMetaDto
 */
export interface PaginationMetaDto {
    /**
     * 
     * @type {number}
     * @memberof PaginationMetaDto
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMetaDto
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMetaDto
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMetaDto
     */
    'totalPages': number;
}
/**
 * 
 * @export
 * @interface PasscodeOptionDto
 */
export interface PasscodeOptionDto {
    /**
     * 
     * @type {number}
     * @memberof PasscodeOptionDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof PasscodeOptionDto
     */
    'pin': number;
    /**
     * 
     * @type {PasscodeScopeType}
     * @memberof PasscodeOptionDto
     */
    'scopeType': PasscodeScopeType;
    /**
     * 
     * @type {string}
     * @memberof PasscodeOptionDto
     */
    'scopeId': string;
}


/**
 * 
 * @export
 * @interface PasscodeOptionsResponseDto
 */
export interface PasscodeOptionsResponseDto {
    /**
     * 
     * @type {number}
     * @memberof PasscodeOptionsResponseDto
     */
    'businessId': number;
    /**
     * 
     * @type {string}
     * @memberof PasscodeOptionsResponseDto
     */
    'chainId'?: string;
    /**
     * Available passcodes for business and chain
     * @type {Array<PasscodeOptionDto>}
     * @memberof PasscodeOptionsResponseDto
     */
    'availablePasscodes': Array<PasscodeOptionDto>;
    /**
     * Business permissions with enabled status
     * @type {Array<PermissionDto>}
     * @memberof PasscodeOptionsResponseDto
     */
    'permissions': Array<PermissionDto>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PasscodeScopeType = {
    Business: 'BUSINESS',
    Chain: 'CHAIN'
} as const;

export type PasscodeScopeType = typeof PasscodeScopeType[keyof typeof PasscodeScopeType];


/**
 * 
 * @export
 * @interface PaymentDetailsDto
 */
export interface PaymentDetailsDto {
    /**
     * Payment method type
     * @type {string}
     * @memberof PaymentDetailsDto
     */
    'paymentMethod': string;
    /**
     * Number of transactions
     * @type {number}
     * @memberof PaymentDetailsDto
     */
    'transactionCount': number;
    /**
     * Total sales amount
     * @type {number}
     * @memberof PaymentDetailsDto
     */
    'totalSales': number;
    /**
     * Total amount actually paid
     * @type {number}
     * @memberof PaymentDetailsDto
     */
    'totalPaid': number;
    /**
     * Difference (important for vouchers)
     * @type {number}
     * @memberof PaymentDetailsDto
     */
    'difference': number;
}
/**
 * 
 * @export
 * @interface PaymentErrorDto
 */
export interface PaymentErrorDto {
    /**
     * 
     * @type {PaymentFailureCode}
     * @memberof PaymentErrorDto
     */
    'code': PaymentFailureCode;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentErrorDto
     */
    'retryable': boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentErrorDto
     */
    'message': string;
    /**
     * When this error occurred
     * @type {string}
     * @memberof PaymentErrorDto
     */
    'timestamp': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PaymentFailureCode = {
    PaymentAborted: 'payment.aborted',
    PaymentCancelledByUser: 'payment.cancelled_by_user',
    PaymentInsufficientFunds: 'payment.insufficient_funds',
    PaymentCardExpired: 'payment.card_expired',
    PaymentCardInvalid: 'payment.card_invalid',
    PaymentPinError: 'payment.pin_error',
    PaymentDeclined: 'payment.declined',
    TerminalOffline: 'terminal.offline',
    TerminalTimeout: 'terminal.timeout',
    TerminalBusy: 'terminal.busy',
    SystemProviderError: 'system.provider_error',
    SystemUnknown: 'system.unknown'
} as const;

export type PaymentFailureCode = typeof PaymentFailureCode[keyof typeof PaymentFailureCode];


/**
 * 
 * @export
 * @interface PaymentIntegrationDto
 */
export interface PaymentIntegrationDto {
    /**
     * Unique integration record ID
     * @type {string}
     * @memberof PaymentIntegrationDto
     */
    'id': string;
    /**
     * 
     * @type {BusinessPaymentIntegrationType}
     * @memberof PaymentIntegrationDto
     */
    'type': BusinessPaymentIntegrationType;
    /**
     * Whether the integration is active for this business
     * @type {boolean}
     * @memberof PaymentIntegrationDto
     */
    'active': boolean;
    /**
     * 
     * @type {PaymentIntegrationDtoLinks}
     * @memberof PaymentIntegrationDto
     */
    'links': PaymentIntegrationDtoLinks;
}


/**
 * Set of API routes available for this integration
 * @export
 * @interface PaymentIntegrationDtoLinks
 */
export interface PaymentIntegrationDtoLinks {
    /**
     * API route for validating a gift card
     * @type {string}
     * @memberof PaymentIntegrationDtoLinks
     */
    'validate'?: string | null;
    /**
     * API route for redeeming a gift card
     * @type {string}
     * @memberof PaymentIntegrationDtoLinks
     */
    'redeem'?: string | null;
}
/**
 * 
 * @export
 * @interface PaymentIntegrationLinkDto
 */
export interface PaymentIntegrationLinkDto {
    /**
     * API route for validating a gift card
     * @type {string}
     * @memberof PaymentIntegrationLinkDto
     */
    'validate'?: string | null;
    /**
     * API route for redeeming a gift card
     * @type {string}
     * @memberof PaymentIntegrationLinkDto
     */
    'redeem'?: string | null;
}
/**
 * 
 * @export
 * @interface PaymentIntentIdDto
 */
export interface PaymentIntentIdDto {
    /**
     * The ID of the payment intent to capture or cancel
     * @type {string}
     * @memberof PaymentIntentIdDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PaymentMethod = {
    Cash: 'Cash',
    Card: 'Card',
    Voucher: 'Voucher',
    EPassi: 'EPassi',
    Edenred: 'Edenred',
    Munchi: 'Munchi',
    Flatpay: 'Flatpay',
    GiftUp: 'GiftUp',
    MobilePay: 'MobilePay',
    CardManual: 'CardManual',
    EdenredManual: 'EdenredManual',
    EmployeeDiscount: 'EmployeeDiscount',
    LunchVoucher: 'LunchVoucher',
    EdenredVoucher: 'EdenredVoucher',
    SmartumVoucher: 'SmartumVoucher',
    Invoice: 'Invoice',
    Smartum: 'Smartum',
    GiftCard: 'GiftCard',
    Debit: 'Debit',
    Credit: 'Credit',
    GiftCardManual: 'GiftCardManual',
    WoltBenefit: 'WoltBenefit',
    Fundis: 'Fundis'
} as const;

export type PaymentMethod = typeof PaymentMethod[keyof typeof PaymentMethod];


/**
 * 
 * @export
 * @interface PaymentMethodDetailsDto
 */
export interface PaymentMethodDetailsDto {
    /**
     * Payment method type
     * @type {string}
     * @memberof PaymentMethodDetailsDto
     */
    'type': string;
    /**
     * 
     * @type {PaymentMethodDetailsDtoCardPresentDetails}
     * @memberof PaymentMethodDetailsDto
     */
    'cardPresentDetails'?: PaymentMethodDetailsDtoCardPresentDetails;
    /**
     * 
     * @type {PaymentMethodDetailsDtoInteracPresentDetails}
     * @memberof PaymentMethodDetailsDto
     */
    'interacPresentDetails'?: PaymentMethodDetailsDtoInteracPresentDetails;
    /**
     * 
     * @type {PaymentMethodDetailsDtoWechatPayDetails}
     * @memberof PaymentMethodDetailsDto
     */
    'wechatPayDetails'?: PaymentMethodDetailsDtoWechatPayDetails;
    /**
     * 
     * @type {PaymentMethodDetailsDtoAffirmDetails}
     * @memberof PaymentMethodDetailsDto
     */
    'affirmDetails'?: PaymentMethodDetailsDtoAffirmDetails;
}
/**
 * Affirm payment details
 * @export
 * @interface PaymentMethodDetailsDtoAffirmDetails
 */
export interface PaymentMethodDetailsDtoAffirmDetails {
    /**
     * Payment location
     * @type {string}
     * @memberof PaymentMethodDetailsDtoAffirmDetails
     */
    'location'?: string | null;
    /**
     * Reader identifier
     * @type {string}
     * @memberof PaymentMethodDetailsDtoAffirmDetails
     */
    'reader'?: string | null;
    /**
     * Affirm transaction ID
     * @type {string}
     * @memberof PaymentMethodDetailsDtoAffirmDetails
     */
    'transactionId'?: string | null;
}
/**
 * Card present payment details
 * @export
 * @interface PaymentMethodDetailsDtoCardPresentDetails
 */
export interface PaymentMethodDetailsDtoCardPresentDetails {
    /**
     * Last 4 digits of the card
     * @type {string}
     * @memberof PaymentMethodDetailsDtoCardPresentDetails
     */
    'last4': string;
    /**
     * Card expiration month
     * @type {string}
     * @memberof PaymentMethodDetailsDtoCardPresentDetails
     */
    'expMonth': string;
    /**
     * Card expiration year
     * @type {string}
     * @memberof PaymentMethodDetailsDtoCardPresentDetails
     */
    'expYear': string;
    /**
     * Cardholder name
     * @type {string}
     * @memberof PaymentMethodDetailsDtoCardPresentDetails
     */
    'cardholderName'?: string | null;
    /**
     * Card funding type
     * @type {string}
     * @memberof PaymentMethodDetailsDtoCardPresentDetails
     */
    'funding': string;
    /**
     * Card brand
     * @type {string}
     * @memberof PaymentMethodDetailsDtoCardPresentDetails
     */
    'brand': string;
    /**
     * Generated card identifier
     * @type {string}
     * @memberof PaymentMethodDetailsDtoCardPresentDetails
     */
    'generatedCard'?: string | null;
    /**
     * Receipt data
     * @type {string}
     * @memberof PaymentMethodDetailsDtoCardPresentDetails
     */
    'receipt'?: string | null;
    /**
     * EMV authorization data
     * @type {string}
     * @memberof PaymentMethodDetailsDtoCardPresentDetails
     */
    'emvAuthData'?: string | null;
    /**
     * Card issuing country
     * @type {string}
     * @memberof PaymentMethodDetailsDtoCardPresentDetails
     */
    'country'?: string | null;
    /**
     * Preferred locales
     * @type {Array<string>}
     * @memberof PaymentMethodDetailsDtoCardPresentDetails
     */
    'preferredLocales': Array<string>;
    /**
     * Card issuer
     * @type {string}
     * @memberof PaymentMethodDetailsDtoCardPresentDetails
     */
    'issuer': string;
    /**
     * Issuer identification number
     * @type {string}
     * @memberof PaymentMethodDetailsDtoCardPresentDetails
     */
    'iin': string;
    /**
     * Card network
     * @type {string}
     * @memberof PaymentMethodDetailsDtoCardPresentDetails
     */
    'network': string;
    /**
     * Card description
     * @type {string}
     * @memberof PaymentMethodDetailsDtoCardPresentDetails
     */
    'description': string;
    /**
     * 
     * @type {CardPresentDetailsDtoWallet}
     * @memberof PaymentMethodDetailsDtoCardPresentDetails
     */
    'wallet': CardPresentDetailsDtoWallet;
    /**
     * Reader location
     * @type {string}
     * @memberof PaymentMethodDetailsDtoCardPresentDetails
     */
    'location'?: string | null;
    /**
     * Card reader identifier
     * @type {string}
     * @memberof PaymentMethodDetailsDtoCardPresentDetails
     */
    'reader'?: string | null;
}
/**
 * Interac present payment details
 * @export
 * @interface PaymentMethodDetailsDtoInteracPresentDetails
 */
export interface PaymentMethodDetailsDtoInteracPresentDetails {
    /**
     * Last 4 digits of the card
     * @type {string}
     * @memberof PaymentMethodDetailsDtoInteracPresentDetails
     */
    'last4': string;
    /**
     * Card expiration month
     * @type {string}
     * @memberof PaymentMethodDetailsDtoInteracPresentDetails
     */
    'expMonth': string;
    /**
     * Card expiration year
     * @type {string}
     * @memberof PaymentMethodDetailsDtoInteracPresentDetails
     */
    'expYear': string;
    /**
     * Cardholder name
     * @type {string}
     * @memberof PaymentMethodDetailsDtoInteracPresentDetails
     */
    'cardholderName'?: string | null;
    /**
     * Card funding type
     * @type {string}
     * @memberof PaymentMethodDetailsDtoInteracPresentDetails
     */
    'funding': string;
    /**
     * Card brand
     * @type {string}
     * @memberof PaymentMethodDetailsDtoInteracPresentDetails
     */
    'brand': string;
    /**
     * Generated card identifier
     * @type {string}
     * @memberof PaymentMethodDetailsDtoInteracPresentDetails
     */
    'generatedCard'?: string | null;
    /**
     * Receipt data
     * @type {string}
     * @memberof PaymentMethodDetailsDtoInteracPresentDetails
     */
    'receipt'?: string | null;
    /**
     * EMV authorization data
     * @type {string}
     * @memberof PaymentMethodDetailsDtoInteracPresentDetails
     */
    'emvAuthData'?: string | null;
    /**
     * Card issuing country
     * @type {string}
     * @memberof PaymentMethodDetailsDtoInteracPresentDetails
     */
    'country'?: string | null;
    /**
     * Preferred locales
     * @type {Array<string>}
     * @memberof PaymentMethodDetailsDtoInteracPresentDetails
     */
    'preferredLocales': Array<string>;
    /**
     * Card issuer
     * @type {string}
     * @memberof PaymentMethodDetailsDtoInteracPresentDetails
     */
    'issuer': string;
    /**
     * Issuer identification number
     * @type {string}
     * @memberof PaymentMethodDetailsDtoInteracPresentDetails
     */
    'iin': string;
    /**
     * Card network
     * @type {string}
     * @memberof PaymentMethodDetailsDtoInteracPresentDetails
     */
    'network': string;
    /**
     * Card description
     * @type {string}
     * @memberof PaymentMethodDetailsDtoInteracPresentDetails
     */
    'description': string;
    /**
     * 
     * @type {CardPresentDetailsDtoWallet}
     * @memberof PaymentMethodDetailsDtoInteracPresentDetails
     */
    'wallet': CardPresentDetailsDtoWallet;
    /**
     * Reader location
     * @type {string}
     * @memberof PaymentMethodDetailsDtoInteracPresentDetails
     */
    'location'?: string | null;
    /**
     * Card reader identifier
     * @type {string}
     * @memberof PaymentMethodDetailsDtoInteracPresentDetails
     */
    'reader'?: string | null;
}
/**
 * WeChat Pay payment details
 * @export
 * @interface PaymentMethodDetailsDtoWechatPayDetails
 */
export interface PaymentMethodDetailsDtoWechatPayDetails {
    /**
     * Payment location
     * @type {string}
     * @memberof PaymentMethodDetailsDtoWechatPayDetails
     */
    'location'?: string | null;
    /**
     * Reader identifier
     * @type {string}
     * @memberof PaymentMethodDetailsDtoWechatPayDetails
     */
    'reader'?: string | null;
    /**
     * WeChat Pay transaction ID
     * @type {string}
     * @memberof PaymentMethodDetailsDtoWechatPayDetails
     */
    'transactionId'?: string | null;
}
/**
 * 
 * @export
 * @interface PaymentMethodTypeDto
 */
export interface PaymentMethodTypeDto {
    /**
     * Payment method ID
     * @type {string}
     * @memberof PaymentMethodTypeDto
     */
    'id': string;
    /**
     * Payment method ID
     * @type {string}
     * @memberof PaymentMethodTypeDto
     */
    'referenceId'?: string | null;
    /**
     * Payment method type
     * @type {string}
     * @memberof PaymentMethodTypeDto
     */
    'type': TypeEnum;
    /**
     * Payment amount
     * @type {number}
     * @memberof PaymentMethodTypeDto
     */
    'amount': number;
    /**
     * Change returned to customer
     * @type {number}
     * @memberof PaymentMethodTypeDto
     */
    'change'?: number;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof PaymentMethodTypeDto
     */
    'provider'?: PaymentProvider | null;
    /**
     * 
     * @type {PaymentMethodTypeDtoData}
     * @memberof PaymentMethodTypeDto
     */
    'data'?: PaymentMethodTypeDtoData | null;
}

export const TypeEnum = {
    Cash: 'Cash',
    Card: 'Card',
    Voucher: 'Voucher',
    EPassi: 'EPassi',
    Edenred: 'Edenred',
    Munchi: 'Munchi',
    Flatpay: 'Flatpay',
    GiftUp: 'GiftUp',
    MobilePay: 'MobilePay',
    CardManual: 'CardManual',
    EdenredManual: 'EdenredManual',
    EmployeeDiscount: 'EmployeeDiscount',
    LunchVoucher: 'LunchVoucher',
    EdenredVoucher: 'EdenredVoucher',
    SmartumVoucher: 'SmartumVoucher',
    Invoice: 'Invoice',
    Smartum: 'Smartum',
    GiftCard: 'GiftCard',
    Debit: 'Debit',
    Credit: 'Credit',
    GiftCardManual: 'GiftCardManual',
    WoltBenefit: 'WoltBenefit',
    Fundis: 'Fundis'
} as const;

export type TypeEnum = typeof TypeEnum[keyof typeof TypeEnum];

/**
 * @type PaymentMethodTypeDtoData
 * Payment-specific data. This could be a Stripe PaymentIntent, Viva session data, or null for cash payments.
 * @export
 */
export type PaymentMethodTypeDtoData = Null | object;

/**
 * 
 * @export
 * @interface PaymentMethodsResponseDto
 */
export interface PaymentMethodsResponseDto {
    /**
     * Unique identifier of the payment method
     * @type {string}
     * @memberof PaymentMethodsResponseDto
     */
    'id': string;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof PaymentMethodsResponseDto
     */
    'name': PaymentMethod;
    /**
     * Display position/order of the payment method in UI
     * @type {number}
     * @memberof PaymentMethodsResponseDto
     */
    'position': number;
    /**
     * Additional configuration or metadata related to the payment method, stored as a JSON string
     * @type {string}
     * @memberof PaymentMethodsResponseDto
     */
    'additionalConfig': string;
    /**
     * Indicates whether the payment method is currently enabled or available for use
     * @type {boolean}
     * @memberof PaymentMethodsResponseDto
     */
    'enable': boolean;
    /**
     * ISO timestamp of the last update to the payment method
     * @type {string}
     * @memberof PaymentMethodsResponseDto
     */
    'updated_at': string;
    /**
     * ISO timestamp of when the payment method was first created
     * @type {string}
     * @memberof PaymentMethodsResponseDto
     */
    'created_at': string;
    /**
     * Description of the payment method
     * @type {string}
     * @memberof PaymentMethodsResponseDto
     */
    'description': string;
    /**
     * Short description or name of the payment method
     * @type {string}
     * @memberof PaymentMethodsResponseDto
     */
    'subDescription': string;
    /**
     * URL of the logo image for the payment method
     * @type {string}
     * @memberof PaymentMethodsResponseDto
     */
    'logo': string;
    /**
     * URL of the illustration image for the payment method
     * @type {string}
     * @memberof PaymentMethodsResponseDto
     */
    'illustration': string;
    /**
     * 
     * @type {PosPaymentType}
     * @memberof PaymentMethodsResponseDto
     */
    'type': PosPaymentType;
    /**
     * Name of the payment method that want to show in UI
     * @type {string}
     * @memberof PaymentMethodsResponseDto
     */
    'customName': string;
    /**
     * Should be shown in history filter or not
     * @type {boolean}
     * @memberof PaymentMethodsResponseDto
     */
    'isHiddenInFilters': boolean;
    /**
     * Minimum amount that an order can pay
     * @type {number}
     * @memberof PaymentMethodsResponseDto
     */
    'minimumCheckoutAmount'?: number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PaymentProvider = {
    Stripe: 'stripe',
    Viva: 'viva',
    Nets: 'nets'
} as const;

export type PaymentProvider = typeof PaymentProvider[keyof typeof PaymentProvider];


/**
 * 
 * @export
 * @enum {string}
 */

export const PaymentProviderEnum = {
    Stripe: 'stripe',
    Viva: 'viva',
    Nets: 'nets'
} as const;

export type PaymentProviderEnum = typeof PaymentProviderEnum[keyof typeof PaymentProviderEnum];


/**
 * 
 * @export
 * @interface PaymentProviderResponseDto
 */
export interface PaymentProviderResponseDto {
    /**
     * 
     * @type {string}
     * @memberof PaymentProviderResponseDto
     */
    'id': string;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof PaymentProviderResponseDto
     */
    'provider': PaymentProvider;
    /**
     * 
     * @type {string}
     * @memberof PaymentProviderResponseDto
     */
    'type': string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentProviderResponseDto
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentProviderResponseDto
     */
    'locationId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentProviderResponseDto
     */
    'businessConfigId': string;
    /**
     * 
     * @type {PaymentProviderResponseDtoAdditionalConfig}
     * @memberof PaymentProviderResponseDto
     */
    'additionalConfig': PaymentProviderResponseDtoAdditionalConfig;
}


/**
 * 
 * @export
 * @interface PaymentProviderResponseDtoAdditionalConfig
 */
export interface PaymentProviderResponseDtoAdditionalConfig {
    /**
     * Viva merchant id
     * @type {string}
     * @memberof PaymentProviderResponseDtoAdditionalConfig
     */
    'merchantId'?: string | null;
    /**
     * Viva source code
     * @type {string}
     * @memberof PaymentProviderResponseDtoAdditionalConfig
     */
    'sourceCode'?: string | null;
}
/**
 * 
 * @export
 * @interface PaymentRefundDto
 */
export interface PaymentRefundDto {
    /**
     * Unique internal ID for this refund transaction
     * @type {string}
     * @memberof PaymentRefundDto
     */
    'id': string;
    /**
     * Unique internal ID for this refund transaction
     * @type {string}
     * @memberof PaymentRefundDto
     */
    'refundId': string;
    /**
     * Refund ID from the payment provider (e.g., Stripe refund ID). Deprecated soon
     * @type {string}
     * @memberof PaymentRefundDto
     */
    'providerRefundId': string;
    /**
     * Refund ID from the payment provider V2 (e.g., Stripe refund ID)
     * @type {string}
     * @memberof PaymentRefundDto
     */
    'sourceTransactionId': string | null;
    /**
     * ID of the original payment being refunded
     * @type {string}
     * @memberof PaymentRefundDto
     * @deprecated
     */
    'originalPaymentId'?: string | null;
    /**
     * ID of the original payment being refunded
     * @type {string}
     * @memberof PaymentRefundDto
     */
    'originalPaymentEventId'?: string | null;
    /**
     * 
     * @type {PaymentProviderEnum}
     * @memberof PaymentRefundDto
     */
    'paymentProvider': PaymentProviderEnum;
    /**
     * The amount refunded
     * @type {number}
     * @memberof PaymentRefundDto
     */
    'amount': number;
    /**
     * Currency of the refund (ISO 4217 code, e.g., EUR)
     * @type {string}
     * @memberof PaymentRefundDto
     */
    'currency': string;
    /**
     * 
     * @type {RefundStatusEnum}
     * @memberof PaymentRefundDto
     */
    'status': RefundStatusEnum;
    /**
     * Timestamp when the refund was processed
     * @type {string}
     * @memberof PaymentRefundDto
     */
    'processedAt': string;
    /**
     * Reason for the refund
     * @type {string}
     * @memberof PaymentRefundDto
     */
    'reason'?: string | null;
    /**
     * Specific items refunded
     * @type {Array<RefundedItemDto>}
     * @memberof PaymentRefundDto
     */
    'items'?: Array<RefundedItemDto>;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof PaymentRefundDto
     */
    'type'?: PaymentMethod;
    /**
     * Additional metadata from the payment provider or system
     * @type {{ [key: string]: any; }}
     * @memberof PaymentRefundDto
     */
    'metadata'?: { [key: string]: any; };
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PaymentStatus = {
    Paid: 'paid',
    Pending: 'pending'
} as const;

export type PaymentStatus = typeof PaymentStatus[keyof typeof PaymentStatus];


/**
 * 
 * @export
 * @interface PaymentStatusDto
 */
export interface PaymentStatusDto {
    /**
     * 
     * @type {SimplePaymentStatus}
     * @memberof PaymentStatusDto
     */
    'status': SimplePaymentStatus;
    /**
     * 
     * @type {string}
     * @memberof PaymentStatusDto
     */
    'orderId': string;
    /**
     * Provider Transaction ID
     * @type {string}
     * @memberof PaymentStatusDto
     */
    'transactionId'?: string;
    /**
     * 
     * @type {PaymentErrorDto}
     * @memberof PaymentStatusDto
     */
    'error'?: PaymentErrorDto;
}


/**
 * 
 * @export
 * @interface PaymentTerminalDto
 */
export interface PaymentTerminalDto {
    /**
     * The unique ID of the Payment Terminal.
     * @type {string}
     * @memberof PaymentTerminalDto
     */
    'id': string;
    /**
     * The unique ID of the Payment Terminal.
     * @type {string}
     * @memberof PaymentTerminalDto
     */
    'hardwareId': string;
    /**
     * The unique ID of the Payment Terminal.
     * @type {string}
     * @memberof PaymentTerminalDto
     */
    'label': string | null;
    /**
     * The unique ID of the Payment Terminal.
     * @type {string}
     * @memberof PaymentTerminalDto
     */
    'orderingBusinessId': string;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof PaymentTerminalDto
     */
    'provider': PaymentProvider;
    /**
     * Timestamp when the payment terminal record was last updated.
     * @type {string}
     * @memberof PaymentTerminalDto
     */
    'updatedAt': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PaymentTypeEnum = {
    Cash: 'cash',
    Card: 'card'
} as const;

export type PaymentTypeEnum = typeof PaymentTypeEnum[keyof typeof PaymentTypeEnum];


/**
 * 
 * @export
 * @interface PermissionDto
 */
export interface PermissionDto {
    /**
     * Permission key identifier
     * @type {string}
     * @memberof PermissionDto
     */
    'key': string;
    /**
     * Whether the permission is enabled
     * @type {boolean}
     * @memberof PermissionDto
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface PermissionRuleDto
 */
export interface PermissionRuleDto {
    /**
     * 
     * @type {PosPermission}
     * @memberof PermissionRuleDto
     */
    'key': PosPermission;
    /**
     * Whether this permission is enabled for the role
     * @type {boolean}
     * @memberof PermissionRuleDto
     */
    'enabled': boolean;
}


/**
 * 
 * @export
 * @interface PermissionRuleResponseDto
 */
export interface PermissionRuleResponseDto {
    /**
     * 
     * @type {string}
     * @memberof PermissionRuleResponseDto
     */
    'id': string;
    /**
     * 
     * @type {PosPermission}
     * @memberof PermissionRuleResponseDto
     */
    'key': PosPermission;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionRuleResponseDto
     */
    'enabled': boolean;
}


/**
 * 
 * @export
 * @interface PhoneCodeVerificationDto
 */
export interface PhoneCodeVerificationDto {
    /**
     * User ID
     * @type {number}
     * @memberof PhoneCodeVerificationDto
     */
    'userId': number;
    /**
     * Verification code sent to the user
     * @type {string}
     * @memberof PhoneCodeVerificationDto
     */
    'code': string;
    /**
     * 
     * @type {CodeChannel}
     * @memberof PhoneCodeVerificationDto
     */
    'channel': CodeChannel;
}


/**
 * 
 * @export
 * @interface PointsBreakdownDto
 */
export interface PointsBreakdownDto {
    /**
     * 
     * @type {string}
     * @memberof PointsBreakdownDto
     */
    'expires_at': string;
    /**
     * 
     * @type {number}
     * @memberof PointsBreakdownDto
     */
    'points': number;
}
/**
 * 
 * @export
 * @interface PointsUpdatePayloadDto
 */
export interface PointsUpdatePayloadDto {
    /**
     * 
     * @type {number}
     * @memberof PointsUpdatePayloadDto
     */
    'targetUserId': number;
    /**
     * 
     * @type {number}
     * @memberof PointsUpdatePayloadDto
     */
    'pointsAmount': number;
    /**
     * 
     * @type {TransactionEventType}
     * @memberof PointsUpdatePayloadDto
     */
    'TransactionEventType': TransactionEventType;
}


/**
 * 
 * @export
 * @interface PointsUpdateResponseDto
 */
export interface PointsUpdateResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof PointsUpdateResponseDto
     */
    'status': boolean;
    /**
     * 
     * @type {string}
     * @memberof PointsUpdateResponseDto
     */
    'message': string;
    /**
     * 
     * @type {{ [key: string]: LoyaltyInfoResponseDtoLinksValue; }}
     * @memberof PointsUpdateResponseDto
     */
    '_links': { [key: string]: LoyaltyInfoResponseDtoLinksValue; };
}
/**
 * 
 * @export
 * @interface PosActionPasscodeDto
 */
export interface PosActionPasscodeDto {
    /**
     * 
     * @type {string}
     * @memberof PosActionPasscodeDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PosActionPasscodeDto
     */
    'name': string;
    /**
     * 
     * @type {Array<PermissionRuleResponseDto>}
     * @memberof PosActionPasscodeDto
     */
    'permissionRules': Array<PermissionRuleResponseDto>;
    /**
     * The one-way bcrypt hash of the PIN.
     * @type {string}
     * @memberof PosActionPasscodeDto
     */
    'pinHash': string;
}
/**
 * 
 * @export
 * @interface PosBusinessDto
 */
export interface PosBusinessDto {
    /**
     * 
     * @type {string}
     * @memberof PosBusinessDto
     */
    'orderingBusinessId': string;
    /**
     * 
     * @type {string}
     * @memberof PosBusinessDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PosBusinessDto
     */
    'address': string | null;
    /**
     * 
     * @type {string}
     * @memberof PosBusinessDto
     */
    'email': string | null;
    /**
     * 
     * @type {string}
     * @memberof PosBusinessDto
     */
    'companyName': string | null;
    /**
     * 
     * @type {string}
     * @memberof PosBusinessDto
     */
    'companyPhone': string | null;
    /**
     * 
     * @type {string}
     * @memberof PosBusinessDto
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof PosBusinessDto
     */
    'bic': string | null;
}
/**
 * 
 * @export
 * @interface PosCustomerDto
 */
export interface PosCustomerDto {
    /**
     * The unique identifier of the customer.
     * @type {number}
     * @memberof PosCustomerDto
     */
    'id': number;
    /**
     * The customer\'s first name at the time of the order.
     * @type {string}
     * @memberof PosCustomerDto
     */
    'first_name': string | null;
    /**
     * The customer\'s last name at the time of the order.
     * @type {string}
     * @memberof PosCustomerDto
     */
    'last_name': string | null;
    /**
     * The primary email address of the customer.
     * @type {string}
     * @memberof PosCustomerDto
     */
    'email': string | null;
    /**
     * The primary phone number of the customer (without country code).
     * @type {string}
     * @memberof PosCustomerDto
     */
    'phone': string | null;
    /**
     * The customer\'s phone country code.
     * @type {string}
     * @memberof PosCustomerDto
     */
    'country_code': string | null;
    /**
     * The logo of the customer.
     * @type {string}
     * @memberof PosCustomerDto
     */
    'logo': string | null;
}
/**
 * 
 * @export
 * @interface PosDiscountDto
 */
export interface PosDiscountDto {
    /**
     * 
     * @type {string}
     * @memberof PosDiscountDto
     */
    'id': string;
    /**
     * 
     * @type {DiscountType}
     * @memberof PosDiscountDto
     */
    'type': DiscountType;
    /**
     * 
     * @type {number}
     * @memberof PosDiscountDto
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof PosDiscountDto
     */
    'lineItemId': string | null;
    /**
     * 
     * @type {DiscountScope}
     * @memberof PosDiscountDto
     */
    'scope': DiscountScope;
    /**
     * 
     * @type {string}
     * @memberof PosDiscountDto
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof PosDiscountDto
     */
    'createdAt': string;
    /**
     * 
     * @type {MoneyDto}
     * @memberof PosDiscountDto
     */
    'appliedAmount'?: MoneyDto;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PosDiscountType = {
    Percentage: 'percentage',
    Fixed: 'fixed'
} as const;

export type PosDiscountType = typeof PosDiscountType[keyof typeof PosDiscountType];


/**
 * 
 * @export
 * @interface PosEmployeeDto
 */
export interface PosEmployeeDto {
    /**
     * 
     * @type {string}
     * @memberof PosEmployeeDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PosEmployeeDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PosEmployeeDto
     */
    'roleId': string;
    /**
     * 
     * @type {Status}
     * @memberof PosEmployeeDto
     */
    'status': Status;
    /**
     * The one-way bcrypt hash of the PIN.
     * @type {string}
     * @memberof PosEmployeeDto
     */
    'pinHash': string;
}


/**
 * 
 * @export
 * @interface PosInventoryStatusResponseDto
 */
export interface PosInventoryStatusResponseDto {
    /**
     * Product ID
     * @type {number}
     * @memberof PosInventoryStatusResponseDto
     */
    'product_id': number;
    /**
     * Category ID
     * @type {number}
     * @memberof PosInventoryStatusResponseDto
     */
    'category_id': number;
    /**
     * POS inventory tracking enabled
     * @type {boolean}
     * @memberof PosInventoryStatusResponseDto
     */
    'pos_inventoried': boolean;
    /**
     * Current POS inventory quantity
     * @type {number}
     * @memberof PosInventoryStatusResponseDto
     */
    'pos_quantity': number;
}
/**
 * 
 * @export
 * @interface PosItemDto
 */
export interface PosItemDto {
    /**
     * Product ID
     * @type {number}
     * @memberof PosItemDto
     */
    'id': number;
    /**
     * Product name
     * @type {string}
     * @memberof PosItemDto
     */
    'name': string;
    /**
     * Product price
     * @type {number}
     * @memberof PosItemDto
     */
    'price': number;
    /**
     * Product description
     * @type {string}
     * @memberof PosItemDto
     */
    'description': string;
    /**
     * Product image URL
     * @type {string}
     * @memberof PosItemDto
     */
    'images': string;
    /**
     * Category ID the product belongs to
     * @type {number}
     * @memberof PosItemDto
     */
    'category_id': number;
    /**
     * Whether the product is tracked for inventory
     * @type {boolean}
     * @memberof PosItemDto
     */
    'inventoried': boolean;
    /**
     * Available quantity if inventoried
     * @type {number}
     * @memberof PosItemDto
     */
    'quantity': number;
    /**
     * Whether the product is marked as featured
     * @type {boolean}
     * @memberof PosItemDto
     */
    'featured': boolean;
    /**
     * Whether the product is currently enabled
     * @type {boolean}
     * @memberof PosItemDto
     */
    'enabled': boolean;
    /**
     * Whether upselling is enabled for this product
     * @type {boolean}
     * @memberof PosItemDto
     */
    'upselling': boolean;
    /**
     * Whether the product is part of an offer
     * @type {boolean}
     * @memberof PosItemDto
     */
    'in_offer': boolean;
    /**
     * Offer price if applicable
     * @type {object}
     * @memberof PosItemDto
     */
    'offer_price': object | null;
    /**
     * Display order rank of the product
     * @type {number}
     * @memberof PosItemDto
     */
    'rank': number;
    /**
     * Weight unit (e.g., g, kg, ml)
     * @type {object}
     * @memberof PosItemDto
     */
    'weight_unit': object;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof PosItemDto
     */
    'updated_at': string;
    /**
     * Product creation timestamp
     * @type {string}
     * @memberof PosItemDto
     */
    'created_at': string;
    /**
     * Deletion timestamp if soft-deleted
     * @type {object}
     * @memberof PosItemDto
     */
    'deleted_at': object | null;
    /**
     * List of product extras (e.g., toppings, add-ons)
     * @type {Array<OrderingItemExtraDto>}
     * @memberof PosItemDto
     */
    'extras': Array<OrderingItemExtraDto>;
    /**
     * Whether the product is restricted
     * @type {boolean}
     * @memberof PosItemDto
     */
    'is_restricted': boolean;
    /**
     * 
     * @type {BusinessTaxResponseDto}
     * @memberof PosItemDto
     */
    'tax': BusinessTaxResponseDto | null;
    /**
     * Product color code in hex format
     * @type {string}
     * @memberof PosItemDto
     */
    'colorCode'?: string;
    /**
     * 
     * @type {PrinterTypeEnum}
     * @memberof PosItemDto
     */
    'printer_type'?: PrinterTypeEnum;
    /**
     * Custom UI override color in hex, e.g., #RRGGBB
     * @type {string}
     * @memberof PosItemDto
     */
    'custom_color_code'?: string;
    /**
     * Whether the product has a display label
     * @type {boolean}
     * @memberof PosItemDto
     */
    'display_photo'?: boolean;
    /**
     * 
     * @type {PosItemDtoReportingCategory}
     * @memberof PosItemDto
     */
    'reporting_category'?: PosItemDtoReportingCategory | null;
    /**
     * Indicates if the product is inventoried in POS
     * @type {boolean}
     * @memberof PosItemDto
     */
    'pos_inventoried': boolean;
    /**
     * Quantity of the product in POS
     * @type {number}
     * @memberof PosItemDto
     */
    'pos_quantity': number;
    /**
     * Channel config of inventoried per product
     * @type {Array<ChannelConfig>}
     * @memberof PosItemDto
     */
    'channel_configs': Array<ChannelConfig>;
    /**
     * Order identifier
     * @type {string}
     * @memberof PosItemDto
     */
    'orderId': string;
    /**
     * Selected options for the item
     * @type {Array<PosSelectedOptionDto>}
     * @memberof PosItemDto
     */
    'options': Array<PosSelectedOptionDto>;
    /**
     * Subtotal amount for the item
     * @type {number}
     * @memberof PosItemDto
     */
    'subTotal': number;
    /**
     * Additional comments for the item
     * @type {string}
     * @memberof PosItemDto
     */
    'comment': string;
    /**
     * 
     * @type {DiscountOptionsDto}
     * @memberof PosItemDto
     */
    'discount': DiscountOptionsDto | null;
    /**
     * Whether the item has been printed
     * @type {boolean}
     * @memberof PosItemDto
     */
    'printed': boolean;
    /**
     * Whether the item has been paid for
     * @type {boolean}
     * @memberof PosItemDto
     */
    'paid': boolean;
}


/**
 * Reporting category details
 * @export
 * @interface PosItemDtoReportingCategory
 */
export interface PosItemDtoReportingCategory {
    /**
     * Reporting Category ID
     * @type {number}
     * @memberof PosItemDtoReportingCategory
     */
    'id': number;
    /**
     * Business ID
     * @type {string}
     * @memberof PosItemDtoReportingCategory
     */
    'business_id': string;
    /**
     * Reporting Category Name
     * @type {string}
     * @memberof PosItemDtoReportingCategory
     */
    'reporting_category_name': string;
    /**
     * Index/Order
     * @type {number}
     * @memberof PosItemDtoReportingCategory
     */
    'index': number;
    /**
     * Created at timestamp
     * @type {string}
     * @memberof PosItemDtoReportingCategory
     */
    'created_at': string;
    /**
     * Updated at timestamp
     * @type {string}
     * @memberof PosItemDtoReportingCategory
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface PosOrderDto
 */
export interface PosOrderDto {
    /**
     * 
     * @type {string}
     * @memberof PosOrderDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PosOrderDto
     */
    'businessId': string;
    /**
     * 
     * @type {CurrencyCode}
     * @memberof PosOrderDto
     */
    'currency': CurrencyCode;
    /**
     * 
     * @type {PosBusinessDto}
     * @memberof PosOrderDto
     */
    'business': PosBusinessDto;
    /**
     * 
     * @type {string}
     * @memberof PosOrderDto
     */
    'createdAt': string;
    /**
     * 
     * @type {OrderStatusEnum}
     * @memberof PosOrderDto
     */
    'status': OrderStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PosOrderDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof PosOrderDto
     */
    'orderNumber': string;
    /**
     * 
     * @type {OrderTypePOS}
     * @memberof PosOrderDto
     */
    'orderType': OrderTypePOS;
    /**
     * 
     * @type {string}
     * @memberof PosOrderDto
     */
    'spotNumber': string | null;
    /**
     * 
     * @type {string}
     * @memberof PosOrderDto
     */
    'comments': string | null;
    /**
     * Id of the staff in shift
     * @type {string}
     * @memberof PosOrderDto
     */
    'staffId': string | null;
    /**
     * Id of the shift
     * @type {string}
     * @memberof PosOrderDto
     */
    'shiftId': string | null;
    /**
     * 
     * @type {OrderRefundStatus}
     * @memberof PosOrderDto
     */
    'orderRefundStatus': OrderRefundStatus;
    /**
     * 
     * @type {LocatorType}
     * @memberof PosOrderDto
     */
    'locatorType': LocatorType;
    /**
     * 
     * @type {PosOrderPriceDto}
     * @memberof PosOrderDto
     */
    'basketPrice': PosOrderPriceDto;
    /**
     * 
     * @type {Array<PosOrderItemDto>}
     * @memberof PosOrderDto
     */
    'items': Array<PosOrderItemDto>;
    /**
     * 
     * @type {Array<PosDiscountDto>}
     * @memberof PosOrderDto
     */
    'discounts': Array<PosDiscountDto>;
    /**
     * 
     * @type {PosCustomerDto}
     * @memberof PosOrderDto
     */
    'customer': PosCustomerDto | null;
    /**
     * 
     * @type {Array<TransactionDto>}
     * @memberof PosOrderDto
     */
    'paymentEvents': Array<TransactionDto>;
    /**
     * 
     * @type {Array<PaymentRefundDto>}
     * @memberof PosOrderDto
     */
    'refunds'?: Array<PaymentRefundDto>;
    /**
     * Data version code
     * @type {string}
     * @memberof PosOrderDto
     */
    'version': string;
    /**
     * 
     * @type {OrderFormat}
     * @memberof PosOrderDto
     */
    'orderFormat'?: OrderFormat;
    /**
     * The ID of the loyalty program active during this order.
     * @type {string}
     * @memberof PosOrderDto
     */
    'loyaltyProgramId': string | null;
    /**
     * An array of loyalty transaction IDs related to this order.
     * @type {Array<string>}
     * @memberof PosOrderDto
     */
    'loyaltyTransactionIds': Array<string>;
    /**
     * 
     * @type {PosOrderDtoTaxSummary}
     * @memberof PosOrderDto
     */
    'taxSummary'?: PosOrderDtoTaxSummary;
    /**
     * Name of staff member who created the order
     * @type {string}
     * @memberof PosOrderDto
     */
    'staffName'?: string | null;
    /**
     * 
     * @type {PosOrderDtoInvoiceCompany}
     * @memberof PosOrderDto
     */
    'invoiceCompany'?: PosOrderDtoInvoiceCompany | null;
    /**
     * 
     * @type {object}
     * @memberof PosOrderDto
     */
    'lastPaymentError'?: object;
}


/**
 * Invoice company information for this order
 * @export
 * @interface PosOrderDtoInvoiceCompany
 */
export interface PosOrderDtoInvoiceCompany {
    /**
     * 
     * @type {string}
     * @memberof PosOrderDtoInvoiceCompany
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof PosOrderDtoInvoiceCompany
     */
    'businessId': number;
    /**
     * 
     * @type {string}
     * @memberof PosOrderDtoInvoiceCompany
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PosOrderDtoInvoiceCompany
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof PosOrderDtoInvoiceCompany
     */
    'countryCode': string;
    /**
     * 
     * @type {string}
     * @memberof PosOrderDtoInvoiceCompany
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof PosOrderDtoInvoiceCompany
     */
    'bic'?: string;
    /**
     * 
     * @type {string}
     * @memberof PosOrderDtoInvoiceCompany
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof PosOrderDtoInvoiceCompany
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PosOrderDtoInvoiceCompany
     */
    'updatedAt': string;
}
/**
 * Tax breakdown for this order
 * @export
 * @interface PosOrderDtoTaxSummary
 */
export interface PosOrderDtoTaxSummary {
    /**
     * Tax breakdown by rate
     * @type {Array<OrderTaxSummaryDto>}
     * @memberof PosOrderDtoTaxSummary
     */
    'taxSummaries': Array<OrderTaxSummaryDto>;
    /**
     * Total without tax in cents
     * @type {number}
     * @memberof PosOrderDtoTaxSummary
     */
    'totalWithoutTax': number;
    /**
     * Total tax amount in cents
     * @type {number}
     * @memberof PosOrderDtoTaxSummary
     */
    'totalTax': number;
    /**
     * Grand total in cents
     * @type {number}
     * @memberof PosOrderDtoTaxSummary
     */
    'grandTotal': number;
}
/**
 * 
 * @export
 * @interface PosOrderItemDto
 */
export interface PosOrderItemDto {
    /**
     * 
     * @type {string}
     * @memberof PosOrderItemDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PosOrderItemDto
     */
    'lineItemId': string;
    /**
     * 
     * @type {string}
     * @memberof PosOrderItemDto
     */
    'posId': string;
    /**
     * 
     * @type {string}
     * @memberof PosOrderItemDto
     */
    'name': string;
    /**
     * 
     * @type {MoneyDto}
     * @memberof PosOrderItemDto
     */
    'basePrice': MoneyDto;
    /**
     * 
     * @type {number}
     * @memberof PosOrderItemDto
     */
    'taxRate': number;
    /**
     * 
     * @type {number}
     * @memberof PosOrderItemDto
     */
    'quantity': number;
    /**
     * 
     * @type {ItemPriceDto}
     * @memberof PosOrderItemDto
     */
    'itemPrice': ItemPriceDto;
    /**
     * 
     * @type {KitchenStatus}
     * @memberof PosOrderItemDto
     */
    'kitchenStatus': KitchenStatus;
    /**
     * 
     * @type {PosPaymentStatus}
     * @memberof PosOrderItemDto
     */
    'paymentStatus': PosPaymentStatus;
    /**
     * 
     * @type {PosDiscountDto}
     * @memberof PosOrderItemDto
     */
    'discount': PosDiscountDto | null;
    /**
     * 
     * @type {boolean}
     * @memberof PosOrderItemDto
     */
    'isBundleOffer': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PosOrderItemDto
     */
    'isAlcohol': boolean;
    /**
     * 
     * @type {string}
     * @memberof PosOrderItemDto
     */
    'comments': string | null;
    /**
     * 
     * @type {string}
     * @memberof PosOrderItemDto
     */
    'logo': string | null;
    /**
     * 
     * @type {PrinterTypeEnum}
     * @memberof PosOrderItemDto
     */
    'printerType'?: PrinterTypeEnum;
    /**
     * 
     * @type {Array<PosOrderOptionDto>}
     * @memberof PosOrderItemDto
     */
    'options': Array<PosOrderOptionDto>;
    /**
     * Whether the product has a display label
     * @type {boolean}
     * @memberof PosOrderItemDto
     */
    'display_photo'?: boolean;
    /**
     * 
     * @type {PosItemDtoReportingCategory}
     * @memberof PosOrderItemDto
     */
    'reporting_category'?: PosItemDtoReportingCategory | null;
    /**
     * Category ID of the item
     * @type {number}
     * @memberof PosOrderItemDto
     */
    'category_id': number | null;
}


/**
 * 
 * @export
 * @interface PosOrderOptionDto
 */
export interface PosOrderOptionDto {
    /**
     * 
     * @type {string}
     * @memberof PosOrderOptionDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PosOrderOptionDto
     */
    'posId': string;
    /**
     * 
     * @type {string}
     * @memberof PosOrderOptionDto
     */
    'name': string;
    /**
     * 
     * @type {Array<PosOrderSuboptionDto>}
     * @memberof PosOrderOptionDto
     */
    'suboptions': Array<PosOrderSuboptionDto>;
}
/**
 * 
 * @export
 * @interface PosOrderPayloadDto
 */
export interface PosOrderPayloadDto {
    /**
     * 
     * @type {PosOrderPayloadDtoOrder}
     * @memberof PosOrderPayloadDto
     */
    'order': PosOrderPayloadDtoOrder;
    /**
     * The business ID.
     * @type {number}
     * @memberof PosOrderPayloadDto
     */
    'businessId': number;
    /**
     * For sending to OM
     * @type {boolean}
     * @memberof PosOrderPayloadDto
     */
    'sentToOm': boolean;
    /**
     * For sending to OM as a ticket
     * @type {boolean}
     * @memberof PosOrderPayloadDto
     */
    'isTicket': boolean;
    /**
     * For sending notification to tablet
     * @type {boolean}
     * @memberof PosOrderPayloadDto
     */
    'sendNotification'?: boolean;
}
/**
 * The finalized order data.
 * @export
 * @interface PosOrderPayloadDtoOrder
 */
export interface PosOrderPayloadDtoOrder {
    /**
     * 
     * @type {string}
     * @memberof PosOrderPayloadDtoOrder
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PosOrderPayloadDtoOrder
     */
    'businessId': string;
    /**
     * 
     * @type {CurrencyCode}
     * @memberof PosOrderPayloadDtoOrder
     */
    'currency': CurrencyCode;
    /**
     * 
     * @type {PosBusinessDto}
     * @memberof PosOrderPayloadDtoOrder
     */
    'business': PosBusinessDto;
    /**
     * 
     * @type {string}
     * @memberof PosOrderPayloadDtoOrder
     */
    'createdAt': string;
    /**
     * 
     * @type {OrderStatusEnum}
     * @memberof PosOrderPayloadDtoOrder
     */
    'status': OrderStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PosOrderPayloadDtoOrder
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof PosOrderPayloadDtoOrder
     */
    'orderNumber': string;
    /**
     * 
     * @type {OrderTypePOS}
     * @memberof PosOrderPayloadDtoOrder
     */
    'orderType': OrderTypePOS;
    /**
     * 
     * @type {string}
     * @memberof PosOrderPayloadDtoOrder
     */
    'spotNumber': string | null;
    /**
     * 
     * @type {string}
     * @memberof PosOrderPayloadDtoOrder
     */
    'comments': string | null;
    /**
     * Id of the staff in shift
     * @type {string}
     * @memberof PosOrderPayloadDtoOrder
     */
    'staffId': string | null;
    /**
     * Id of the shift
     * @type {string}
     * @memberof PosOrderPayloadDtoOrder
     */
    'shiftId': string | null;
    /**
     * 
     * @type {OrderRefundStatus}
     * @memberof PosOrderPayloadDtoOrder
     */
    'orderRefundStatus': OrderRefundStatus;
    /**
     * 
     * @type {LocatorType}
     * @memberof PosOrderPayloadDtoOrder
     */
    'locatorType': LocatorType;
    /**
     * 
     * @type {PosOrderPriceDto}
     * @memberof PosOrderPayloadDtoOrder
     */
    'basketPrice': PosOrderPriceDto;
    /**
     * 
     * @type {Array<PosOrderItemDto>}
     * @memberof PosOrderPayloadDtoOrder
     */
    'items': Array<PosOrderItemDto>;
    /**
     * 
     * @type {Array<PosDiscountDto>}
     * @memberof PosOrderPayloadDtoOrder
     */
    'discounts': Array<PosDiscountDto>;
    /**
     * 
     * @type {PosCustomerDto}
     * @memberof PosOrderPayloadDtoOrder
     */
    'customer': PosCustomerDto | null;
    /**
     * 
     * @type {Array<TransactionDto>}
     * @memberof PosOrderPayloadDtoOrder
     */
    'paymentEvents': Array<TransactionDto>;
    /**
     * 
     * @type {Array<PaymentRefundDto>}
     * @memberof PosOrderPayloadDtoOrder
     */
    'refunds'?: Array<PaymentRefundDto>;
    /**
     * Data version code
     * @type {string}
     * @memberof PosOrderPayloadDtoOrder
     */
    'version': string;
    /**
     * 
     * @type {OrderFormat}
     * @memberof PosOrderPayloadDtoOrder
     */
    'orderFormat'?: OrderFormat;
    /**
     * The ID of the loyalty program active during this order.
     * @type {string}
     * @memberof PosOrderPayloadDtoOrder
     */
    'loyaltyProgramId': string | null;
    /**
     * An array of loyalty transaction IDs related to this order.
     * @type {Array<string>}
     * @memberof PosOrderPayloadDtoOrder
     */
    'loyaltyTransactionIds': Array<string>;
    /**
     * 
     * @type {PosOrderDtoTaxSummary}
     * @memberof PosOrderPayloadDtoOrder
     */
    'taxSummary'?: PosOrderDtoTaxSummary;
    /**
     * Name of staff member who created the order
     * @type {string}
     * @memberof PosOrderPayloadDtoOrder
     */
    'staffName'?: string | null;
    /**
     * 
     * @type {PosOrderDtoInvoiceCompany}
     * @memberof PosOrderPayloadDtoOrder
     */
    'invoiceCompany'?: PosOrderDtoInvoiceCompany | null;
    /**
     * 
     * @type {object}
     * @memberof PosOrderPayloadDtoOrder
     */
    'lastPaymentError'?: object;
}


/**
 * 
 * @export
 * @interface PosOrderPriceDto
 */
export interface PosOrderPriceDto {
    /**
     * 
     * @type {PriceBreakdownDto}
     * @memberof PosOrderPriceDto
     */
    'priceBreakdown': PriceBreakdownDto;
    /**
     * 
     * @type {MoneyDto}
     * @memberof PosOrderPriceDto
     */
    'total': MoneyDto;
}
/**
 * 
 * @export
 * @interface PosOrderSuboptionDto
 */
export interface PosOrderSuboptionDto {
    /**
     * 
     * @type {string}
     * @memberof PosOrderSuboptionDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PosOrderSuboptionDto
     */
    'posId': string;
    /**
     * 
     * @type {string}
     * @memberof PosOrderSuboptionDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PosOrderSuboptionDto
     */
    'taxRate': number;
    /**
     * 
     * @type {MoneyDto}
     * @memberof PosOrderSuboptionDto
     */
    'price': MoneyDto;
    /**
     * 
     * @type {number}
     * @memberof PosOrderSuboptionDto
     */
    'quantity': number;
    /**
     * 
     * @type {SuboptionPriceBreakdownDto}
     * @memberof PosOrderSuboptionDto
     */
    'priceBreakdown': SuboptionPriceBreakdownDto;
    /**
     * 
     * @type {string}
     * @memberof PosOrderSuboptionDto
     */
    'value_pos_id': string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PosPaymentStatus = {
    Unpaid: 'unpaid',
    Paying: 'paying',
    Paid: 'paid'
} as const;

export type PosPaymentStatus = typeof PosPaymentStatus[keyof typeof PosPaymentStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const PosPaymentType = {
    Manual: 'manual',
    Static: 'static',
    NonStatic: 'non_static',
    Common: 'common'
} as const;

export type PosPaymentType = typeof PosPaymentType[keyof typeof PosPaymentType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PosPermission = {
    AccessPosApp: 'Access::PosApp',
    PagePos: 'Page::Pos',
    PageOpenOrders: 'Page::OpenOrders',
    PageOrders: 'Page::Orders',
    PageTransactions: 'Page::Transactions',
    PageProducts: 'Page::Products',
    PageReports: 'Page::Reports',
    PageSettings: 'Page::Settings',
    Cart: 'Cart::*',
    CartAddItem: 'Cart::AddItem',
    CartRemoveItem: 'Cart::RemoveItem',
    CartApplyDiscount: 'Cart::ApplyDiscount',
    CartVoidItem: 'Cart::VoidItem',
    CartClear: 'Cart::Clear',
    Transaction: 'Transaction::*',
    TransactionView: 'Transaction::View',
    TransactionRefund: 'Transaction::Refund',
    Shift: 'Shift::*',
    ShiftForceClockOut: 'Shift::ForceClockOut',
    Settings: 'Settings::*',
    SettingsEditProfile: 'Settings::EditProfile'
} as const;

export type PosPermission = typeof PosPermission[keyof typeof PosPermission];


/**
 * 
 * @export
 * @interface PosRoleDto
 */
export interface PosRoleDto {
    /**
     * 
     * @type {string}
     * @memberof PosRoleDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PosRoleDto
     */
    'name': string;
    /**
     * 
     * @type {Array<PermissionRuleResponseDto>}
     * @memberof PosRoleDto
     */
    'permissionRules': Array<PermissionRuleResponseDto>;
}
/**
 * 
 * @export
 * @interface PosSelectedOptionDto
 */
export interface PosSelectedOptionDto {
    /**
     * Option id
     * @type {string}
     * @memberof PosSelectedOptionDto
     */
    'optionId': string;
    /**
     * Option name
     * @type {string}
     * @memberof PosSelectedOptionDto
     */
    'name': string;
    /**
     * Total price
     * @type {number}
     * @memberof PosSelectedOptionDto
     */
    'totalPrice': number;
    /**
     * Sub-options for the discount
     * @type {Array<PosSubOptionDto>}
     * @memberof PosSelectedOptionDto
     */
    'subOption': Array<PosSubOptionDto>;
}
/**
 * 
 * @export
 * @interface PosSessionResponseDto
 */
export interface PosSessionResponseDto {
    /**
     * 
     * @type {OperatingMode}
     * @memberof PosSessionResponseDto
     */
    'operatingMode': OperatingMode;
    /**
     * 
     * @type {Array<PosEmployeeDto>}
     * @memberof PosSessionResponseDto
     */
    'employees': Array<PosEmployeeDto>;
    /**
     * 
     * @type {Array<PosRoleDto>}
     * @memberof PosSessionResponseDto
     */
    'roles': Array<PosRoleDto>;
    /**
     * 
     * @type {Array<PosActionPasscodeDto>}
     * @memberof PosSessionResponseDto
     */
    'actionPasscodes': Array<PosActionPasscodeDto>;
}


/**
 * 
 * @export
 * @interface PosSubOptionDto
 */
export interface PosSubOptionDto {
    /**
     * Sub-option ID
     * @type {string}
     * @memberof PosSubOptionDto
     */
    'subOptionId': string;
    /**
     * Sub-option name
     * @type {string}
     * @memberof PosSubOptionDto
     */
    'name': string;
    /**
     * Sub-option price
     * @type {number}
     * @memberof PosSubOptionDto
     */
    'price': number;
    /**
     * Sub-option quantity
     * @type {number}
     * @memberof PosSubOptionDto
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface PosUpdateOrderDto
 */
export interface PosUpdateOrderDto {
    /**
     * Unique identifier for the order
     * @type {string}
     * @memberof PosUpdateOrderDto
     */
    'orderId': string;
    /**
     * ID of the business updating the order
     * @type {number}
     * @memberof PosUpdateOrderDto
     */
    'orderingBusinessId': number;
    /**
     * 
     * @type {ProviderEnum}
     * @memberof PosUpdateOrderDto
     */
    'provider': ProviderEnum;
    /**
     * 
     * @type {OrderStatusEnum}
     * @memberof PosUpdateOrderDto
     */
    'status': OrderStatusEnum;
    /**
     * Whether the order is a ticket
     * @type {boolean}
     * @memberof PosUpdateOrderDto
     */
    'isTicket'?: boolean;
}


/**
 * 
 * @export
 * @interface PreOrderReminderDto
 */
export interface PreOrderReminderDto {
    /**
     * Unique identifier for the order
     * @type {string}
     * @memberof PreOrderReminderDto
     */
    'orderId': string;
    /**
     * ID of the business updating the order
     * @type {number}
     * @memberof PreOrderReminderDto
     */
    'orderingBusinessId': number;
    /**
     * 
     * @type {ProviderEnum}
     * @memberof PreOrderReminderDto
     */
    'provider': ProviderEnum;
    /**
     * Pickup time of the order
     * @type {string}
     * @memberof PreOrderReminderDto
     */
    'scheduledTime': string;
}


/**
 * 
 * @export
 * @interface PreorderDto
 */
export interface PreorderDto {
    /**
     * Preorder ID
     * @type {string}
     * @memberof PreorderDto
     */
    'id': string;
    /**
     * 
     * @type {PreorderStatus}
     * @memberof PreorderDto
     */
    'status': PreorderStatus;
    /**
     * Preorder time
     * @type {string}
     * @memberof PreorderDto
     */
    'preorderTime': string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PreorderStatus = {
    Waiting: 'waiting',
    Confirm: 'confirm'
} as const;

export type PreorderStatus = typeof PreorderStatus[keyof typeof PreorderStatus];


/**
 * 
 * @export
 * @interface PriceBreakdownDto
 */
export interface PriceBreakdownDto {
    /**
     * 
     * @type {MoneyDto}
     * @memberof PriceBreakdownDto
     */
    'totalBeforeDiscounts': MoneyDto;
    /**
     * 
     * @type {MoneyDto}
     * @memberof PriceBreakdownDto
     */
    'subtotalItemDiscounts': MoneyDto;
    /**
     * 
     * @type {MoneyDto}
     * @memberof PriceBreakdownDto
     */
    'subtotalBasketDiscounts': MoneyDto;
    /**
     * 
     * @type {MoneyDto}
     * @memberof PriceBreakdownDto
     */
    'totalDiscounts': MoneyDto;
}
/**
 * 
 * @export
 * @interface PriceSummaryDto
 */
export interface PriceSummaryDto {
    /**
     * Price summary ID
     * @type {string}
     * @memberof PriceSummaryDto
     */
    'id': string;
    /**
     * Total net amount
     * @type {number}
     * @memberof PriceSummaryDto
     */
    'totalNet': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PrinterTypeEnum = {
    Kitchen: 'KITCHEN',
    Bar: 'BAR',
    Receipt: 'RECEIPT',
    Cloud: 'CLOUD'
} as const;

export type PrinterTypeEnum = typeof PrinterTypeEnum[keyof typeof PrinterTypeEnum];


/**
 * 
 * @export
 * @interface ProcessOrderActionsDto
 */
export interface ProcessOrderActionsDto {
    /**
     * Array of actions to process
     * @type {Array<string>}
     * @memberof ProcessOrderActionsDto
     */
    'actions': Array<ActionsEnum>;
    /**
     * 
     * @type {ProcessOrderActionsDtoData}
     * @memberof ProcessOrderActionsDto
     */
    'data': ProcessOrderActionsDtoData;
}

export const ActionsEnum = {
    Ticketing: 'Ticketing',
    OrderChange: 'OrderChange',
    NewOrder: 'NewOrder',
    Printing: 'Printing',
    PosOrderChange: 'PosOrderChange',
    UpdateLoyaltyPoints: 'UpdateLoyaltyPoints'
} as const;

export type ActionsEnum = typeof ActionsEnum[keyof typeof ActionsEnum];

/**
 * Action-specific data
 * @export
 * @interface ProcessOrderActionsDtoData
 */
export interface ProcessOrderActionsDtoData {
    /**
     * Order ID
     * @type {string}
     * @memberof ProcessOrderActionsDtoData
     */
    'orderId': string;
    /**
     * Business ID
     * @type {string}
     * @memberof ProcessOrderActionsDtoData
     */
    'businessId': string;
    /**
     * Array of cancelled line item IDs
     * @type {Array<string>}
     * @memberof ProcessOrderActionsDtoData
     */
    'cancelledItems': Array<string>;
    /**
     * targetUserId
     * @type {number}
     * @memberof ProcessOrderActionsDtoData
     */
    'targetUserId'?: number;
}
/**
 * 
 * @export
 * @interface ProcessOrderActionsResponseDto
 */
export interface ProcessOrderActionsResponseDto {
    /**
     * 
     * @type {ProcessOrderActionsResponseDtoOrder}
     * @memberof ProcessOrderActionsResponseDto
     */
    'order': ProcessOrderActionsResponseDtoOrder;
    /**
     * Actions that were processed
     * @type {Array<string>}
     * @memberof ProcessOrderActionsResponseDto
     */
    'processedActions': Array<string>;
}
/**
 * Processed order
 * @export
 * @interface ProcessOrderActionsResponseDtoOrder
 */
export interface ProcessOrderActionsResponseDtoOrder {
    /**
     * 
     * @type {string}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'businessId': string;
    /**
     * 
     * @type {CurrencyCode}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'currency': CurrencyCode;
    /**
     * 
     * @type {PosBusinessDto}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'business': PosBusinessDto;
    /**
     * 
     * @type {string}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'createdAt': string;
    /**
     * 
     * @type {OrderStatusEnum}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'status': OrderStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'orderNumber': string;
    /**
     * 
     * @type {OrderTypePOS}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'orderType': OrderTypePOS;
    /**
     * 
     * @type {string}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'spotNumber': string | null;
    /**
     * 
     * @type {string}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'comments': string | null;
    /**
     * Id of the staff in shift
     * @type {string}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'staffId': string | null;
    /**
     * Id of the shift
     * @type {string}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'shiftId': string | null;
    /**
     * 
     * @type {OrderRefundStatus}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'orderRefundStatus': OrderRefundStatus;
    /**
     * 
     * @type {LocatorType}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'locatorType': LocatorType;
    /**
     * 
     * @type {PosOrderPriceDto}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'basketPrice': PosOrderPriceDto;
    /**
     * 
     * @type {Array<PosOrderItemDto>}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'items': Array<PosOrderItemDto>;
    /**
     * 
     * @type {Array<PosDiscountDto>}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'discounts': Array<PosDiscountDto>;
    /**
     * 
     * @type {PosCustomerDto}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'customer': PosCustomerDto | null;
    /**
     * 
     * @type {Array<TransactionDto>}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'paymentEvents': Array<TransactionDto>;
    /**
     * 
     * @type {Array<PaymentRefundDto>}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'refunds'?: Array<PaymentRefundDto>;
    /**
     * Data version code
     * @type {string}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'version': string;
    /**
     * 
     * @type {OrderFormat}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'orderFormat'?: OrderFormat;
    /**
     * The ID of the loyalty program active during this order.
     * @type {string}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'loyaltyProgramId': string | null;
    /**
     * An array of loyalty transaction IDs related to this order.
     * @type {Array<string>}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'loyaltyTransactionIds': Array<string>;
    /**
     * 
     * @type {PosOrderDtoTaxSummary}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'taxSummary'?: PosOrderDtoTaxSummary;
    /**
     * Name of staff member who created the order
     * @type {string}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'staffName'?: string | null;
    /**
     * 
     * @type {PosOrderDtoInvoiceCompany}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'invoiceCompany'?: PosOrderDtoInvoiceCompany | null;
    /**
     * 
     * @type {object}
     * @memberof ProcessOrderActionsResponseDtoOrder
     */
    'lastPaymentError'?: object;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ProductAvailability = {
    Available: 'AVAILABLE',
    UnavailableToday: 'UNAVAILABLE_TODAY',
    UnavailableIndefinitely: 'UNAVAILABLE_INDEFINITELY'
} as const;

export type ProductAvailability = typeof ProductAvailability[keyof typeof ProductAvailability];


/**
 * 
 * @export
 * @enum {string}
 */

export const ProductDetailLayout = {
    Modal: 'MODAL',
    Screen: 'SCREEN'
} as const;

export type ProductDetailLayout = typeof ProductDetailLayout[keyof typeof ProductDetailLayout];


/**
 * 
 * @export
 * @interface ProductDto
 */
export interface ProductDto {
    /**
     * Product ID
     * @type {string}
     * @memberof ProductDto
     */
    'id': string;
    /**
     * Product external ID
     * @type {string}
     * @memberof ProductDto
     */
    'externalId': string;
    /**
     * Product name
     * @type {string}
     * @memberof ProductDto
     */
    'name': string;
    /**
     * Quantity of product
     * @type {number}
     * @memberof ProductDto
     */
    'quantity': number;
    /**
     * Unit price of product
     * @type {number}
     * @memberof ProductDto
     */
    'unitPrice': number;
    /**
     * Paid price of product
     * @type {number}
     * @memberof ProductDto
     */
    'paidPrice': number;
    /**
     * Comment for the product
     * @type {string}
     * @memberof ProductDto
     */
    'comment': string | null;
    /**
     * Custom fields for the product
     * @type {object}
     * @memberof ProductDto
     */
    'customField': object | null;
    /**
     * Kitchen status of the product
     * @type {string}
     * @memberof ProductDto
     */
    'kitchenStatus': string | null;
    /**
     * List of product options
     * @type {Array<OptionDto>}
     * @memberof ProductDto
     */
    'options': Array<OptionDto>;
}
/**
 * 
 * @export
 * @interface ProductWithCategoryDto
 */
export interface ProductWithCategoryDto {
    /**
     * Product ID
     * @type {number}
     * @memberof ProductWithCategoryDto
     */
    'id': number;
    /**
     * Product name
     * @type {string}
     * @memberof ProductWithCategoryDto
     */
    'name': string;
    /**
     * Product price
     * @type {number}
     * @memberof ProductWithCategoryDto
     */
    'price': number;
    /**
     * Product description
     * @type {string}
     * @memberof ProductWithCategoryDto
     */
    'description': string;
    /**
     * Product image URL
     * @type {string}
     * @memberof ProductWithCategoryDto
     */
    'images': string;
    /**
     * Category ID the product belongs to
     * @type {number}
     * @memberof ProductWithCategoryDto
     */
    'category_id': number;
    /**
     * Whether the product is tracked for inventory
     * @type {boolean}
     * @memberof ProductWithCategoryDto
     */
    'inventoried': boolean;
    /**
     * Available quantity if inventoried
     * @type {number}
     * @memberof ProductWithCategoryDto
     */
    'quantity': number;
    /**
     * Whether the product is marked as featured
     * @type {boolean}
     * @memberof ProductWithCategoryDto
     */
    'featured': boolean;
    /**
     * Whether the product is currently enabled
     * @type {boolean}
     * @memberof ProductWithCategoryDto
     */
    'enabled': boolean;
    /**
     * Whether upselling is enabled for this product
     * @type {boolean}
     * @memberof ProductWithCategoryDto
     */
    'upselling': boolean;
    /**
     * Whether the product is part of an offer
     * @type {boolean}
     * @memberof ProductWithCategoryDto
     */
    'in_offer': boolean;
    /**
     * Offer price if applicable
     * @type {object}
     * @memberof ProductWithCategoryDto
     */
    'offer_price': object | null;
    /**
     * Display order rank of the product
     * @type {number}
     * @memberof ProductWithCategoryDto
     */
    'rank': number;
    /**
     * Weight unit (e.g., g, kg, ml)
     * @type {object}
     * @memberof ProductWithCategoryDto
     */
    'weight_unit': object;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof ProductWithCategoryDto
     */
    'updated_at': string;
    /**
     * Product creation timestamp
     * @type {string}
     * @memberof ProductWithCategoryDto
     */
    'created_at': string;
    /**
     * Deletion timestamp if soft-deleted
     * @type {object}
     * @memberof ProductWithCategoryDto
     */
    'deleted_at': object | null;
    /**
     * List of product extras (e.g., toppings, add-ons)
     * @type {Array<OrderingItemExtraDto>}
     * @memberof ProductWithCategoryDto
     */
    'extras': Array<OrderingItemExtraDto>;
    /**
     * Whether the product is restricted
     * @type {boolean}
     * @memberof ProductWithCategoryDto
     */
    'is_restricted': boolean;
    /**
     * 
     * @type {BusinessTaxResponseDto}
     * @memberof ProductWithCategoryDto
     */
    'tax': BusinessTaxResponseDto | null;
    /**
     * Name of the category this product belongs to
     * @type {string}
     * @memberof ProductWithCategoryDto
     */
    'categoryName': string;
    /**
     * Indicates if the product is inventoried in POS
     * @type {boolean}
     * @memberof ProductWithCategoryDto
     */
    'pos_inventoried': boolean;
    /**
     * Quantity of the product in POS
     * @type {number}
     * @memberof ProductWithCategoryDto
     */
    'pos_quantity': number;
    /**
     * Channel config of inventoried per product
     * @type {Array<ChannelConfig>}
     * @memberof ProductWithCategoryDto
     */
    'channel_configs': Array<ChannelConfig>;
}
/**
 * 
 * @export
 * @interface ProductsByCategoriesResponseDto
 */
export interface ProductsByCategoriesResponseDto {
    /**
     * List of products with their associated categories
     * @type {Array<ProductWithCategoryDto>}
     * @memberof ProductsByCategoriesResponseDto
     */
    'products': Array<ProductWithCategoryDto>;
    /**
     * 
     * @type {ProductsByCategoriesResponseDtoSummary}
     * @memberof ProductsByCategoriesResponseDto
     */
    'summary': ProductsByCategoriesResponseDtoSummary;
}
/**
 * Summary data for products and categories
 * @export
 * @interface ProductsByCategoriesResponseDtoSummary
 */
export interface ProductsByCategoriesResponseDtoSummary {
    /**
     * Total number of products
     * @type {number}
     * @memberof ProductsByCategoriesResponseDtoSummary
     */
    'productCount': number;
    /**
     * Total number of categories
     * @type {number}
     * @memberof ProductsByCategoriesResponseDtoSummary
     */
    'categoryCount': number;
}
/**
 * 
 * @export
 * @interface ProductsSummaryDto
 */
export interface ProductsSummaryDto {
    /**
     * Total number of products
     * @type {number}
     * @memberof ProductsSummaryDto
     */
    'productCount': number;
    /**
     * Total number of categories
     * @type {number}
     * @memberof ProductsSummaryDto
     */
    'categoryCount': number;
}
/**
 * 
 * @export
 * @interface ProgramUserDto
 */
export interface ProgramUserDto {
    /**
     * The id of the user
     * @type {number}
     * @memberof ProgramUserDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ProgramUserDto
     */
    'first_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProgramUserDto
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof ProgramUserDto
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramUserDto
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof ProgramUserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramUserDto
     */
    'image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramUserDto
     */
    'country_code': string;
    /**
     * 
     * @type {string}
     * @memberof ProgramUserDto
     */
    'date_of_birth'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramUserDto
     */
    'address'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ProviderEnum = {
    Wolt: 'Wolt',
    MunchiOnline: 'MunchiOnline',
    MunchiKiosk: 'MunchiKiosk',
    MunchiPos: 'MunchiPos',
    UberEats: 'UberEats',
    Foodora: 'Foodora',
    Bolt: 'Bolt',
    MunchiKioskV2: 'MunchiKioskV2',
    Kiosk: 'Kiosk'
} as const;

export type ProviderEnum = typeof ProviderEnum[keyof typeof ProviderEnum];


/**
 * 
 * @export
 * @interface ProviderIntegrationDto
 */
export interface ProviderIntegrationDto {
    /**
     * Provider external ID (unique key used in integrations)
     * @type {string}
     * @memberof ProviderIntegrationDto
     */
    'externalId': string;
    /**
     * 
     * @type {ProviderEnum}
     * @memberof ProviderIntegrationDto
     */
    'provider': ProviderEnum;
    /**
     * Business orderingBusinessId
     * @type {number}
     * @memberof ProviderIntegrationDto
     */
    'orderingBusinessId': number;
    /**
     * Integrations this provider supports (capability)
     * @type {Array<IntegrationType>}
     * @memberof ProviderIntegrationDto
     */
    'supportedIntegrations': Array<IntegrationType>;
    /**
     * Whether this provider is internal (starts with \"Munchi\")
     * @type {boolean}
     * @memberof ProviderIntegrationDto
     */
    'isInternal': boolean;
}


/**
 * 
 * @export
 * @interface ProviderMapResponseDto
 */
export interface ProviderMapResponseDto {
    /**
     * Only providers configured for this business are included. Keys are ProviderEnum values.
     * @type {{ [key: string]: ProviderResponseDto; }}
     * @memberof ProviderMapResponseDto
     */
    'providers': { [key: string]: ProviderResponseDto; };
}
/**
 * 
 * @export
 * @interface ProviderResponseDto
 */
export interface ProviderResponseDto {
    /**
     * Whether the update failed (true) or succeeded (false)
     * @type {boolean}
     * @memberof ProviderResponseDto
     */
    'error': boolean;
    /**
     * Status message for the provider
     * @type {string}
     * @memberof ProviderResponseDto
     */
    'message': string;
    /**
     * Time when the product will be updated
     * @type {string}
     * @memberof ProviderResponseDto
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface ProviderStatusResponseDto
 */
export interface ProviderStatusResponseDto {
    /**
     * 
     * @type {ProviderEnum}
     * @memberof ProviderStatusResponseDto
     */
    'provider': ProviderEnum;
    /**
     * Provider open status
     * @type {boolean}
     * @memberof ProviderStatusResponseDto
     */
    'open': boolean;
}


/**
 * 
 * @export
 * @interface ReadyOrderDto
 */
export interface ReadyOrderDto {
    /**
     * Unique identifier for the order
     * @type {string}
     * @memberof ReadyOrderDto
     */
    'orderId': string;
    /**
     * ID of the business updating the order
     * @type {number}
     * @memberof ReadyOrderDto
     */
    'orderingBusinessId': number;
    /**
     * 
     * @type {ProviderEnum}
     * @memberof ReadyOrderDto
     */
    'provider': ProviderEnum;
}


/**
 * 
 * @export
 * @interface ReceiptDetailsDto
 */
export interface ReceiptDetailsDto {
    /**
     * Account type
     * @type {string}
     * @memberof ReceiptDetailsDto
     */
    'accountType': string;
    /**
     * Application cryptogram
     * @type {string}
     * @memberof ReceiptDetailsDto
     */
    'applicationCryptogram': string;
    /**
     * Application preferred name
     * @type {string}
     * @memberof ReceiptDetailsDto
     */
    'applicationPreferredName': string;
    /**
     * Authorization code
     * @type {string}
     * @memberof ReceiptDetailsDto
     */
    'authorizationCode': string;
    /**
     * Authorization response code
     * @type {string}
     * @memberof ReceiptDetailsDto
     */
    'authorizationResponseCode': string;
    /**
     * Cardholder verification method
     * @type {string}
     * @memberof ReceiptDetailsDto
     */
    'cvm': string;
    /**
     * Dedicated file name
     * @type {string}
     * @memberof ReceiptDetailsDto
     */
    'dedicatedFileName': string;
    /**
     * Terminal verification result
     * @type {string}
     * @memberof ReceiptDetailsDto
     */
    'terminalVerificationResult': string;
    /**
     * Transaction status information
     * @type {string}
     * @memberof ReceiptDetailsDto
     */
    'transactionStatusInformation': string;
}
/**
 * 
 * @export
 * @interface RedeemGiftCardDto
 */
export interface RedeemGiftCardDto {
    /**
     * 
     * @type {string}
     * @memberof RedeemGiftCardDto
     */
    'giftCardNumber': string;
    /**
     * 
     * @type {number}
     * @memberof RedeemGiftCardDto
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof RedeemGiftCardDto
     */
    'orderingBusinessId': number;
}
/**
 * 
 * @export
 * @interface RedeemGiftCardResponseDto
 */
export interface RedeemGiftCardResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof RedeemGiftCardResponseDto
     */
    'success': boolean;
    /**
     * 
     * @type {number}
     * @memberof RedeemGiftCardResponseDto
     */
    'errorCode'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RedeemGiftCardResponseDto
     */
    'redeemedAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RedeemGiftCardResponseDto
     */
    'remainingBalance'?: number;
    /**
     * 
     * @type {string}
     * @memberof RedeemGiftCardResponseDto
     */
    'currency'?: string;
}
/**
 * 
 * @export
 * @interface RefreshTokenDto
 */
export interface RefreshTokenDto {
    /**
     * JWT refresh token issued by the login endpoint
     * @type {string}
     * @memberof RefreshTokenDto
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface RefreshTokenResponseDto
 */
export interface RefreshTokenResponseDto {
    /**
     * Message indicating that new access and refresh tokens have been generated
     * @type {string}
     * @memberof RefreshTokenResponseDto
     */
    'message': string;
    /**
     * New access token for authenticated API requests
     * @type {string}
     * @memberof RefreshTokenResponseDto
     */
    'accessToken': string;
    /**
     * New refresh token to obtain future access tokens
     * @type {string}
     * @memberof RefreshTokenResponseDto
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface RefundChoiceOptionDto
 */
export interface RefundChoiceOptionDto {
    /**
     * 
     * @type {string}
     * @memberof RefundChoiceOptionDto
     */
    'originalPaymentEventId': string;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof RefundChoiceOptionDto
     */
    'method': PaymentMethod;
    /**
     * 
     * @type {number}
     * @memberof RefundChoiceOptionDto
     */
    'amountAvailable': number;
    /**
     * 
     * @type {string}
     * @memberof RefundChoiceOptionDto
     */
    'cardLastFour'?: string;
}


/**
 * 
 * @export
 * @interface RefundDto
 */
export interface RefundDto {
    /**
     * Unique identifier for the refund
     * @type {string}
     * @memberof RefundDto
     */
    'id': string;
    /**
     * Reference ID for the refund
     * @type {string}
     * @memberof RefundDto
     */
    'referenceId': string;
    /**
     * Original reference ID
     * @type {string}
     * @memberof RefundDto
     */
    'originalReferenceId': string;
    /**
     * Provider refund ID
     * @type {string}
     * @memberof RefundDto
     */
    'providerRefundId': string;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof RefundDto
     */
    'paymentProvider': PaymentProvider;
    /**
     * Refund amount
     * @type {string}
     * @memberof RefundDto
     */
    'amount': string;
    /**
     * Currency code
     * @type {string}
     * @memberof RefundDto
     */
    'currency': string;
    /**
     * 
     * @type {RefundStatusEnum}
     * @memberof RefundDto
     */
    'status': RefundStatusEnum;
    /**
     * Date when the refund was processed
     * @type {string}
     * @memberof RefundDto
     */
    'processedAt': string;
    /**
     * External order ID
     * @type {string}
     * @memberof RefundDto
     */
    'orderExternalId': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RefundMode = {
    Full: 'FULL',
    Item: 'ITEM'
} as const;

export type RefundMode = typeof RefundMode[keyof typeof RefundMode];


/**
 * 
 * @export
 * @enum {string}
 */

export const RefundOverallStatus = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    ChoiceRequired: 'CHOICE_REQUIRED',
    Completed: 'COMPLETED',
    Failed: 'FAILED'
} as const;

export type RefundOverallStatus = typeof RefundOverallStatus[keyof typeof RefundOverallStatus];


/**
 * 
 * @export
 * @interface RefundPayloadDto
 */
export interface RefundPayloadDto {
    /**
     * The ordering business ID for this transaction.
     * @type {number}
     * @memberof RefundPayloadDto
     */
    'orderingBusinessId': number;
    /**
     * The POS order id for this transaction.
     * @type {string}
     * @memberof RefundPayloadDto
     */
    'posOrderId': string;
    /**
     * The transaction IDs to refund.
     * @type {Array<string>}
     * @memberof RefundPayloadDto
     */
    'transactionIds': Array<string> | null;
    /**
     * The item data to be refunded
     * @type {Array<RefundedItemDto>}
     * @memberof RefundPayloadDto
     */
    'items': Array<RefundedItemDto> | null;
    /**
     * The unique ID of the transaction to be refunded
     * @type {string}
     * @memberof RefundPayloadDto
     */
    'refundTransactionId': string | null;
    /**
     * The terminal id for this transaction.
     * @type {string}
     * @memberof RefundPayloadDto
     */
    'terminalId': string;
}
/**
 * 
 * @export
 * @interface RefundPayloadDtoV4
 */
export interface RefundPayloadDtoV4 {
    /**
     * The amount to be refunded.
     * @type {number}
     * @memberof RefundPayloadDtoV4
     */
    'amount': number;
    /**
     * The merchant ID for this transaction
     * @type {string}
     * @memberof RefundPayloadDtoV4
     */
    'merchantId': string;
    /**
     * The parent session ID for this transaction.
     * @type {string}
     * @memberof RefundPayloadDtoV4
     */
    'parentSessionId': string;
    /**
     * The parent session ID for this transaction.
     * @type {string}
     * @memberof RefundPayloadDtoV4
     */
    'orderId': string;
    /**
     * The business ID for this transaction.
     * @type {string}
     * @memberof RefundPayloadDtoV4
     */
    'businessId': string;
    /**
     * The terminal ID for this transaction
     * @type {string}
     * @memberof RefundPayloadDtoV4
     */
    'terminalId': string;
}
/**
 * 
 * @export
 * @interface RefundPlanDto
 */
export interface RefundPlanDto {
    /**
     * 
     * @type {string}
     * @memberof RefundPlanDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RefundPlanDto
     */
    'orderId': string;
    /**
     * 
     * @type {string}
     * @memberof RefundPlanDto
     */
    'businessId': string;
    /**
     * 
     * @type {RefundMode}
     * @memberof RefundPlanDto
     */
    'mode': RefundMode;
    /**
     * A translation key for the frontend if the status is FAILED.
     * @type {object}
     * @memberof RefundPlanDto
     */
    'failureReasonKey'?: object | null;
    /**
     * 
     * @type {RefundOverallStatus}
     * @memberof RefundPlanDto
     */
    'status': RefundOverallStatus;
    /**
     * The index of the current PENDING step in the plan. Null if complete or requires choice.
     * @type {number}
     * @memberof RefundPlanDto
     */
    'activeStepIndex'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RefundPlanDto
     */
    'totalAmount': number;
    /**
     * List of refunded items
     * @type {Array<RefundedItemDto>}
     * @memberof RefundPlanDto
     */
    'items': Array<RefundedItemDto>;
    /**
     * 
     * @type {Array<RefundPlanItemDto>}
     * @memberof RefundPlanDto
     */
    'plan': Array<RefundPlanItemDto>;
    /**
     * 
     * @type {string}
     * @memberof RefundPlanDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof RefundPlanDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof RefundPlanDto
     */
    'amountToRefund'?: number;
    /**
     * 
     * @type {Array<RefundChoiceOptionDto>}
     * @memberof RefundPlanDto
     */
    'options'?: Array<RefundChoiceOptionDto>;
}


/**
 * 
 * @export
 * @interface RefundPlanItemDto
 */
export interface RefundPlanItemDto {
    /**
     * 
     * @type {string}
     * @memberof RefundPlanItemDto
     */
    'stepId': string;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof RefundPlanItemDto
     */
    'method': PaymentMethod;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof RefundPlanItemDto
     */
    'provider'?: PaymentProvider;
    /**
     * The amount to be refunded in cents.
     * @type {number}
     * @memberof RefundPlanItemDto
     */
    'amount': number;
    /**
     * The unique ID of the original payment event this refund is sourced from.
     * @type {string}
     * @memberof RefundPlanItemDto
     */
    'originalPaymentEventId': string;
    /**
     * The reference ID (e.g., session or payment intent ID) of the original transaction, crucial for provider APIs.
     * @type {string}
     * @memberof RefundPlanItemDto
     */
    'originalPaymentReferenceId': string | null;
    /**
     * 
     * @type {RefundStepStatus}
     * @memberof RefundPlanItemDto
     */
    'status': RefundStepStatus;
    /**
     * The full, unaltered raw response from the payment provider for this specific transaction.
     * @type {{ [key: string]: any; }}
     * @memberof RefundPlanItemDto
     */
    'rawData'?: { [key: string]: any; } | null;
}


/**
 * 
 * @export
 * @interface RefundRequestItemDto
 */
export interface RefundRequestItemDto {
    /**
     * The unique identifier of the original order line item.
     * @type {string}
     * @memberof RefundRequestItemDto
     */
    'lineItemId': string;
    /**
     * The quantity of the item to be refunded. Must be at least 1.
     * @type {number}
     * @memberof RefundRequestItemDto
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RefundStatusEnum = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failed: 'FAILED',
    Canceled: 'CANCELED'
} as const;

export type RefundStatusEnum = typeof RefundStatusEnum[keyof typeof RefundStatusEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const RefundStepStatus = {
    Pending: 'PENDING',
    InProgress: 'in_progress',
    Failed: 'FAILED',
    Completed: 'COMPLETED'
} as const;

export type RefundStepStatus = typeof RefundStepStatus[keyof typeof RefundStepStatus];


/**
 * 
 * @export
 * @interface RefundedItemDto
 */
export interface RefundedItemDto {
    /**
     * Unique ID for this refunded item record (response only)
     * @type {string}
     * @memberof RefundedItemDto
     */
    'id'?: string | null;
    /**
     * Reference to the unique line item from the original order
     * @type {string}
     * @memberof RefundedItemDto
     */
    'lineItemId': string;
    /**
     * Reference to the general product\'s ID (e.g., SKU or posId)
     * @type {string}
     * @memberof RefundedItemDto
     */
    'itemId': string;
    /**
     * Product name
     * @type {string}
     * @memberof RefundedItemDto
     */
    'name': string;
    /**
     * The price of a single unit of this item at the time of refund
     * @type {number}
     * @memberof RefundedItemDto
     */
    'unitPrice': number;
    /**
     * Quantity refunded for this item
     * @type {number}
     * @memberof RefundedItemDto
     */
    'quantity': number;
    /**
     * Total amount refunded for this line (quantity * unitPrice)
     * @type {number}
     * @memberof RefundedItemDto
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface RegisterUserResponseDto
 */
export interface RegisterUserResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof RegisterUserResponseDto
     */
    'status': boolean;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserResponseDto
     */
    'message': string;
    /**
     * 
     * @type {UserInfoResponse}
     * @memberof RegisterUserResponseDto
     */
    'userInfo': UserInfoResponse;
}
/**
 * 
 * @export
 * @interface RejectOrderDto
 */
export interface RejectOrderDto {
    /**
     * Unique identifier for the order
     * @type {string}
     * @memberof RejectOrderDto
     */
    'orderId': string;
    /**
     * ID of the business updating the order
     * @type {number}
     * @memberof RejectOrderDto
     */
    'orderingBusinessId': number;
    /**
     * 
     * @type {ProviderEnum}
     * @memberof RejectOrderDto
     */
    'provider': ProviderEnum;
    /**
     * Reason for rejecting the order
     * @type {string}
     * @memberof RejectOrderDto
     */
    'reason': string;
}


/**
 * 
 * @export
 * @interface ReportingCategoryDto
 */
export interface ReportingCategoryDto {
    /**
     * Reporting Category ID
     * @type {number}
     * @memberof ReportingCategoryDto
     */
    'id': number;
    /**
     * Business ID
     * @type {string}
     * @memberof ReportingCategoryDto
     */
    'business_id': string;
    /**
     * Reporting Category Name
     * @type {string}
     * @memberof ReportingCategoryDto
     */
    'reporting_category_name': string;
    /**
     * Index/Order
     * @type {number}
     * @memberof ReportingCategoryDto
     */
    'index': number;
    /**
     * Created at timestamp
     * @type {string}
     * @memberof ReportingCategoryDto
     */
    'created_at': string;
    /**
     * Updated at timestamp
     * @type {string}
     * @memberof ReportingCategoryDto
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface ResetEodDto
 */
export interface ResetEodDto {
    /**
     * The unique binding ID for the business or device
     * @type {string}
     * @memberof ResetEodDto
     */
    'bindingId': string;
}
/**
 * 
 * @export
 * @interface ResolveChoiceDto
 */
export interface ResolveChoiceDto {
    /**
     * The originalPaymentEventId of the payment source chosen by the user.
     * @type {string}
     * @memberof ResolveChoiceDto
     */
    'chosenPaymentEventId': string;
}
/**
 * 
 * @export
 * @interface RewardPointPayload
 */
export interface RewardPointPayload {
    /**
     * The amount of credit to add (positive value) or deduct (negative value). Examples: \"+20\" to add 20 points, \"-20\" to deduct 20 points, \"+100\" for large additions, \"-5\" for small deductions.
     * @type {string}
     * @memberof RewardPointPayload
     */
    'amount': string;
    /**
     * The business ID associated with the reward points
     * @type {number}
     * @memberof RewardPointPayload
     */
    'businessId': number;
}
/**
 * 
 * @export
 * @interface RoleResponseDto
 */
export interface RoleResponseDto {
    /**
     * 
     * @type {string}
     * @memberof RoleResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RoleResponseDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof RoleResponseDto
     */
    'businessId': number;
    /**
     * An array of permission rule objects
     * @type {Array<PermissionRuleDto>}
     * @memberof RoleResponseDto
     */
    'permissionRules': Array<PermissionRuleDto>;
}
/**
 * 
 * @export
 * @interface SalesSummaryDto
 */
export interface SalesSummaryDto {
    /**
     * Total number of orders
     * @type {number}
     * @memberof SalesSummaryDto
     */
    'totalOrders': number;
    /**
     * Total sales amount
     * @type {number}
     * @memberof SalesSummaryDto
     */
    'totalSales': number;
    /**
     * Net sales amount after adjustments
     * @type {number}
     * @memberof SalesSummaryDto
     */
    'netSales': number;
    /**
     * Total amount actually paid
     * @type {number}
     * @memberof SalesSummaryDto
     */
    'totalPaid': number;
    /**
     * Total difference
     * @type {number}
     * @memberof SalesSummaryDto
     */
    'totalDifference': number;
    /**
     * Total transactions
     * @type {number}
     * @memberof SalesSummaryDto
     */
    'totalTransactions': number;
    /**
     * Number of rejected orders
     * @type {number}
     * @memberof SalesSummaryDto
     */
    'rejectedOrders': number;
    /**
     * Total rejected sales amount
     * @type {number}
     * @memberof SalesSummaryDto
     */
    'rejectedSales': number;
    /**
     * Average sales per order
     * @type {number}
     * @memberof SalesSummaryDto
     */
    'averageSales': number;
    /**
     * Total number of items sold
     * @type {number}
     * @memberof SalesSummaryDto
     */
    'totalItemsCount': number;
    /**
     * Total refund amount
     * @type {number}
     * @memberof SalesSummaryDto
     */
    'totalRefunds': number;
    /**
     * Total discount amount given
     * @type {number}
     * @memberof SalesSummaryDto
     */
    'totalDiscounts': number;
    /**
     * Total voucher forfeited amount in cents
     * @type {number}
     * @memberof SalesSummaryDto
     */
    'totalVoucherForfeited': number;
}
/**
 * 
 * @export
 * @interface SalesSummaryDtoV2
 */
export interface SalesSummaryDtoV2 {
    /**
     * Total number of orders
     * @type {number}
     * @memberof SalesSummaryDtoV2
     */
    'totalOrders': number;
    /**
     * Total sales amount
     * @type {number}
     * @memberof SalesSummaryDtoV2
     */
    'totalSales': number;
    /**
     * Net sales amount after adjustments
     * @type {number}
     * @memberof SalesSummaryDtoV2
     */
    'netSales': number;
    /**
     * Total amount actually paid
     * @type {number}
     * @memberof SalesSummaryDtoV2
     */
    'totalPaid': number;
    /**
     * Total difference
     * @type {number}
     * @memberof SalesSummaryDtoV2
     */
    'totalDifference': number;
    /**
     * Total transactions
     * @type {number}
     * @memberof SalesSummaryDtoV2
     */
    'totalTransactions': number;
    /**
     * Number of rejected orders
     * @type {number}
     * @memberof SalesSummaryDtoV2
     */
    'rejectedOrders': number;
    /**
     * Total rejected sales amount
     * @type {number}
     * @memberof SalesSummaryDtoV2
     */
    'rejectedSales': number;
    /**
     * Average sales per order
     * @type {number}
     * @memberof SalesSummaryDtoV2
     */
    'averageSales': number;
    /**
     * Total number of items sold
     * @type {number}
     * @memberof SalesSummaryDtoV2
     */
    'totalItemsCount': number;
    /**
     * Total refund amount
     * @type {number}
     * @memberof SalesSummaryDtoV2
     */
    'totalRefunds': number;
    /**
     * Total discount amount given
     * @type {number}
     * @memberof SalesSummaryDtoV2
     */
    'totalDiscounts': number;
    /**
     * Total voucher forfeited amount in cents
     * @type {number}
     * @memberof SalesSummaryDtoV2
     */
    'totalVoucherForfeited': number;
    /**
     * Total amount of all payment methods
     * @type {number}
     * @memberof SalesSummaryDtoV2
     */
    'totalPaymentAmount': number;
}
/**
 * 
 * @export
 * @interface ScheduleDto
 */
export interface ScheduleDto {
    /**
     * Array of time lapses for a specific day of the week
     * @type {Array<LapseDto>}
     * @memberof ScheduleDto
     */
    'lapses': Array<LapseDto>;
    /**
     * Indicates if this schedule entry is active
     * @type {boolean}
     * @memberof ScheduleDto
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface SearchUserInfoResponseDto
 */
export interface SearchUserInfoResponseDto {
    /**
     * 
     * @type {{ [key: string]: LoyaltyInfoResponseDtoLinksValue; }}
     * @memberof SearchUserInfoResponseDto
     */
    '_links': { [key: string]: LoyaltyInfoResponseDtoLinksValue; };
    /**
     * 
     * @type {Array<UserWithLoyaltyDto>}
     * @memberof SearchUserInfoResponseDto
     */
    'data': Array<UserWithLoyaltyDto>;
}
/**
 * 
 * @export
 * @interface SendPosOrderTicketDto
 */
export interface SendPosOrderTicketDto {
    /**
     * 
     * @type {SendPosOrderTicketDtoData}
     * @memberof SendPosOrderTicketDto
     */
    'data': SendPosOrderTicketDtoData;
    /**
     * Business ID
     * @type {string}
     * @memberof SendPosOrderTicketDto
     */
    'businessId': string;
    /**
     * Send notification to the business
     * @type {boolean}
     * @memberof SendPosOrderTicketDto
     */
    'sendNotification'?: boolean;
}
/**
 * Order data
 * @export
 * @interface SendPosOrderTicketDtoData
 */
export interface SendPosOrderTicketDtoData {
    /**
     * 
     * @type {string}
     * @memberof SendPosOrderTicketDtoData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SendPosOrderTicketDtoData
     */
    'businessId': string;
    /**
     * 
     * @type {CurrencyCode}
     * @memberof SendPosOrderTicketDtoData
     */
    'currency': CurrencyCode;
    /**
     * 
     * @type {PosBusinessDto}
     * @memberof SendPosOrderTicketDtoData
     */
    'business': PosBusinessDto;
    /**
     * 
     * @type {string}
     * @memberof SendPosOrderTicketDtoData
     */
    'createdAt': string;
    /**
     * 
     * @type {OrderStatusEnum}
     * @memberof SendPosOrderTicketDtoData
     */
    'status': OrderStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SendPosOrderTicketDtoData
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof SendPosOrderTicketDtoData
     */
    'orderNumber': string;
    /**
     * 
     * @type {OrderTypePOS}
     * @memberof SendPosOrderTicketDtoData
     */
    'orderType': OrderTypePOS;
    /**
     * 
     * @type {string}
     * @memberof SendPosOrderTicketDtoData
     */
    'spotNumber': string | null;
    /**
     * 
     * @type {string}
     * @memberof SendPosOrderTicketDtoData
     */
    'comments': string | null;
    /**
     * Id of the staff in shift
     * @type {string}
     * @memberof SendPosOrderTicketDtoData
     */
    'staffId': string | null;
    /**
     * Id of the shift
     * @type {string}
     * @memberof SendPosOrderTicketDtoData
     */
    'shiftId': string | null;
    /**
     * 
     * @type {OrderRefundStatus}
     * @memberof SendPosOrderTicketDtoData
     */
    'orderRefundStatus': OrderRefundStatus;
    /**
     * 
     * @type {LocatorType}
     * @memberof SendPosOrderTicketDtoData
     */
    'locatorType': LocatorType;
    /**
     * 
     * @type {PosOrderPriceDto}
     * @memberof SendPosOrderTicketDtoData
     */
    'basketPrice': PosOrderPriceDto;
    /**
     * 
     * @type {Array<PosOrderItemDto>}
     * @memberof SendPosOrderTicketDtoData
     */
    'items': Array<PosOrderItemDto>;
    /**
     * 
     * @type {Array<PosDiscountDto>}
     * @memberof SendPosOrderTicketDtoData
     */
    'discounts': Array<PosDiscountDto>;
    /**
     * 
     * @type {PosCustomerDto}
     * @memberof SendPosOrderTicketDtoData
     */
    'customer': PosCustomerDto | null;
    /**
     * 
     * @type {Array<TransactionDto>}
     * @memberof SendPosOrderTicketDtoData
     */
    'paymentEvents': Array<TransactionDto>;
    /**
     * 
     * @type {Array<PaymentRefundDto>}
     * @memberof SendPosOrderTicketDtoData
     */
    'refunds'?: Array<PaymentRefundDto>;
    /**
     * Data version code
     * @type {string}
     * @memberof SendPosOrderTicketDtoData
     */
    'version': string;
    /**
     * 
     * @type {OrderFormat}
     * @memberof SendPosOrderTicketDtoData
     */
    'orderFormat'?: OrderFormat;
    /**
     * The ID of the loyalty program active during this order.
     * @type {string}
     * @memberof SendPosOrderTicketDtoData
     */
    'loyaltyProgramId': string | null;
    /**
     * An array of loyalty transaction IDs related to this order.
     * @type {Array<string>}
     * @memberof SendPosOrderTicketDtoData
     */
    'loyaltyTransactionIds': Array<string>;
    /**
     * 
     * @type {PosOrderDtoTaxSummary}
     * @memberof SendPosOrderTicketDtoData
     */
    'taxSummary'?: PosOrderDtoTaxSummary;
    /**
     * Name of staff member who created the order
     * @type {string}
     * @memberof SendPosOrderTicketDtoData
     */
    'staffName'?: string | null;
    /**
     * 
     * @type {PosOrderDtoInvoiceCompany}
     * @memberof SendPosOrderTicketDtoData
     */
    'invoiceCompany'?: PosOrderDtoInvoiceCompany | null;
    /**
     * 
     * @type {object}
     * @memberof SendPosOrderTicketDtoData
     */
    'lastPaymentError'?: object;
}


/**
 * 
 * @export
 * @interface SendReportEmailDto
 */
export interface SendReportEmailDto {
    /**
     * Optional custom subject
     * @type {string}
     * @memberof SendReportEmailDto
     */
    'subject'?: string;
    /**
     * Additional message for email body
     * @type {string}
     * @memberof SendReportEmailDto
     */
    'message'?: string;
    /**
     * Email address to send the report to
     * @type {string}
     * @memberof SendReportEmailDto
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ServiceType = {
    Table: 'table',
    Counter: 'counter'
} as const;

export type ServiceType = typeof ServiceType[keyof typeof ServiceType];


/**
 * 
 * @export
 * @interface ShareOrderingBusinessIdPayload
 */
export interface ShareOrderingBusinessIdPayload {
    /**
     * The ordering business ID for this transaction.
     * @type {number}
     * @memberof ShareOrderingBusinessIdPayload
     */
    'orderingBusinessId': number;
}
/**
 * 
 * @export
 * @interface ShiftEmployeeDto
 */
export interface ShiftEmployeeDto {
    /**
     * 
     * @type {string}
     * @memberof ShiftEmployeeDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ShiftEmployeeDto
     */
    'name': string;
    /**
     * 
     * @type {Status}
     * @memberof ShiftEmployeeDto
     */
    'status': Status;
    /**
     * 
     * @type {string}
     * @memberof ShiftEmployeeDto
     */
    'photoUrl': string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SimplePaymentStatus = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type SimplePaymentStatus = typeof SimplePaymentStatus[keyof typeof SimplePaymentStatus];


/**
 * 
 * @export
 * @interface SingleProviderStatusResponseDto
 */
export interface SingleProviderStatusResponseDto {
    /**
     * 
     * @type {SingleProviderStatusResponseDtoActiveChannel}
     * @memberof SingleProviderStatusResponseDto
     */
    'activeChannel': SingleProviderStatusResponseDtoActiveChannel | null;
}
/**
 * Active channel status
 * @export
 * @interface SingleProviderStatusResponseDtoActiveChannel
 */
export interface SingleProviderStatusResponseDtoActiveChannel {
    /**
     * 
     * @type {ProviderEnum}
     * @memberof SingleProviderStatusResponseDtoActiveChannel
     */
    'provider': ProviderEnum;
    /**
     * Provider open status
     * @type {boolean}
     * @memberof SingleProviderStatusResponseDtoActiveChannel
     */
    'open': boolean;
}


/**
 * 
 * @export
 * @interface SplitPartDto
 */
export interface SplitPartDto {
    /**
     * Split part ID
     * @type {string}
     * @memberof SplitPartDto
     */
    'id': string;
    /**
     * Split amount
     * @type {number}
     * @memberof SplitPartDto
     */
    'amount': number;
    /**
     * 
     * @type {SplitPartStatus}
     * @memberof SplitPartDto
     */
    'status': SplitPartStatus;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SplitPartStatus = {
    Paid: 'paid',
    Unpaid: 'unpaid'
} as const;

export type SplitPartStatus = typeof SplitPartStatus[keyof typeof SplitPartStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const StaffActivityActionType = {
    OrderCreated: 'ORDER_CREATED',
    OrderUpdated: 'ORDER_UPDATED',
    ItemAdded: 'ITEM_ADDED',
    ItemRemoved: 'ITEM_REMOVED',
    ItemUpdated: 'ITEM_UPDATED',
    DiscountApplied: 'DISCOUNT_APPLIED',
    DiscountRemoved: 'DISCOUNT_REMOVED',
    RefundInitiated: 'REFUND_INITIATED',
    RefundProcessed: 'REFUND_PROCESSED',
    RefundCanceled: 'REFUND_CANCELED',
    PaymentProcessed: 'PAYMENT_PROCESSED',
    OrderStatusUpdated: 'ORDER_STATUS_UPDATED',
    InventoryUpdated: 'INVENTORY_UPDATED',
    CashSessionOpened: 'CASH_SESSION_OPENED',
    CashSessionClosed: 'CASH_SESSION_CLOSED',
    CashManualAdd: 'CASH_MANUAL_ADD',
    CashManualRemove: 'CASH_MANUAL_REMOVE'
} as const;

export type StaffActivityActionType = typeof StaffActivityActionType[keyof typeof StaffActivityActionType];


/**
 * 
 * @export
 * @interface StaffActivityChangeDto
 */
export interface StaffActivityChangeDto {
    /**
     * The name of the attribute that changed
     * @type {string}
     * @memberof StaffActivityChangeDto
     */
    'attribute': string;
    /**
     * The previous value of the attribute
     * @type {object}
     * @memberof StaffActivityChangeDto
     */
    'oldValue'?: object | null;
    /**
     * The new value of the attribute
     * @type {object}
     * @memberof StaffActivityChangeDto
     */
    'newValue'?: object | null;
}
/**
 * 
 * @export
 * @interface StaffActivityLogDto
 */
export interface StaffActivityLogDto {
    /**
     * Unique ID of the log entry
     * @type {string}
     * @memberof StaffActivityLogDto
     */
    'id': string;
    /**
     * The ISO 8601 timestamp of when the action occurred
     * @type {string}
     * @memberof StaffActivityLogDto
     */
    'timestamp': string;
    /**
     * The ID of the business this log belongs to
     * @type {string}
     * @memberof StaffActivityLogDto
     */
    'businessId': string;
    /**
     * The ID of the order this log belongs to
     * @type {string}
     * @memberof StaffActivityLogDto
     */
    'orderId': string | null;
    /**
     * The ID of the staff member who performed the action
     * @type {string}
     * @memberof StaffActivityLogDto
     */
    'staffId': string | null;
    /**
     * The ID of the shift during which the action occurred
     * @type {string}
     * @memberof StaffActivityLogDto
     */
    'shiftId': string | null;
    /**
     * 
     * @type {StaffActivityActionType}
     * @memberof StaffActivityLogDto
     */
    'actionType': StaffActivityActionType;
    /**
     * The type of entity that was affected
     * @type {string}
     * @memberof StaffActivityLogDto
     */
    'entityType': string;
    /**
     * The ID of the entity that was affected
     * @type {string}
     * @memberof StaffActivityLogDto
     */
    'entityId': string;
    /**
     * A list of changes that occurred during this action
     * @type {Array<StaffActivityChangeDto>}
     * @memberof StaffActivityLogDto
     */
    'changes': Array<StaffActivityChangeDto>;
    /**
     * The expiration date of the log entry, if applicable
     * @type {string}
     * @memberof StaffActivityLogDto
     */
    'expiresAt'?: string | null;
    /**
     * Name of the product associated with the activity log
     * @type {string}
     * @memberof StaffActivityLogDto
     */
    'productName'?: string | null;
}


/**
 * 
 * @export
 * @interface StationDetailsDto
 */
export interface StationDetailsDto {
    /**
     * 
     * @type {string}
     * @memberof StationDetailsDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StationDetailsDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StationDetailsDto
     */
    'hardwareId': string;
    /**
     * 
     * @type {StationType}
     * @memberof StationDetailsDto
     */
    'type': StationType;
    /**
     * 
     * @type {Status}
     * @memberof StationDetailsDto
     */
    'status': Status;
    /**
     * 
     * @type {number}
     * @memberof StationDetailsDto
     */
    'orderingBusinessId': number;
    /**
     * 
     * @type {string}
     * @memberof StationDetailsDto
     */
    'prefix': string;
    /**
     * 
     * @type {object}
     * @memberof StationDetailsDto
     */
    'metadata'?: object;
    /**
     * Timestamp when the station record was created.
     * @type {string}
     * @memberof StationDetailsDto
     */
    'createdAt': string;
    /**
     * Timestamp when the station record was last updated.
     * @type {string}
     * @memberof StationDetailsDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {StationDetailsDtoPaymentTerminal}
     * @memberof StationDetailsDto
     */
    'paymentTerminal'?: StationDetailsDtoPaymentTerminal | null;
}


/**
 * The payment terminal connected to this station, or null if unassigned.
 * @export
 * @interface StationDetailsDtoPaymentTerminal
 */
export interface StationDetailsDtoPaymentTerminal {
    /**
     * The unique ID of the Payment Terminal.
     * @type {string}
     * @memberof StationDetailsDtoPaymentTerminal
     */
    'id': string;
    /**
     * The unique ID of the Payment Terminal.
     * @type {string}
     * @memberof StationDetailsDtoPaymentTerminal
     */
    'hardwareId': string;
    /**
     * The unique ID of the Payment Terminal.
     * @type {string}
     * @memberof StationDetailsDtoPaymentTerminal
     */
    'label': string | null;
    /**
     * The unique ID of the Payment Terminal.
     * @type {string}
     * @memberof StationDetailsDtoPaymentTerminal
     */
    'orderingBusinessId': string;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof StationDetailsDtoPaymentTerminal
     */
    'provider': PaymentProvider;
    /**
     * Timestamp when the payment terminal record was last updated.
     * @type {string}
     * @memberof StationDetailsDtoPaymentTerminal
     */
    'updatedAt': string;
}


/**
 * 
 * @export
 * @interface StationSyncResponseDto
 */
export interface StationSyncResponseDto {
    /**
     * A success message indicating the sync was successful
     * @type {string}
     * @memberof StationSyncResponseDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StationType = {
    Kiosk: 'KIOSK',
    Pos: 'POS'
} as const;

export type StationType = typeof StationType[keyof typeof StationType];


/**
 * 
 * @export
 * @enum {string}
 */

export const Status = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type Status = typeof Status[keyof typeof Status];


/**
 * 
 * @export
 * @interface StripeConnectionTokenDto
 */
export interface StripeConnectionTokenDto {
    /**
     * String representing the object\'s type
     * @type {string}
     * @memberof StripeConnectionTokenDto
     */
    'object': string;
    /**
     * The id of the location that this connection token is scoped to
     * @type {string}
     * @memberof StripeConnectionTokenDto
     */
    'location'?: string;
    /**
     * Your application should pass this token to the Stripe Terminal SDK
     * @type {string}
     * @memberof StripeConnectionTokenDto
     */
    'secret': string;
}
/**
 * 
 * @export
 * @interface StripePaymentIntentDto
 */
export interface StripePaymentIntentDto {
    /**
     * Unique identifier for the payment intent
     * @type {string}
     * @memberof StripePaymentIntentDto
     */
    'id': string;
    /**
     * Object type, always \"payment_intent\"
     * @type {string}
     * @memberof StripePaymentIntentDto
     */
    'object': string;
    /**
     * Amount intended to be collected (in smallest currency unit)
     * @type {number}
     * @memberof StripePaymentIntentDto
     */
    'amount': number;
    /**
     * Amount that can be captured from this payment intent
     * @type {number}
     * @memberof StripePaymentIntentDto
     */
    'amount_capturable': number;
    /**
     * Amount that has been received from this payment intent
     * @type {number}
     * @memberof StripePaymentIntentDto
     */
    'amount_received': number;
    /**
     * The currency of the payment intent
     * @type {string}
     * @memberof StripePaymentIntentDto
     */
    'currency': string;
    /**
     * Customer ID this payment intent belongs to, if any
     * @type {object}
     * @memberof StripePaymentIntentDto
     */
    'customer'?: object | null;
    /**
     * Status of the payment intent
     * @type {string}
     * @memberof StripePaymentIntentDto
     */
    'status': StatusEnum;
    /**
     * ID of the payment method used in this payment intent
     * @type {object}
     * @memberof StripePaymentIntentDto
     */
    'payment_method'?: object | null;
    /**
     * Time at which the object was created
     * @type {number}
     * @memberof StripePaymentIntentDto
     */
    'created': number;
    /**
     * Has the value true if the object exists in live mode or false if the object exists in test mode
     * @type {boolean}
     * @memberof StripePaymentIntentDto
     */
    'livemode': boolean;
    /**
     * Shipping information
     * @type {object}
     * @memberof StripePaymentIntentDto
     */
    'shipping'?: object | null;
    /**
     * Set of key-value pairs attached to the object
     * @type {object}
     * @memberof StripePaymentIntentDto
     */
    'metadata'?: object;
}

export const StatusEnum = {
    RequiresPaymentMethod: 'requires_payment_method',
    RequiresConfirmation: 'requires_confirmation',
    RequiresAction: 'requires_action',
    Processing: 'processing',
    RequiresCapture: 'requires_capture',
    Canceled: 'canceled',
    Succeeded: 'succeeded'
} as const;

export type StatusEnum = typeof StatusEnum[keyof typeof StatusEnum];

/**
 * 
 * @export
 * @interface SubOptionDto
 */
export interface SubOptionDto {
    /**
     * SubOption ID
     * @type {string}
     * @memberof SubOptionDto
     */
    'id': string;
    /**
     * SubOption external ID
     * @type {string}
     * @memberof SubOptionDto
     */
    'externalId': string;
    /**
     * SubOption name
     * @type {string}
     * @memberof SubOptionDto
     */
    'name': string;
    /**
     * Quantity of suboption
     * @type {number}
     * @memberof SubOptionDto
     */
    'quantity': number;
    /**
     * Paid price of suboption
     * @type {number}
     * @memberof SubOptionDto
     */
    'paidPrice': number;
    /**
     * Unit price of suboption
     * @type {number}
     * @memberof SubOptionDto
     */
    'unitPrice': number;
}
/**
 * 
 * @export
 * @interface SubcategoryDto
 */
export interface SubcategoryDto {
    /**
     * Subcategory ID
     * @type {number}
     * @memberof SubcategoryDto
     */
    'id': number;
    /**
     * Subcategory name
     * @type {string}
     * @memberof SubcategoryDto
     */
    'name': string;
    /**
     * Subcategory image URL
     * @type {string}
     * @memberof SubcategoryDto
     */
    'image': string | null;
    /**
     * Display rank
     * @type {number}
     * @memberof SubcategoryDto
     */
    'rank': number;
    /**
     * Whether the subcategory is enabled
     * @type {boolean}
     * @memberof SubcategoryDto
     */
    'enabled': boolean;
    /**
     * ID of the parent category
     * @type {number}
     * @memberof SubcategoryDto
     */
    'parent_category_id': number;
    /**
     * Subcategory slug
     * @type {string}
     * @memberof SubcategoryDto
     */
    'slug': string | null;
    /**
     * Subcategory description
     * @type {string}
     * @memberof SubcategoryDto
     */
    'header': string | null;
    /**
     * Subcategory description
     * @type {string}
     * @memberof SubcategoryDto
     */
    'description': string | null;
    /**
     * Products in this subcategory
     * @type {Array<OrderingCoProductDto>}
     * @memberof SubcategoryDto
     */
    'products': Array<OrderingCoProductDto>;
}
/**
 * 
 * @export
 * @interface SuboptionPriceBreakdownDto
 */
export interface SuboptionPriceBreakdownDto {
    /**
     * 
     * @type {MoneyDto}
     * @memberof SuboptionPriceBreakdownDto
     */
    'totalBeforeDiscounts': MoneyDto;
    /**
     * 
     * @type {MoneyDto}
     * @memberof SuboptionPriceBreakdownDto
     */
    'totalDiscounts': MoneyDto;
    /**
     * 
     * @type {MoneyDto}
     * @memberof SuboptionPriceBreakdownDto
     */
    'subtotalBasketDiscounts': MoneyDto;
    /**
     * 
     * @type {MoneyDto}
     * @memberof SuboptionPriceBreakdownDto
     */
    'subtotalItemDiscounts': MoneyDto;
}
/**
 * 
 * @export
 * @interface SupportedChannelDto
 */
export interface SupportedChannelDto {
    /**
     * 
     * @type {ProviderEnum}
     * @memberof SupportedChannelDto
     */
    'channel': ProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof SupportedChannelDto
     */
    'label': string;
}


/**
 * 
 * @export
 * @interface SyncStationDto
 */
export interface SyncStationDto {
    /**
     * Unique hardware ID of the station device
     * @type {string}
     * @memberof SyncStationDto
     */
    'hardwareId': string;
    /**
     * Ordering business ID
     * @type {number}
     * @memberof SyncStationDto
     */
    'businessId': number;
    /**
     * Display name for the station
     * @type {string}
     * @memberof SyncStationDto
     */
    'name'?: string;
    /**
     * Prefix for station when creating orders
     * @type {string}
     * @memberof SyncStationDto
     */
    'prefix': string;
    /**
     * 
     * @type {StationType}
     * @memberof SyncStationDto
     */
    'type'?: StationType;
    /**
     * Payment terminal ID associated with this station
     * @type {string}
     * @memberof SyncStationDto
     */
    'paymentTerminalId'?: string;
    /**
     * Additional settings for the station in JSON format
     * @type {object}
     * @memberof SyncStationDto
     */
    'settings'?: object;
    /**
     * Metadata information about the station device in JSON format
     * @type {object}
     * @memberof SyncStationDto
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @interface SyncTerminalDto
 */
export interface SyncTerminalDto {
    /**
     * Hardware ID of the station to connect the terminal to
     * @type {string}
     * @memberof SyncTerminalDto
     */
    'stationHardwareId': string;
    /**
     * Hardware ID of the payment terminal
     * @type {string}
     * @memberof SyncTerminalDto
     */
    'terminalId': string;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof SyncTerminalDto
     */
    'provider': PaymentProvider;
    /**
     * Label/name for the terminal
     * @type {string}
     * @memberof SyncTerminalDto
     */
    'label'?: string;
    /**
     * 
     * @type {TerminalConnectionType}
     * @memberof SyncTerminalDto
     */
    'connectionType'?: TerminalConnectionType;
    /**
     * Business ID that owns the terminal
     * @type {number}
     * @memberof SyncTerminalDto
     */
    'businessId': number;
}


/**
 * 
 * @export
 * @interface TaxBreakdownDto
 */
export interface TaxBreakdownDto {
    /**
     * Standard tax amount
     * @type {number}
     * @memberof TaxBreakdownDto
     */
    'standardTaxAmount': number;
    /**
     * Premium tax amount
     * @type {number}
     * @memberof TaxBreakdownDto
     */
    'premiumTaxAmount': number;
    /**
     * Total tax amount
     * @type {number}
     * @memberof TaxBreakdownDto
     */
    'totalTaxAmount': number;
    /**
     * Standard tax rate %
     * @type {number}
     * @memberof TaxBreakdownDto
     */
    'standardTaxRate': number;
    /**
     * Premium tax rate %
     * @type {number}
     * @memberof TaxBreakdownDto
     */
    'premiumTaxRate': number;
}
/**
 * 
 * @export
 * @interface TaxBreakdownDtoV3
 */
export interface TaxBreakdownDtoV3 {
    /**
     * Tax breakdown by rate
     * @type {Array<TaxRateItem>}
     * @memberof TaxBreakdownDtoV3
     */
    'taxRates': Array<TaxRateItem>;
    /**
     * Total tax amount
     * @type {number}
     * @memberof TaxBreakdownDtoV3
     */
    'totalTaxAmount': number;
}
/**
 * 
 * @export
 * @interface TaxDetailsDto
 */
export interface TaxDetailsDto {
    /**
     * Array of alcohol items
     * @type {Array<PosItemDto>}
     * @memberof TaxDetailsDto
     */
    'alcoholItems': Array<PosItemDto>;
    /**
     * Total amount for alcohol items without tax
     * @type {number}
     * @memberof TaxDetailsDto
     */
    'alcoholTotalWithoutTax': number;
    /**
     * Total amount for non-alcohol items
     * @type {number}
     * @memberof TaxDetailsDto
     */
    'totalWithouAlcohol': number;
    /**
     * Tax amount for alcohol items
     * @type {number}
     * @memberof TaxDetailsDto
     */
    'alcoholTaxAmount': number;
    /**
     * Total tax amount
     * @type {number}
     * @memberof TaxDetailsDto
     */
    'taxAmount': number;
    /**
     * Total amount for alcohol items including tax
     * @type {number}
     * @memberof TaxDetailsDto
     */
    'alcoholTotal': number;
    /**
     * Total amount without tax
     * @type {number}
     * @memberof TaxDetailsDto
     */
    'totalWithoutTax': number;
    /**
     * 
     * @type {TaxDetailsDtoSelectedTax}
     * @memberof TaxDetailsDto
     */
    'selectedTax': TaxDetailsDtoSelectedTax;
    /**
     * 
     * @type {TaxDetailsDtoSelectedTax}
     * @memberof TaxDetailsDto
     */
    'alcoholTax'?: TaxDetailsDtoSelectedTax;
}
/**
 * Tax information for this item
 * @export
 * @interface TaxDetailsDtoSelectedTax
 */
export interface TaxDetailsDtoSelectedTax {
    /**
     * 
     * @type {number}
     * @memberof TaxDetailsDtoSelectedTax
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TaxDetailsDtoSelectedTax
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TaxDetailsDtoSelectedTax
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof TaxDetailsDtoSelectedTax
     */
    'rate': number;
    /**
     * 
     * @type {number}
     * @memberof TaxDetailsDtoSelectedTax
     */
    'type': number;
}
/**
 * 
 * @export
 * @interface TaxRateItem
 */
export interface TaxRateItem {
    /**
     * Tax rate percentage
     * @type {number}
     * @memberof TaxRateItem
     */
    'rate': number;
    /**
     * Tax amount for this rate
     * @type {number}
     * @memberof TaxRateItem
     */
    'amount': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TerminalConnectionType = {
    Network: 'NETWORK'
} as const;

export type TerminalConnectionType = typeof TerminalConnectionType[keyof typeof TerminalConnectionType];


/**
 * 
 * @export
 * @interface TerminalDetailsDto
 */
export interface TerminalDetailsDto {
    /**
     * The unique ID of the payment terminal.
     * @type {string}
     * @memberof TerminalDetailsDto
     */
    'id': string;
    /**
     * The hardware ID provided by the payment service provider.
     * @type {string}
     * @memberof TerminalDetailsDto
     */
    'hardwareId': string;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof TerminalDetailsDto
     */
    'provider': PaymentProvider;
    /**
     * An optional human-readable label for the terminal.
     * @type {string}
     * @memberof TerminalDetailsDto
     */
    'label': string | null;
    /**
     * The business ID the terminal is registered to.
     * @type {number}
     * @memberof TerminalDetailsDto
     */
    'orderingBusinessId': number;
    /**
     * Timestamp when the terminal record was created.
     * @type {string}
     * @memberof TerminalDetailsDto
     */
    'createdAt': string;
    /**
     * Timestamp when the terminal record was last updated.
     * @type {string}
     * @memberof TerminalDetailsDto
     */
    'updatedAt': string;
}


/**
 * 
 * @export
 * @interface TerminalValidationResponseDto
 */
export interface TerminalValidationResponseDto {
    /**
     * Is valid terminal id or not for the current user session
     * @type {boolean}
     * @memberof TerminalValidationResponseDto
     */
    'isValid': boolean;
}
/**
 * 
 * @export
 * @interface ThemeTokensDto
 */
export interface ThemeTokensDto {
    /**
     * 
     * @type {string}
     * @memberof ThemeTokensDto
     */
    'munchi-primary': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTokensDto
     */
    'munchi-text-muted': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTokensDto
     */
    'munchi-green': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTokensDto
     */
    'munchi-yellow': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTokensDto
     */
    'munchi-red': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTokensDto
     */
    'munchi-purple': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTokensDto
     */
    'munchi-orange': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTokensDto
     */
    'munchi-blue': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTokensDto
     */
    'munchi-gray': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTokensDto
     */
    'munchi-tag-primary': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTokensDto
     */
    'munchi-bg-primary': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTokensDto
     */
    'munchi-bg-gray-component': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTokensDto
     */
    'munchi-bg-transparent-black': string;
    /**
     * 
     * @type {string}
     * @memberof ThemeTokensDto
     */
    'munchi-card': string;
}
/**
 * 
 * @export
 * @interface TimeDto
 */
export interface TimeDto {
    /**
     * Hour component of the time (0-23)
     * @type {number}
     * @memberof TimeDto
     */
    'hour': number;
    /**
     * Minute component of the time (0-59)
     * @type {number}
     * @memberof TimeDto
     */
    'minute': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TimeSpan = {
    Custom: 'CUSTOM',
    Day: 'DAY',
    Week: 'WEEK',
    Month: 'MONTH',
    Year: 'YEAR'
} as const;

export type TimeSpan = typeof TimeSpan[keyof typeof TimeSpan];


/**
 * 
 * @export
 * @interface TodayShiftResponseDto
 */
export interface TodayShiftResponseDto {
    /**
     * 
     * @type {TodayShiftResponseDtoActiveShift}
     * @memberof TodayShiftResponseDto
     */
    'activeShift': TodayShiftResponseDtoActiveShift | null;
}
/**
 * The currently open shift for the employee, or null if none.
 * @export
 * @interface TodayShiftResponseDtoActiveShift
 */
export interface TodayShiftResponseDtoActiveShift {
    /**
     * 
     * @type {string}
     * @memberof TodayShiftResponseDtoActiveShift
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TodayShiftResponseDtoActiveShift
     */
    'employeeId': string;
    /**
     * The orderingBusinessId.
     * @type {number}
     * @memberof TodayShiftResponseDtoActiveShift
     */
    'businessId': number;
    /**
     * 
     * @type {string}
     * @memberof TodayShiftResponseDtoActiveShift
     */
    'clockInTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof TodayShiftResponseDtoActiveShift
     */
    'clockOutTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof TodayShiftResponseDtoActiveShift
     */
    'activeSessionId': string;
    /**
     * 
     * @type {EmployeeShiftResponseDtoEmployee}
     * @memberof TodayShiftResponseDtoActiveShift
     */
    'employee': EmployeeShiftResponseDtoEmployee;
}
/**
 * 
 * @export
 * @interface TransactionDto
 */
export interface TransactionDto {
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    'referenceId': string | null;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof TransactionDto
     */
    'provider': PaymentProvider;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof TransactionDto
     */
    'type': PaymentMethod;
    /**
     * Amount paid in cents
     * @type {number}
     * @memberof TransactionDto
     */
    'amount': number;
    /**
     * Difference from cash rounding in cents
     * @type {number}
     * @memberof TransactionDto
     */
    'roundingDifference': number;
    /**
     * Raw data from payment provider
     * @type {object}
     * @memberof TransactionDto
     */
    'rawData': object;
    /**
     * 
     * @type {string}
     * @memberof TransactionDto
     */
    'createdAt': string;
    /**
     * 
     * @type {TransactionDtoCardDetail}
     * @memberof TransactionDto
     */
    'cardDetail': TransactionDtoCardDetail | null;
    /**
     * The monetary amount of the voucher value that was *not* used and *not* refunded to the customer (i.e., the overage). This is applicable only when a voucher is used and its value exceeds the order total.
     * @type {number}
     * @memberof TransactionDto
     */
    'voucherForfeitedAmount'?: number | null;
    /**
     * The specific line items this transaction paid for. If null or empty, it was a pooled payment against the total bill.
     * @type {Array<string>}
     * @memberof TransactionDto
     */
    'lineItemIds'?: Array<string> | null;
    /**
     * The specific split part this transaction paid for. If null, it was not a payment for a split part.
     * @type {string}
     * @memberof TransactionDto
     */
    'splitPartId'?: string | null;
    /**
     * Indicates whether this transaction was processed as a pre-authorization.
     * @type {string}
     * @memberof TransactionDto
     */
    'label': string | null;
}


/**
 * Details about the cart, optional
 * @export
 * @interface TransactionDtoCardDetail
 */
export interface TransactionDtoCardDetail {
    /**
     * 
     * @type {string}
     * @memberof TransactionDtoCardDetail
     */
    'cardType': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDtoCardDetail
     */
    'cardNumber': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDtoCardDetail
     */
    'aid': string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionDtoCardDetail
     */
    'orderCode': string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionDtoCardDetail
     */
    'transactionId': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDtoCardDetail
     */
    'timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDtoCardDetail
     */
    'applicationLabel': string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionDtoCardDetail
     */
    'issuer': string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TransactionEventType = {
    Earn: 'earn',
    Redeem: 'redeem',
    Collect: 'collect',
    Credit: 'credit',
    Debit: 'debit',
    Claimed: 'claimed'
} as const;

export type TransactionEventType = typeof TransactionEventType[keyof typeof TransactionEventType];


/**
 * 
 * @export
 * @enum {string}
 */

export const TransactionType = {
    Purchase: 'purchase',
    PurchaseWithCashback: 'purchaseWithCashback',
    Reversal: 'reversal',
    ReturnOfGoods: 'returnOfGoods',
    Bonus: 'bonus',
    Authorization: 'authorization',
    PreAuthorizationIncremental: 'preAuthorizationIncremental',
    PreAuthorizationReversal: 'preAuthorizationReversal',
    PreAuthorizationSaleCompletion: 'preAuthorizationSaleCompletion',
    Deposit: 'deposit',
    BalanceInquiry: 'balanceInquiry'
} as const;

export type TransactionType = typeof TransactionType[keyof typeof TransactionType];


/**
 * 
 * @export
 * @enum {string}
 */

export const Type = {
    Instant: 'instant',
    Preorder: 'preorder'
} as const;

export type Type = typeof Type[keyof typeof Type];


/**
 * 
 * @export
 * @interface UnifiedDiscountsResponseDto
 */
export interface UnifiedDiscountsResponseDto {
    /**
     * Venue-level discounts
     * @type {Array<BusinessDiscountDto>}
     * @memberof UnifiedDiscountsResponseDto
     */
    'venue': Array<BusinessDiscountDto>;
    /**
     * Global (owner-level) discounts applicable to this venue
     * @type {Array<BusinessDiscountDto>}
     * @memberof UnifiedDiscountsResponseDto
     */
    'global': Array<BusinessDiscountDto>;
}
/**
 * 
 * @export
 * @interface UnlockTerminalDto
 */
export interface UnlockTerminalDto {
    /**
     * The ID of the employee unlocking the terminal.
     * @type {string}
     * @memberof UnlockTerminalDto
     */
    'employeeId': string;
}
/**
 * 
 * @export
 * @interface UpdateChannelInventoryDto
 */
export interface UpdateChannelInventoryDto {
    /**
     * Array of channel inventory updates
     * @type {Array<ChannelInventoryUpdateDto>}
     * @memberof UpdateChannelInventoryDto
     */
    'channels': Array<ChannelInventoryUpdateDto>;
}
/**
 * 
 * @export
 * @interface UpdateInvoiceCompanyDto
 */
export interface UpdateInvoiceCompanyDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateInvoiceCompanyDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateInvoiceCompanyDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateInvoiceCompanyDto
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateInvoiceCompanyDto
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateInvoiceCompanyDto
     */
    'bic'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateInvoiceCompanyDto
     */
    'address'?: string;
}
/**
 * 
 * @export
 * @interface UpdatePermissionDto
 */
export interface UpdatePermissionDto {
    /**
     * Whether the permission is enabled
     * @type {boolean}
     * @memberof UpdatePermissionDto
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface UpdatePosInventoryDto
 */
export interface UpdatePosInventoryDto {
    /**
     * Enable POS inventory tracking
     * @type {boolean}
     * @memberof UpdatePosInventoryDto
     */
    'pos_inventoried': boolean;
    /**
     * Current POS inventory quantity
     * @type {number}
     * @memberof UpdatePosInventoryDto
     */
    'pos_quantity': number;
}
/**
 * 
 * @export
 * @interface UpdateStatusResponseDto
 */
export interface UpdateStatusResponseDto {
    /**
     * Future time when the status will change back
     * @type {string}
     * @memberof UpdateStatusResponseDto
     */
    'futureTime'?: string | null;
    /**
     * 
     * @type {ProviderEnum}
     * @memberof UpdateStatusResponseDto
     */
    'provider': ProviderEnum;
    /**
     * Business ID for which the status was updated
     * @type {number}
     * @memberof UpdateStatusResponseDto
     */
    'businessId': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const UpsellMode = {
    AfterAddProduct: 'AfterAddProduct',
    BeforeCheckout: 'BeforeCheckout',
    Disabled: 'Disabled'
} as const;

export type UpsellMode = typeof UpsellMode[keyof typeof UpsellMode];


/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * Name of the user
     * @type {string}
     * @memberof UserDto
     */
    'name'?: string;
    /**
     * Email address of the user
     * @type {string}
     * @memberof UserDto
     */
    'email': string;
    /**
     * Cellphone number of the user
     * @type {string}
     * @memberof UserDto
     */
    'cellphone': string;
    /**
     * Country phone code
     * @type {string}
     * @memberof UserDto
     */
    'countryPhoneCode': string;
    /**
     * Password for the user account
     * @type {string}
     * @memberof UserDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * Unique identifier of the user
     * @type {number}
     * @memberof UserInfo
     */
    'id': number;
    /**
     * Full name of the user
     * @type {string}
     * @memberof UserInfo
     */
    'name': string;
    /**
     * Email address of the user
     * @type {string}
     * @memberof UserInfo
     */
    'email': string;
    /**
     * Users cellphone number
     * @type {string}
     * @memberof UserInfo
     */
    'cellphone': string;
    /**
     * Country dialing code for the phone number
     * @type {string}
     * @memberof UserInfo
     */
    'countryPhoneCode': string;
    /**
     * Whether the phone number is verified
     * @type {boolean}
     * @memberof UserInfo
     */
    'phoneVerified': boolean;
    /**
     * Session token used for ordering authorization
     * @type {string}
     * @memberof UserInfo
     */
    'orderingAccessToken': string;
}
/**
 * 
 * @export
 * @interface UserInfoResponse
 */
export interface UserInfoResponse {
    /**
     * 
     * @type {number}
     * @memberof UserInfoResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserInfoResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoResponse
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoResponse
     */
    'cellphone': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoResponse
     */
    'countryPhoneCode': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserInfoResponse
     */
    'phoneVerified': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserInfoResponse
     */
    'orderingAccessToken': string;
}
/**
 * 
 * @export
 * @interface UserInfoResponseDto
 */
export interface UserInfoResponseDto {
    /**
     * 
     * @type {number}
     * @memberof UserInfoResponseDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserInfoResponseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoResponseDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoResponseDto
     */
    'cellphone': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoResponseDto
     */
    'countryPhoneCode': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserInfoResponseDto
     */
    'phoneVerified': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserInfoResponseDto
     */
    'orderingAccessToken': string;
}
/**
 * 
 * @export
 * @interface UserValidation
 */
export interface UserValidation {
    /**
     * 
     * @type {string}
     * @memberof UserValidation
     */
    'phone': string;
}
/**
 * 
 * @export
 * @interface UserWithLoyaltyDto
 */
export interface UserWithLoyaltyDto {
    /**
     * 
     * @type {ProgramUserDto}
     * @memberof UserWithLoyaltyDto
     */
    'user': ProgramUserDto;
    /**
     * 
     * @type {LoyaltyAccountDto}
     * @memberof UserWithLoyaltyDto
     */
    'loyaltyAccount': LoyaltyAccountDto;
}
/**
 * 
 * @export
 * @interface ValidateGiftCardDto
 */
export interface ValidateGiftCardDto {
    /**
     * 
     * @type {string}
     * @memberof ValidateGiftCardDto
     */
    'giftCardNumber': string;
    /**
     * 
     * @type {number}
     * @memberof ValidateGiftCardDto
     */
    'orderingBusinessId': number;
}
/**
 * 
 * @export
 * @interface ValidateGiftCardResponseDto
 */
export interface ValidateGiftCardResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof ValidateGiftCardResponseDto
     */
    'valid': boolean;
    /**
     * 
     * @type {number}
     * @memberof ValidateGiftCardResponseDto
     */
    'errorCode'?: number | null;
    /**
     * 
     * @type {GiftCardInfoDto}
     * @memberof ValidateGiftCardResponseDto
     */
    'cardInfo'?: GiftCardInfoDto;
}
/**
 * 
 * @export
 * @interface ValidatePasscodeDto
 */
export interface ValidatePasscodeDto {
    /**
     * 
     * @type {number}
     * @memberof ValidatePasscodeDto
     */
    'businessId': number;
    /**
     * 
     * @type {number}
     * @memberof ValidatePasscodeDto
     */
    'passcode': number;
}
/**
 * 
 * @export
 * @interface ValidatePasscodeResponseDto
 */
export interface ValidatePasscodeResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof ValidatePasscodeResponseDto
     */
    'valid': boolean;
    /**
     * Permissions returned only if valid is true
     * @type {Array<PermissionDto>}
     * @memberof ValidatePasscodeResponseDto
     */
    'permissions'?: Array<PermissionDto>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const VerificationType = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type VerificationType = typeof VerificationType[keyof typeof VerificationType];


/**
 * 
 * @export
 * @interface VideoBackgroundConfig
 */
export interface VideoBackgroundConfig {
    /**
     * Opacity of the overlay
     * @type {number}
     * @memberof VideoBackgroundConfig
     */
    'overlayOpacity': number;
    /**
     * Color of the overlay
     * @type {string}
     * @memberof VideoBackgroundConfig
     */
    'overlayColor'?: string;
    /**
     * 
     * @type {BusinessBackgroundType}
     * @memberof VideoBackgroundConfig
     */
    'type': BusinessBackgroundType;
    /**
     * URL of the video file
     * @type {string}
     * @memberof VideoBackgroundConfig
     */
    'url': string;
    /**
     * Thumbnail URL shown while video loads
     * @type {string}
     * @memberof VideoBackgroundConfig
     */
    'poster': string;
    /**
     * Should the video loop?
     * @type {boolean}
     * @memberof VideoBackgroundConfig
     */
    'loop'?: boolean;
}


/**
 * 
 * @export
 * @interface VivaCancelTransactionDto
 */
export interface VivaCancelTransactionDto {
    /**
     * The session ID for the transaction.
     * @type {string}
     * @memberof VivaCancelTransactionDto
     */
    'sessionId': string;
    /**
     * The cash register ID for the transaction.
     * @type {string}
     * @memberof VivaCancelTransactionDto
     */
    'cashRegisterId': string;
}
/**
 * 
 * @export
 * @interface VivaCreatePaymentDto
 */
export interface VivaCreatePaymentDto {
    /**
     * The ordering business ID for this transaction.
     * @type {number}
     * @memberof VivaCreatePaymentDto
     */
    'orderingBusinessId': number;
    /**
     * 
     * @type {PaymentProvider}
     * @memberof VivaCreatePaymentDto
     */
    'provider': PaymentProvider;
    /**
     * The cart ID for this transaction.
     * @type {string}
     * @memberof VivaCreatePaymentDto
     */
    'cartId': string;
    /**
     * The amount for this transaction in cents.
     * @type {number}
     * @memberof VivaCreatePaymentDto
     */
    'amount': number;
    /**
     * The terminal ID for this transaction.
     * @type {string}
     * @memberof VivaCreatePaymentDto
     */
    'terminalId': string;
    /**
     * 
     * @type {VivaCurrencyCode}
     * @memberof VivaCreatePaymentDto
     */
    'currencyCode': VivaCurrencyCode;
    /**
     * Whether to show the transaction result.
     * @type {boolean}
     * @memberof VivaCreatePaymentDto
     */
    'showTransactionResult'?: boolean;
    /**
     * Whether to show the receipt.
     * @type {boolean}
     * @memberof VivaCreatePaymentDto
     */
    'showReceipt'?: boolean;
    /**
     * The tip amount for this transaction.
     * @type {number}
     * @memberof VivaCreatePaymentDto
     */
    'tipAmount'?: number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const VivaCurrencyCode = {
    _978: '978',
    _840: '840',
    _826: '826',
    _392: '392',
    _036: '036',
    _124: '124',
    _756: '756',
    _156: '156',
    _344: '344',
    _554: '554',
    _752: '752',
    _410: '410',
    _702: '702',
    _578: '578',
    _484: '484',
    _356: '356',
    _643: '643',
    _710: '710',
    _949: '949',
    _986: '986',
    _901: '901',
    _208: '208',
    _985: '985',
    _764: '764',
    _360: '360',
    _348: '348',
    _203: '203',
    _376: '376',
    _152: '152',
    _608: '608',
    _784: '784',
    _170: '170',
    _682: '682',
    _458: '458',
    _946: '946'
} as const;

export type VivaCurrencyCode = typeof VivaCurrencyCode[keyof typeof VivaCurrencyCode];


/**
 * 
 * @export
 * @interface VivaDevice
 */
export interface VivaDevice {
    /**
     * The terminal ID for this transaction.
     * @type {string}
     * @memberof VivaDevice
     */
    'terminalId': string;
    /**
     * 
     * @type {DeviceStatus}
     * @memberof VivaDevice
     */
    'statusId': DeviceStatus;
    /**
     * The source code of the business location.
     * @type {string}
     * @memberof VivaDevice
     */
    'sourceCode': string;
    /**
     * The virtual terminal ID of the device.
     * @type {string}
     * @memberof VivaDevice
     */
    'virtualTerminalId': string;
}


/**
 * 
 * @export
 * @interface VivaDiscoverDevicesDto
 */
export interface VivaDiscoverDevicesDto {
    /**
     * The ordering business ID for this transaction.
     * @type {number}
     * @memberof VivaDiscoverDevicesDto
     */
    'orderingBusinessId': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const VivaErrorId = {
    NUMBER_1000: 1000,
    NUMBER_1001: 1001,
    NUMBER_1002: 1002,
    NUMBER_1003: 1003,
    NUMBER_1004: 1004,
    NUMBER_1006: 1006,
    NUMBER_1007: 1007,
    NUMBER_1008: 1008,
    NUMBER_1009: 1009,
    NUMBER_1010: 1010,
    NUMBER_1011: 1011,
    NUMBER_1012: 1012,
    NUMBER_1013: 1013,
    NUMBER_1014: 1014,
    NUMBER_1016: 1016,
    NUMBER_1017: 1017,
    NUMBER_1018: 1018,
    NUMBER_1019: 1019,
    NUMBER_1020: 1020,
    NUMBER_1021: 1021,
    NUMBER_1047: 1047,
    NUMBER_1048: 1048,
    NUMBER_1049: 1049,
    NUMBER_1050: 1050,
    NUMBER_1051: 1051,
    NUMBER_1052: 1052,
    NUMBER_1053: 1053,
    NUMBER_1054: 1054,
    NUMBER_1055: 1055,
    NUMBER_1056: 1056,
    NUMBER_1057: 1057,
    NUMBER_1058: 1058,
    NUMBER_1059: 1059,
    NUMBER_1060: 1060,
    NUMBER_1061: 1061,
    NUMBER_1062: 1062,
    NUMBER_1063: 1063,
    NUMBER_1064: 1064,
    NUMBER_1065: 1065,
    NUMBER_1066: 1066,
    NUMBER_1067: 1067,
    NUMBER_1068: 1068,
    NUMBER_1069: 1069,
    NUMBER_1070: 1070,
    NUMBER_1071: 1071,
    NUMBER_1072: 1072,
    NUMBER_1074: 1074,
    NUMBER_1075: 1075,
    NUMBER_1076: 1076,
    NUMBER_1077: 1077,
    NUMBER_1079: 1079,
    NUMBER_1080: 1080,
    NUMBER_1081: 1081,
    NUMBER_1082: 1082,
    NUMBER_1083: 1083,
    NUMBER_1099: 1099,
    NUMBER_1100: 1100,
    NUMBER_1101: 1101,
    NUMBER_1102: 1102,
    NUMBER_1110: 1110,
    NUMBER_1301: 1301,
    NUMBER_1302: 1302,
    NUMBER_1303: 1303,
    NUMBER_2000: 2000,
    NUMBER_3000: 3000,
    NUMBER_3001: 3001,
    NUMBER_3002: 3002,
    NUMBER_3099: 3099,
    NUMBER_4000: 4000,
    NUMBER_5000: 5000,
    NUMBER_5001: 5001,
    NUMBER_5002: 5002,
    NUMBER_5003: 5003,
    NUMBER_5004: 5004,
    NUMBER_5005: 5005,
    NUMBER_5006: 5006,
    NUMBER_6000: 6000,
    NUMBER_6102: 6102,
    NUMBER_6201: 6201,
    NUMBER_7001: 7001,
    NUMBER_7002: 7002,
    NUMBER_7003: 7003,
    NUMBER_7004: 7004,
    NUMBER_7005: 7005
} as const;

export type VivaErrorId = typeof VivaErrorId[keyof typeof VivaErrorId];


/**
 * 
 * @export
 * @interface VivaEventDataEcrDto
 */
export interface VivaEventDataEcrDto {
    /**
     * Application Identifier (AID)
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'Aid': string;
    /**
     * Terminal ID (Tid)
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'Tid': string;
    /**
     * Transaction amount in the smallest currency unit
     * @type {number}
     * @memberof VivaEventDataEcrDto
     */
    'Amount': number;
    /**
     * 
     * @type {VivaEventId}
     * @memberof VivaEventDataEcrDto
     */
    'EventId': VivaEventId;
    /**
     * Indicates if the transaction was a pre-authorization
     * @type {boolean}
     * @memberof VivaEventDataEcrDto
     */
    'Preauth': boolean;
    /**
     * Indicates if the transaction was successful
     * @type {boolean}
     * @memberof VivaEventDataEcrDto
     */
    'Success': boolean;
    /**
     * Message describing the transaction outcome
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'Message': string;
    /**
     * Tip amount
     * @type {number}
     * @memberof VivaEventDataEcrDto
     */
    'TipAmount': number;
    /**
     * Merchant ID (UUID)
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'MerchantId': string;
    /**
     * Reseller ID (UUID)
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'ResellerId': string;
    /**
     * Order Code
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'OrderCode': string;
    /**
     * Session ID
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'SessionId': string;
    /**
     * Number of installments
     * @type {number}
     * @memberof VivaEventDataEcrDto
     */
    'Installments': number;
    /**
     * Terminal ID
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'TerminalId': string;
    /**
     * Indicates if an abort success operation occurred
     * @type {boolean}
     * @memberof VivaEventDataEcrDto
     */
    'AbortSuccess': boolean;
    /**
     * Indicates if an abort operation occurred
     * @type {boolean}
     * @memberof VivaEventDataEcrDto
     */
    'AbortOperation': boolean;
    /**
     * 
     * @type {VivaCurrencyCode}
     * @memberof VivaEventDataEcrDto
     */
    'CurrencyCode': VivaCurrencyCode;
    /**
     * PAN Entry Mode
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'PanEntryMode': string;
    /**
     * Transaction ID (UUID)
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'TransactionId': string;
    /**
     * Reference Number
     * @type {number}
     * @memberof VivaEventDataEcrDto
     */
    'ReferenceNumber': number;
    /**
     * Cash Register ID
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'CashRegisterId': string;
    /**
     * DCC Details
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'DccDetails'?: string;
    /**
     * Short Order Code
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'ShortOrderCode': string;
    /**
     * Transaction Type ID
     * @type {number}
     * @memberof VivaEventDataEcrDto
     */
    'TransactionTypeId': number;
    /**
     * Authorization ID
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'AuthorizationId': string;
    /**
     * Application Label (e.g., Card Scheme)
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'ApplicationLabel': string;
    /**
     * Loyalty Information
     * @type {object}
     * @memberof VivaEventDataEcrDto
     */
    'LoyaltyInfo'?: object;
    /**
     * AADE Transaction ID
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'AadeTransactionId'?: string | null;
    /**
     * Merchant Reference
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'MerchantReference': string;
    /**
     * Cardholder Verification Method (CVM)
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'VerificationMethod': string;
    /**
     * Abort Acknowledge Time
     * @type {object}
     * @memberof VivaEventDataEcrDto
     */
    'AbortAckTime'?: object;
    /**
     * Retrieval Reference Number
     * @type {number}
     * @memberof VivaEventDataEcrDto
     */
    'RetrievalReferenceNumber': number;
    /**
     * Primary Account Number Masked
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'PrimaryAccountNumberMasked': string;
    /**
     * Transaction Date and Time (ISO 8601 format)
     * @type {string}
     * @memberof VivaEventDataEcrDto
     */
    'TransactionDateTime': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const VivaEventId = {
    NUMBER_1000: 1000,
    NUMBER_1001: 1001,
    NUMBER_1002: 1002,
    NUMBER_1003: 1003,
    NUMBER_1004: 1004,
    NUMBER_1006: 1006,
    NUMBER_1007: 1007,
    NUMBER_1008: 1008,
    NUMBER_1009: 1009,
    NUMBER_1010: 1010,
    NUMBER_1011: 1011,
    NUMBER_1012: 1012,
    NUMBER_1013: 1013,
    NUMBER_1014: 1014,
    NUMBER_1016: 1016,
    NUMBER_1017: 1017,
    NUMBER_1018: 1018,
    NUMBER_1019: 1019,
    NUMBER_1020: 1020,
    NUMBER_1021: 1021,
    NUMBER_1047: 1047,
    NUMBER_1048: 1048,
    NUMBER_1049: 1049,
    NUMBER_1050: 1050,
    NUMBER_1051: 1051,
    NUMBER_1052: 1052,
    NUMBER_1053: 1053,
    NUMBER_1054: 1054,
    NUMBER_1055: 1055,
    NUMBER_1056: 1056,
    NUMBER_1057: 1057,
    NUMBER_1058: 1058,
    NUMBER_1059: 1059,
    NUMBER_1060: 1060,
    NUMBER_1061: 1061,
    NUMBER_1062: 1062,
    NUMBER_1063: 1063,
    NUMBER_1064: 1064,
    NUMBER_1065: 1065,
    NUMBER_1066: 1066,
    NUMBER_1067: 1067,
    NUMBER_1068: 1068,
    NUMBER_1069: 1069,
    NUMBER_1070: 1070,
    NUMBER_1071: 1071,
    NUMBER_1072: 1072,
    NUMBER_1074: 1074,
    NUMBER_1075: 1075,
    NUMBER_1076: 1076,
    NUMBER_1077: 1077,
    NUMBER_1079: 1079,
    NUMBER_1080: 1080,
    NUMBER_1081: 1081,
    NUMBER_1082: 1082,
    NUMBER_1083: 1083,
    NUMBER_1099: 1099,
    NUMBER_1100: 1100,
    NUMBER_1101: 1101,
    NUMBER_1102: 1102,
    NUMBER_1110: 1110,
    NUMBER_1301: 1301,
    NUMBER_1302: 1302,
    NUMBER_1303: 1303,
    NUMBER_2000: 2000,
    NUMBER_3000: 3000,
    NUMBER_3001: 3001,
    NUMBER_3002: 3002,
    NUMBER_3099: 3099,
    NUMBER_4000: 4000,
    NUMBER_5000: 5000,
    NUMBER_5001: 5001,
    NUMBER_5002: 5002,
    NUMBER_5003: 5003,
    NUMBER_5004: 5004,
    NUMBER_5005: 5005,
    NUMBER_5006: 5006,
    NUMBER_6000: 6000,
    NUMBER_6102: 6102,
    NUMBER_6201: 6201,
    NUMBER_7001: 7001,
    NUMBER_7002: 7002,
    NUMBER_7003: 7003,
    NUMBER_7004: 7004,
    NUMBER_7005: 7005
} as const;

export type VivaEventId = typeof VivaEventId[keyof typeof VivaEventId];


/**
 * 
 * @export
 * @interface VivaPaymentIntent
 */
export interface VivaPaymentIntent {
    /**
     * The session ID for the transaction.
     * @type {string}
     * @memberof VivaPaymentIntent
     */
    'sessionId': string;
    /**
     * The terminal ID initiating the transaction.
     * @type {string}
     * @memberof VivaPaymentIntent
     */
    'terminalId': string;
    /**
     * The cash register ID associated with the transaction.
     * @type {string}
     * @memberof VivaPaymentIntent
     */
    'cashRegisterId': string;
    /**
     * The amount of the transaction.
     * @type {number}
     * @memberof VivaPaymentIntent
     */
    'amount': number;
    /**
     * The currency code for the transaction amount.
     * @type {string}
     * @memberof VivaPaymentIntent
     */
    'currencyCode': CurrencyCodeEnum;
    /**
     * A reference for the merchant.
     * @type {string}
     * @memberof VivaPaymentIntent
     */
    'merchantReference'?: string;
    /**
     * A human-readable description for the customer statement.
     * @type {string}
     * @memberof VivaPaymentIntent
     */
    'customerTrns'?: string;
    /**
     * The tip amount included in the transaction.
     * @type {number}
     * @memberof VivaPaymentIntent
     */
    'tipAmount': number;
    /**
     * Indicates if the transaction is a preauthorization.
     * @type {boolean}
     * @memberof VivaPaymentIntent
     */
    'preauth': boolean;
    /**
     * Whether to show the transaction result on the terminal.
     * @type {boolean}
     * @memberof VivaPaymentIntent
     */
    'showTransactionResult': boolean;
    /**
     * Whether to show the receipt on the terminal.
     * @type {boolean}
     * @memberof VivaPaymentIntent
     */
    'showReceipt': boolean;
    /**
     * 
     * @type {VivaPaymentIntentIsvDetails}
     * @memberof VivaPaymentIntent
     */
    'isvDetails'?: VivaPaymentIntentIsvDetails;
}

export const CurrencyCodeEnum = {
    _978: '978',
    _840: '840',
    _826: '826',
    _392: '392',
    _036: '036',
    _124: '124',
    _756: '756',
    _156: '156',
    _344: '344',
    _554: '554',
    _752: '752',
    _410: '410',
    _702: '702',
    _578: '578',
    _484: '484',
    _356: '356',
    _643: '643',
    _710: '710',
    _949: '949',
    _986: '986',
    _901: '901',
    _208: '208',
    _985: '985',
    _764: '764',
    _360: '360',
    _348: '348',
    _203: '203',
    _376: '376',
    _152: '152',
    _608: '608',
    _784: '784',
    _170: '170',
    _682: '682',
    _458: '458',
    _946: '946'
} as const;

export type CurrencyCodeEnum = typeof CurrencyCodeEnum[keyof typeof CurrencyCodeEnum];

/**
 * ISV (Independent Software Vendor) specific details.
 * @export
 * @interface VivaPaymentIntentIsvDetails
 */
export interface VivaPaymentIntentIsvDetails {
    /**
     * The amount related to the ISV (Independent Software Vendor).
     * @type {number}
     * @memberof VivaPaymentIntentIsvDetails
     */
    'amount'?: number;
    /**
     * The terminal merchant ID associated with the ISV.
     * @type {string}
     * @memberof VivaPaymentIntentIsvDetails
     */
    'terminalMerchantId'?: string;
    /**
     * The source code for the ISV.
     * @type {string}
     * @memberof VivaPaymentIntentIsvDetails
     */
    'sourceCode'?: string;
    /**
     * The merchant ID for the ISV.
     * @type {string}
     * @memberof VivaPaymentIntentIsvDetails
     */
    'merchantId'?: string;
    /**
     * The merchant source code for the ISV.
     * @type {string}
     * @memberof VivaPaymentIntentIsvDetails
     */
    'merchantSourceCode'?: string;
}
/**
 * 
 * @export
 * @interface VivaPaymentMessageDto
 */
export interface VivaPaymentMessageDto {
    /**
     * Indicates if the payment transaction was successful.
     * @type {boolean}
     * @memberof VivaPaymentMessageDto
     */
    'success': boolean;
    /**
     * Error message if the transaction failed.
     * @type {string}
     * @memberof VivaPaymentMessageDto
     */
    'error'?: string;
    /**
     * The detailed, human-readable error string provided by the payment service provider (PSP) if the transaction failed.
     * @type {string}
     * @memberof VivaPaymentMessageDto
     */
    'errorCode'?: string;
    /**
     * The terminal ID where the transaction was processed.
     * @type {object}
     * @memberof VivaPaymentMessageDto
     */
    'terminalId'?: object | null;
    /**
     * The raw, unparsed response object received from the payment provider.
     * @type {object}
     * @memberof VivaPaymentMessageDto
     */
    'rawData': object;
    /**
     * A unique identifier for the request, used for tracking.
     * @type {string}
     * @memberof VivaPaymentMessageDto
     */
    'sessionId'?: string;
    /**
     * 
     * @type {VivaPaymentMessageDtoData}
     * @memberof VivaPaymentMessageDto
     */
    'data'?: VivaPaymentMessageDtoData;
}
/**
 * Transaction details if the payment was successful.
 * @export
 * @interface VivaPaymentMessageDtoData
 */
export interface VivaPaymentMessageDtoData {
    /**
     * The session ID for the transaction.
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'sessionId': string;
    /**
     * The terminal ID that performed the transaction.
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'terminalId': string;
    /**
     * The cash register ID associated with the transaction.
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'cashRegisterId': string;
    /**
     * The amount of the transaction in the smallest currency unit.
     * @type {number}
     * @memberof VivaPaymentMessageDtoData
     */
    'amount': number;
    /**
     * 
     * @type {VivaCurrencyCode}
     * @memberof VivaPaymentMessageDtoData
     */
    'currencyCode': VivaCurrencyCode;
    /**
     * A reference for the merchant (e.g., order ID).
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'merchantReference'?: string;
    /**
     * A human-readable description for the customer statement.
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'customerTrns'?: string;
    /**
     * Whether the receipt was shown on the terminal.
     * @type {boolean}
     * @memberof VivaPaymentMessageDtoData
     */
    'showReceipt': boolean;
    /**
     * Whether the transaction result was shown on the terminal.
     * @type {boolean}
     * @memberof VivaPaymentMessageDtoData
     */
    'showTransactionResult': boolean;
    /**
     * The tip amount included in the transaction.
     * @type {number}
     * @memberof VivaPaymentMessageDtoData
     */
    'tipAmount': number;
    /**
     * Indicates if the transaction was successful.
     * @type {boolean}
     * @memberof VivaPaymentMessageDtoData
     */
    'success': boolean;
    /**
     * 
     * @type {VivaErrorId}
     * @memberof VivaPaymentMessageDtoData
     */
    'eventId': VivaErrorId;
    /**
     * Parent session id for refund
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'parentSessionId'?: string | null;
    /**
     * Authorization ID from the acquirer/issuer.
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'authorizationId': string;
    /**
     * Unique transaction ID generated by the system.
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'transactionId': string;
    /**
     * Type ID of the transaction (e.g., Sale, Refund).
     * @type {number}
     * @memberof VivaPaymentMessageDtoData
     */
    'transactionTypeId': number;
    /**
     * Retrieval Reference Number (RRN).
     * @type {number}
     * @memberof VivaPaymentMessageDtoData
     */
    'retrievalReferenceNumber': number;
    /**
     * Indicates how the card was entered (e.g., Contactless, Chip).
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'panEntryMode': string;
    /**
     * Card application label (e.g., Visa Debit).
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'applicationLabel': string;
    /**
     * Application Identifier (AID) of the card.
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'aid': string;
    /**
     * Masked Primary Account Number (PAN) of the card.
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'primaryAccountNumberMasked': string;
    /**
     * Date and time of the transaction (ISO 8601 format).
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'transactionDateTime': string;
    /**
     * Indicates if the operation was aborted by the user/system.
     * @type {boolean}
     * @memberof VivaPaymentMessageDtoData
     */
    'abortOperation': boolean;
    /**
     * Time the abort operation was acknowledged.
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'abortAckTime'?: string | null;
    /**
     * Indicates if the abort operation was successful.
     * @type {boolean}
     * @memberof VivaPaymentMessageDtoData
     */
    'abortSuccess': boolean;
    /**
     * Information related to loyalty programs.
     * @type {object}
     * @memberof VivaPaymentMessageDtoData
     */
    'loyaltyInfo'?: object | null;
    /**
     * Cardholder Verification Method used (e.g., PIN, Signature, None).
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'verificationMethod': string;
    /**
     * Terminal Identifier (TID), often same as terminalId.
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'tid': string;
    /**
     * A short code related to the order.
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'shortOrderCode': string;
    /**
     * Number of installments for the payment.
     * @type {number}
     * @memberof VivaPaymentMessageDtoData
     */
    'installments': number;
    /**
     * A human-readable message about the transaction status.
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'message': string;
    /**
     * Indicates if the transaction was a preauthorization.
     * @type {boolean}
     * @memberof VivaPaymentMessageDtoData
     */
    'preauth': boolean;
    /**
     * A reference number for the transaction.
     * @type {number}
     * @memberof VivaPaymentMessageDtoData
     */
    'referenceNumber': number;
    /**
     * A full code related to the order.
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'orderCode': string;
    /**
     * Transaction event ID.
     * @type {number}
     * @memberof VivaPaymentMessageDtoData
     */
    'transactionEventId': number;
    /**
     * Type of the card used (e.g., Visa Debit, Mastercard).
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'cardType': string;
    /**
     * Identifier for the bank or card network.
     * @type {string}
     * @memberof VivaPaymentMessageDtoData
     */
    'bankId': string;
    /**
     * 
     * @type {VivaPaymentIntentIsvDetails}
     * @memberof VivaPaymentMessageDtoData
     */
    'isvDetails'?: VivaPaymentIntentIsvDetails;
    /**
     * AADE (Greek Tax Authority) specific transaction ID.
     * @type {object}
     * @memberof VivaPaymentMessageDtoData
     */
    'aadeTransactionId'?: object | null;
    /**
     * AADE (Greek Tax Authority) specific result command.
     * @type {object}
     * @memberof VivaPaymentMessageDtoData
     */
    'aadeResultCommand'?: object | null;
    /**
     * Dynamic Currency Conversion (DCC) details, if applicable.
     * @type {object}
     * @memberof VivaPaymentMessageDtoData
     */
    'dccDetails'?: object | null;
    /**
     * Any surcharge amount applied to the transaction.
     * @type {number}
     * @memberof VivaPaymentMessageDtoData
     */
    'surchargeAmount': number;
}


/**
 * 
 * @export
 * @interface VivaPaymentResultDto
 */
export interface VivaPaymentResultDto {
    /**
     * The session ID for the transaction.
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'sessionId': string;
    /**
     * The terminal ID that performed the transaction.
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'terminalId': string;
    /**
     * The cash register ID associated with the transaction.
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'cashRegisterId': string;
    /**
     * The amount of the transaction in the smallest currency unit.
     * @type {number}
     * @memberof VivaPaymentResultDto
     */
    'amount': number;
    /**
     * 
     * @type {VivaCurrencyCode}
     * @memberof VivaPaymentResultDto
     */
    'currencyCode': VivaCurrencyCode;
    /**
     * A reference for the merchant (e.g., order ID).
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'merchantReference'?: string;
    /**
     * A human-readable description for the customer statement.
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'customerTrns'?: string;
    /**
     * Whether the receipt was shown on the terminal.
     * @type {boolean}
     * @memberof VivaPaymentResultDto
     */
    'showReceipt': boolean;
    /**
     * Whether the transaction result was shown on the terminal.
     * @type {boolean}
     * @memberof VivaPaymentResultDto
     */
    'showTransactionResult': boolean;
    /**
     * The tip amount included in the transaction.
     * @type {number}
     * @memberof VivaPaymentResultDto
     */
    'tipAmount': number;
    /**
     * Indicates if the transaction was successful.
     * @type {boolean}
     * @memberof VivaPaymentResultDto
     */
    'success': boolean;
    /**
     * 
     * @type {VivaErrorId}
     * @memberof VivaPaymentResultDto
     */
    'eventId': VivaErrorId;
    /**
     * Parent session id for refund
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'parentSessionId'?: string | null;
    /**
     * Authorization ID from the acquirer/issuer.
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'authorizationId': string;
    /**
     * Unique transaction ID generated by the system.
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'transactionId': string;
    /**
     * Type ID of the transaction (e.g., Sale, Refund).
     * @type {number}
     * @memberof VivaPaymentResultDto
     */
    'transactionTypeId': number;
    /**
     * Retrieval Reference Number (RRN).
     * @type {number}
     * @memberof VivaPaymentResultDto
     */
    'retrievalReferenceNumber': number;
    /**
     * Indicates how the card was entered (e.g., Contactless, Chip).
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'panEntryMode': string;
    /**
     * Card application label (e.g., Visa Debit).
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'applicationLabel': string;
    /**
     * Application Identifier (AID) of the card.
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'aid': string;
    /**
     * Masked Primary Account Number (PAN) of the card.
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'primaryAccountNumberMasked': string;
    /**
     * Date and time of the transaction (ISO 8601 format).
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'transactionDateTime': string;
    /**
     * Indicates if the operation was aborted by the user/system.
     * @type {boolean}
     * @memberof VivaPaymentResultDto
     */
    'abortOperation': boolean;
    /**
     * Time the abort operation was acknowledged.
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'abortAckTime'?: string | null;
    /**
     * Indicates if the abort operation was successful.
     * @type {boolean}
     * @memberof VivaPaymentResultDto
     */
    'abortSuccess': boolean;
    /**
     * Information related to loyalty programs.
     * @type {object}
     * @memberof VivaPaymentResultDto
     */
    'loyaltyInfo'?: object | null;
    /**
     * Cardholder Verification Method used (e.g., PIN, Signature, None).
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'verificationMethod': string;
    /**
     * Terminal Identifier (TID), often same as terminalId.
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'tid': string;
    /**
     * A short code related to the order.
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'shortOrderCode': string;
    /**
     * Number of installments for the payment.
     * @type {number}
     * @memberof VivaPaymentResultDto
     */
    'installments': number;
    /**
     * A human-readable message about the transaction status.
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'message': string;
    /**
     * Indicates if the transaction was a preauthorization.
     * @type {boolean}
     * @memberof VivaPaymentResultDto
     */
    'preauth': boolean;
    /**
     * A reference number for the transaction.
     * @type {number}
     * @memberof VivaPaymentResultDto
     */
    'referenceNumber': number;
    /**
     * A full code related to the order.
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'orderCode': string;
    /**
     * Transaction event ID.
     * @type {number}
     * @memberof VivaPaymentResultDto
     */
    'transactionEventId': number;
    /**
     * Type of the card used (e.g., Visa Debit, Mastercard).
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'cardType': string;
    /**
     * Identifier for the bank or card network.
     * @type {string}
     * @memberof VivaPaymentResultDto
     */
    'bankId': string;
    /**
     * 
     * @type {VivaPaymentIntentIsvDetails}
     * @memberof VivaPaymentResultDto
     */
    'isvDetails'?: VivaPaymentIntentIsvDetails;
    /**
     * AADE (Greek Tax Authority) specific transaction ID.
     * @type {object}
     * @memberof VivaPaymentResultDto
     */
    'aadeTransactionId'?: object | null;
    /**
     * AADE (Greek Tax Authority) specific result command.
     * @type {object}
     * @memberof VivaPaymentResultDto
     */
    'aadeResultCommand'?: object | null;
    /**
     * Dynamic Currency Conversion (DCC) details, if applicable.
     * @type {object}
     * @memberof VivaPaymentResultDto
     */
    'dccDetails'?: object | null;
    /**
     * Any surcharge amount applied to the transaction.
     * @type {number}
     * @memberof VivaPaymentResultDto
     */
    'surchargeAmount': number;
}


/**
 * 
 * @export
 * @interface VivaWebhookPayloadDto
 */
export interface VivaWebhookPayloadDto {
    /**
     * Webhook URL
     * @type {string}
     * @memberof VivaWebhookPayloadDto
     */
    'Url': string;
    /**
     * Event data containing transaction details
     * @type {object}
     * @memberof VivaWebhookPayloadDto
     */
    'EventData': object;
    /**
     * Event creation timestamp
     * @type {string}
     * @memberof VivaWebhookPayloadDto
     */
    'Created': string;
    /**
     * Correlation ID for tracking
     * @type {string}
     * @memberof VivaWebhookPayloadDto
     */
    'CorrelationId': string;
    /**
     * Event type ID
     * @type {number}
     * @memberof VivaWebhookPayloadDto
     */
    'EventTypeId': EventTypeIdEnum;
    /**
     * Event delay
     * @type {object}
     * @memberof VivaWebhookPayloadDto
     */
    'Delay'?: object;
    /**
     * Retry count
     * @type {number}
     * @memberof VivaWebhookPayloadDto
     */
    'RetryCount': number;
    /**
     * Retry delay in seconds
     * @type {object}
     * @memberof VivaWebhookPayloadDto
     */
    'RetryDelayInSeconds'?: object;
    /**
     * Message ID
     * @type {string}
     * @memberof VivaWebhookPayloadDto
     */
    'MessageId': string;
    /**
     * Recipient ID
     * @type {string}
     * @memberof VivaWebhookPayloadDto
     */
    'RecipientId': string;
    /**
     * Message type ID
     * @type {number}
     * @memberof VivaWebhookPayloadDto
     */
    'MessageTypeId': number;
}

export const EventTypeIdEnum = {
    NUMBER_1796: 1796,
    NUMBER_1797: 1797,
    NUMBER_1798: 1798,
    NUMBER_1799: 1799,
    NUMBER_1802: 1802,
    NUMBER_1803: 1803,
    NUMBER_8193: 8193,
    NUMBER_8194: 8194
} as const;

export type EventTypeIdEnum = typeof EventTypeIdEnum[keyof typeof EventTypeIdEnum];

/**
 * 
 * @export
 * @interface WalletDto
 */
export interface WalletDto {
    /**
     * The ID of the wallet
     * @type {number}
     * @memberof WalletDto
     */
    'id': number;
    /**
     * Unique code for the wallet
     * @type {string}
     * @memberof WalletDto
     */
    'code': string;
    /**
     * The ID of the user who owns this wallet
     * @type {number}
     * @memberof WalletDto
     */
    'user_id': number;
    /**
     * Current balance in the wallet
     * @type {number}
     * @memberof WalletDto
     */
    'balance': number;
    /**
     * Whether the wallet is locked
     * @type {boolean}
     * @memberof WalletDto
     */
    'locked': boolean;
    /**
     * Reason for locking the wallet, if applicable
     * @type {object}
     * @memberof WalletDto
     */
    'locked_reason': object | null;
    /**
     * Timestamp when the wallet was locked, if applicable
     * @type {object}
     * @memberof WalletDto
     */
    'locked_at': object | null;
    /**
     * Timestamp when the wallet was created
     * @type {string}
     * @memberof WalletDto
     */
    'created_at': string;
    /**
     * Timestamp when the wallet was last updated
     * @type {string}
     * @memberof WalletDto
     */
    'updated_at': string;
    /**
     * Type of wallet (e.g., cash, credit_point)
     * @type {string}
     * @memberof WalletDto
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface WechatPayDetailsDto
 */
export interface WechatPayDetailsDto {
    /**
     * Payment location
     * @type {string}
     * @memberof WechatPayDetailsDto
     */
    'location'?: string | null;
    /**
     * Reader identifier
     * @type {string}
     * @memberof WechatPayDetailsDto
     */
    'reader'?: string | null;
    /**
     * WeChat Pay transaction ID
     * @type {string}
     * @memberof WechatPayDetailsDto
     */
    'transactionId'?: string | null;
}

/**
 * AblyApi - axios parameter creator
 * @export
 */
export const AblyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ably/refresh-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTax: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ably/refresh-tax`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ably/request-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AblyApi - functional programming interface
 * @export
 */
export const AblyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AblyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshTax(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshTax(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AblyApi - factory interface
 * @export
 */
export const AblyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AblyApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshConfig(options?: any): AxiosPromise<void> {
            return localVarFp.refreshConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTax(options?: any): AxiosPromise<void> {
            return localVarFp.refreshTax(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestSettings(options?: any): AxiosPromise<void> {
            return localVarFp.requestSettings(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AblyApi - interface
 * @export
 * @interface AblyApi
 */
export interface AblyApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AblyApiInterface
     */
    refreshConfig(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AblyApiInterface
     */
    refreshTax(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AblyApiInterface
     */
    requestSettings(options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * AblyApi - object-oriented interface
 * @export
 * @class AblyApi
 * @extends {BaseAPI}
 */
export class AblyApi extends BaseAPI implements AblyApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AblyApi
     */
    public refreshConfig(options?: AxiosRequestConfig) {
        return AblyApiFp(this.configuration).refreshConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AblyApi
     */
    public refreshTax(options?: AxiosRequestConfig) {
        return AblyApiFp(this.configuration).refreshTax(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AblyApi
     */
    public requestSettings(options?: AxiosRequestConfig) {
        return AblyApiFp(this.configuration).requestSettings(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Checks if a user exists in Firebase by email. If not, it creates them. It then returns a custom token for the client app to sign in with.
         * @summary Upsert a user in Firebase and get a custom sign-in token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firebaseAuth: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/firebase-login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate verification code
         * @param {GenerateCodeDto} generateCodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCode: async (generateCodeDto: GenerateCodeDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateCodeDto' is not null or undefined
            assertParamExists('generateCode', 'generateCodeDto', generateCodeDto)
            const localVarPath = `/api/v1/auth/code/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateCodeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authorize user
         * @param {CredentialDto} credentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (credentialDto: CredentialDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialDto' is not null or undefined
            assertParamExists('login', 'credentialDto', credentialDto)
            const localVarPath = `/api/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credentialDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Log out the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh authentication token
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (refreshTokenDto: RefreshTokenDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenDto' is not null or undefined
            assertParamExists('refreshToken', 'refreshTokenDto', refreshTokenDto)
            const localVarPath = `/api/v1/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new user
         * @param {UserDto} userDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (userDto: UserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userDto' is not null or undefined
            assertParamExists('registerUser', 'userDto', userDto)
            const localVarPath = `/api/v1/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify the provided code
         * @param {string} orderingAccessToken Access token in the format eyJ0Blcm9.....
         * @param {PhoneCodeVerificationDto} phoneCodeVerificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCode: async (orderingAccessToken: string, phoneCodeVerificationDto: PhoneCodeVerificationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderingAccessToken' is not null or undefined
            assertParamExists('verifyCode', 'orderingAccessToken', orderingAccessToken)
            // verify required parameter 'phoneCodeVerificationDto' is not null or undefined
            assertParamExists('verifyCode', 'phoneCodeVerificationDto', phoneCodeVerificationDto)
            const localVarPath = `/api/v1/auth/code/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orderingAccessToken != null) {
                localVarHeaderParameter['orderingAccessToken'] = String(orderingAccessToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(phoneCodeVerificationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Checks if a user exists in Firebase by email. If not, it creates them. It then returns a custom token for the client app to sign in with.
         * @summary Upsert a user in Firebase and get a custom sign-in token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async firebaseAuth(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirebaseTokenDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.firebaseAuth(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate verification code
         * @param {GenerateCodeDto} generateCodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateCode(generateCodeDto: GenerateCodeDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateCodeResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateCode(generateCodeDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Authorize user
         * @param {CredentialDto} credentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(credentialDto: CredentialDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(credentialDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Log out the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogoutResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Refresh authentication token
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(refreshTokenDto: RefreshTokenDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshTokenDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new user
         * @param {UserDto} userDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(userDto: UserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterUserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(userDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Verify the provided code
         * @param {string} orderingAccessToken Access token in the format eyJ0Blcm9.....
         * @param {PhoneCodeVerificationDto} phoneCodeVerificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyCode(orderingAccessToken: string, phoneCodeVerificationDto: PhoneCodeVerificationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyCode(orderingAccessToken, phoneCodeVerificationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Checks if a user exists in Firebase by email. If not, it creates them. It then returns a custom token for the client app to sign in with.
         * @summary Upsert a user in Firebase and get a custom sign-in token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firebaseAuth(options?: any): AxiosPromise<FirebaseTokenDto> {
            return localVarFp.firebaseAuth(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate verification code
         * @param {GenerateCodeDto} generateCodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCode(generateCodeDto: GenerateCodeDto, options?: any): AxiosPromise<GenerateCodeResponseDto> {
            return localVarFp.generateCode(generateCodeDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authorize user
         * @param {CredentialDto} credentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(credentialDto: CredentialDto, options?: any): AxiosPromise<LoginResponseDto> {
            return localVarFp.login(credentialDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Log out the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<LogoutResponseDto> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh authentication token
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(refreshTokenDto: RefreshTokenDto, options?: any): AxiosPromise<RefreshTokenResponseDto> {
            return localVarFp.refreshToken(refreshTokenDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new user
         * @param {UserDto} userDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(userDto: UserDto, options?: any): AxiosPromise<RegisterUserResponseDto> {
            return localVarFp.registerUser(userDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify the provided code
         * @param {string} orderingAccessToken Access token in the format eyJ0Blcm9.....
         * @param {PhoneCodeVerificationDto} phoneCodeVerificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCode(orderingAccessToken: string, phoneCodeVerificationDto: PhoneCodeVerificationDto, options?: any): AxiosPromise<boolean> {
            return localVarFp.verifyCode(orderingAccessToken, phoneCodeVerificationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     * Checks if a user exists in Firebase by email. If not, it creates them. It then returns a custom token for the client app to sign in with.
     * @summary Upsert a user in Firebase and get a custom sign-in token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    firebaseAuth(options?: AxiosRequestConfig): AxiosPromise<FirebaseTokenDto>;

    /**
     * 
     * @summary Generate verification code
     * @param {GenerateCodeDto} generateCodeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    generateCode(generateCodeDto: GenerateCodeDto, options?: AxiosRequestConfig): AxiosPromise<GenerateCodeResponseDto>;

    /**
     * 
     * @summary Authorize user
     * @param {CredentialDto} credentialDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    login(credentialDto: CredentialDto, options?: AxiosRequestConfig): AxiosPromise<LoginResponseDto>;

    /**
     * 
     * @summary Log out the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    logout(options?: AxiosRequestConfig): AxiosPromise<LogoutResponseDto>;

    /**
     * 
     * @summary Refresh authentication token
     * @param {RefreshTokenDto} refreshTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    refreshToken(refreshTokenDto: RefreshTokenDto, options?: AxiosRequestConfig): AxiosPromise<RefreshTokenResponseDto>;

    /**
     * 
     * @summary Register a new user
     * @param {UserDto} userDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    registerUser(userDto: UserDto, options?: AxiosRequestConfig): AxiosPromise<RegisterUserResponseDto>;

    /**
     * 
     * @summary Verify the provided code
     * @param {string} orderingAccessToken Access token in the format eyJ0Blcm9.....
     * @param {PhoneCodeVerificationDto} phoneCodeVerificationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    verifyCode(orderingAccessToken: string, phoneCodeVerificationDto: PhoneCodeVerificationDto, options?: AxiosRequestConfig): AxiosPromise<boolean>;

}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     * Checks if a user exists in Firebase by email. If not, it creates them. It then returns a custom token for the client app to sign in with.
     * @summary Upsert a user in Firebase and get a custom sign-in token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public firebaseAuth(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).firebaseAuth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate verification code
     * @param {GenerateCodeDto} generateCodeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public generateCode(generateCodeDto: GenerateCodeDto, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).generateCode(generateCodeDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authorize user
     * @param {CredentialDto} credentialDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(credentialDto: CredentialDto, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(credentialDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Log out the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh authentication token
     * @param {RefreshTokenDto} refreshTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshToken(refreshTokenDto: RefreshTokenDto, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshToken(refreshTokenDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new user
     * @param {UserDto} userDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public registerUser(userDto: UserDto, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).registerUser(userDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify the provided code
     * @param {string} orderingAccessToken Access token in the format eyJ0Blcm9.....
     * @param {PhoneCodeVerificationDto} phoneCodeVerificationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public verifyCode(orderingAccessToken: string, phoneCodeVerificationDto: PhoneCodeVerificationDto, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).verifyCode(orderingAccessToken, phoneCodeVerificationDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BusinessApi - axios parameter creator
 * @export
 */
export const BusinessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create single business permission
         * @param {string} businessId 
         * @param {PermissionDto} permissionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessPermission: async (businessId: string, permissionDto: PermissionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('createBusinessPermission', 'businessId', businessId)
            // verify required parameter 'permissionDto' is not null or undefined
            assertParamExists('createBusinessPermission', 'permissionDto', permissionDto)
            const localVarPath = `/api/v1/business/{businessId}/permissions`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(permissionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete business permission
         * @param {string} permissionId 
         * @param {any} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBusinessPermission: async (permissionId: string, businessId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('deleteBusinessPermission', 'permissionId', permissionId)
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('deleteBusinessPermission', 'businessId', businessId)
            const localVarPath = `/api/v1/business/{businessId}/permissions/{permissionId}`
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)))
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId 
         * @param {BusinessCategoryBodyDto} businessCategoryBodyDto Exmaple body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessCategoriesByMenuId: async (businessId: string, businessCategoryBodyDto: BusinessCategoryBodyDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getBusinessCategoriesByMenuId', 'businessId', businessId)
            // verify required parameter 'businessCategoryBodyDto' is not null or undefined
            assertParamExists('getBusinessCategoriesByMenuId', 'businessCategoryBodyDto', businessCategoryBodyDto)
            const localVarPath = `/api/v1/business/{businessId}/menu/categories`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(businessCategoryBodyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get business menu categories V2
         * @param {string} businessId 
         * @param {BusinessCategoryBodyDto} businessCategoryBodyDto Exmaple body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessCategoriesByMenuIdV2: async (businessId: string, businessCategoryBodyDto: BusinessCategoryBodyDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getBusinessCategoriesByMenuIdV2', 'businessId', businessId)
            // verify required parameter 'businessCategoryBodyDto' is not null or undefined
            assertParamExists('getBusinessCategoriesByMenuIdV2', 'businessCategoryBodyDto', businessCategoryBodyDto)
            const localVarPath = `/api/v2/business/{businessId}/menu/categories`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(businessCategoryBodyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {string} [lang] Language code (default is \&quot;en\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessConfig: async (businessId: string, lang?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getBusinessConfig', 'businessId', businessId)
            const localVarPath = `/api/v1/business/{businessId}/configs`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {string} [lang] Language code (default is \&quot;en\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessConfigById: async (businessId: string, lang?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getBusinessConfigById', 'businessId', businessId)
            const localVarPath = `/api/v1/business/{businessId}/external/configs`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} businessId Id of the business
         * @param {string} [lang] Language code (default is \&quot;en\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessConfigByIdV2: async (businessId: string, lang?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getBusinessConfigByIdV2', 'businessId', businessId)
            const localVarPath = `/api/v2/business/{businessId}/external/configs`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {string} [lang] Language code (default is \&quot;en\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessConfiguration: async (businessId: string, lang?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getBusinessConfiguration', 'businessId', businessId)
            const localVarPath = `/api/v1/business/{businessId}/internal/configs`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId 
         * @param {'pos' | 'kiosk'} menuType Type of menu (e.g., pos)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessMenuByType: async (businessId: string, menuType: 'pos' | 'kiosk', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getBusinessMenuByType', 'businessId', businessId)
            // verify required parameter 'menuType' is not null or undefined
            assertParamExists('getBusinessMenuByType', 'menuType', menuType)
            const localVarPath = `/api/v1/business/{businessId}/menu/{menuType}`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)))
                .replace(`{${"menuType"}}`, encodeURIComponent(String(menuType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get business menu by type V2
         * @param {string} businessId 
         * @param {'pos' | 'kiosk'} menuType Type of menu (e.g., pos)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessMenuByTypeV2: async (businessId: string, menuType: 'pos' | 'kiosk', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getBusinessMenuByTypeV2', 'businessId', businessId)
            // verify required parameter 'menuType' is not null or undefined
            assertParamExists('getBusinessMenuByTypeV2', 'menuType', menuType)
            const localVarPath = `/api/v2/business/{businessId}/menu/{menuType}`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)))
                .replace(`{${"menuType"}}`, encodeURIComponent(String(menuType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get business menu by type V3
         * @param {string} businessId 
         * @param {'pos' | 'kiosk'} menuType Type of menu (e.g., pos)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessMenuByTypeV3: async (businessId: string, menuType: 'pos' | 'kiosk', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getBusinessMenuByTypeV3', 'businessId', businessId)
            // verify required parameter 'menuType' is not null or undefined
            assertParamExists('getBusinessMenuByTypeV3', 'menuType', menuType)
            const localVarPath = `/api/v3/business/{businessId}/menu/{menuType}`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)))
                .replace(`{${"menuType"}}`, encodeURIComponent(String(menuType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessProviderStatus: async (businessId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getBusinessProviderStatus', 'businessId', businessId)
            const localVarPath = `/api/v1/business/{businessId}/provider/status`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {ProviderEnum} [channel] Channel like Wolt, Foodora, etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessProviderStatusExternal: async (businessId: string, channel?: ProviderEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getBusinessProviderStatusExternal', 'businessId', businessId)
            const localVarPath = `/api/v1/business/{businessId}/provider/status/external`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessTax: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/business/tax`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {ProviderEnum} provider The provider channel like Wolt, Foodora, etc.
         * @param {string} externalId The external identifier for the provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleBusinessProviderStatus: async (businessId: string, provider: ProviderEnum, externalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getSingleBusinessProviderStatus', 'businessId', businessId)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('getSingleBusinessProviderStatus', 'provider', provider)
            // verify required parameter 'externalId' is not null or undefined
            assertParamExists('getSingleBusinessProviderStatus', 'externalId', externalId)
            const localVarPath = `/api/v1/business/{businessId}/{provider}/{externalId}/status`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)))
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)))
                .replace(`{${"externalId"}}`, encodeURIComponent(String(externalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnifiedDiscounts: async (businessId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getUnifiedDiscounts', 'businessId', businessId)
            const localVarPath = `/api/v1/business/{businessId}/discount`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {BusinessStatusDto} businessStatusDto Update business status body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBusinessStatus: async (businessId: string, businessStatusDto: BusinessStatusDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('setBusinessStatus', 'businessId', businessId)
            // verify required parameter 'businessStatusDto' is not null or undefined
            assertParamExists('setBusinessStatus', 'businessStatusDto', businessStatusDto)
            const localVarPath = `/api/v1/business/{businessId}/status`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(businessStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} businessId 
         * @param {BusinessStatusDto} businessStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBusinessStatusSchedule: async (businessId: number, businessStatusDto: BusinessStatusDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('setBusinessStatusSchedule', 'businessId', businessId)
            // verify required parameter 'businessStatusDto' is not null or undefined
            assertParamExists('setBusinessStatusSchedule', 'businessStatusDto', businessStatusDto)
            const localVarPath = `/api/v1/business/{businessId}/status/schedule`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(businessStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update single business permission
         * @param {string} permissionId 
         * @param {any} businessId 
         * @param {UpdatePermissionDto} updatePermissionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBusinessPermission: async (permissionId: string, businessId: any, updatePermissionDto: UpdatePermissionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('updateBusinessPermission', 'permissionId', permissionId)
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('updateBusinessPermission', 'businessId', businessId)
            // verify required parameter 'updatePermissionDto' is not null or undefined
            assertParamExists('updateBusinessPermission', 'updatePermissionDto', updatePermissionDto)
            const localVarPath = `/api/v1/business/{businessId}/permissions/{permissionId}`
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)))
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePermissionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateBusiness: async (businessId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('validateBusiness', 'businessId', businessId)
            const localVarPath = `/api/v1/business/{businessId}/validate`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BusinessApi - functional programming interface
 * @export
 */
export const BusinessApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BusinessApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create single business permission
         * @param {string} businessId 
         * @param {PermissionDto} permissionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBusinessPermission(businessId: string, permissionDto: PermissionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessPermissionResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBusinessPermission(businessId, permissionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete business permission
         * @param {string} permissionId 
         * @param {any} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBusinessPermission(permissionId: string, businessId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBusinessPermission(permissionId, businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId 
         * @param {BusinessCategoryBodyDto} businessCategoryBodyDto Exmaple body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessCategoriesByMenuId(businessId: string, businessCategoryBodyDto: BusinessCategoryBodyDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CategoryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessCategoriesByMenuId(businessId, businessCategoryBodyDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get business menu categories V2
         * @param {string} businessId 
         * @param {BusinessCategoryBodyDto} businessCategoryBodyDto Exmaple body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessCategoriesByMenuIdV2(businessId: string, businessCategoryBodyDto: BusinessCategoryBodyDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExtendedCategoryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessCategoriesByMenuIdV2(businessId, businessCategoryBodyDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {string} [lang] Language code (default is \&quot;en\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessConfig(businessId: string, lang?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessConfigResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessConfig(businessId, lang, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {string} [lang] Language code (default is \&quot;en\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessConfigById(businessId: string, lang?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalBusinessConfigResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessConfigById(businessId, lang, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {string} businessId Id of the business
         * @param {string} [lang] Language code (default is \&quot;en\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessConfigByIdV2(businessId: string, lang?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessConfigByIdV2(businessId, lang, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {string} [lang] Language code (default is \&quot;en\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessConfiguration(businessId: string, lang?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessConfigResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessConfiguration(businessId, lang, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId 
         * @param {'pos' | 'kiosk'} menuType Type of menu (e.g., pos)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessMenuByType(businessId: string, menuType: 'pos' | 'kiosk', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MenuDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessMenuByType(businessId, menuType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get business menu by type V2
         * @param {string} businessId 
         * @param {'pos' | 'kiosk'} menuType Type of menu (e.g., pos)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessMenuByTypeV2(businessId: string, menuType: 'pos' | 'kiosk', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MenuDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessMenuByTypeV2(businessId, menuType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get business menu by type V3
         * @param {string} businessId 
         * @param {'pos' | 'kiosk'} menuType Type of menu (e.g., pos)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessMenuByTypeV3(businessId: string, menuType: 'pos' | 'kiosk', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuReponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessMenuByTypeV3(businessId, menuType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessProviderStatus(businessId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProviderStatusResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessProviderStatus(businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {ProviderEnum} [channel] Channel like Wolt, Foodora, etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessProviderStatusExternal(businessId: string, channel?: ProviderEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProviderStatusResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessProviderStatusExternal(businessId, channel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessTax(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BusinessTaxResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessTax(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {ProviderEnum} provider The provider channel like Wolt, Foodora, etc.
         * @param {string} externalId The external identifier for the provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleBusinessProviderStatus(businessId: string, provider: ProviderEnum, externalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SingleProviderStatusResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleBusinessProviderStatus(businessId, provider, externalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnifiedDiscounts(businessId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnifiedDiscountsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnifiedDiscounts(businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {BusinessStatusDto} businessStatusDto Update business status body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setBusinessStatus(businessId: string, businessStatusDto: BusinessStatusDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateStatusResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setBusinessStatus(businessId, businessStatusDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} businessId 
         * @param {BusinessStatusDto} businessStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setBusinessStatusSchedule(businessId: number, businessStatusDto: BusinessStatusDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setBusinessStatusSchedule(businessId, businessStatusDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update single business permission
         * @param {string} permissionId 
         * @param {any} businessId 
         * @param {UpdatePermissionDto} updatePermissionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBusinessPermission(permissionId: string, businessId: any, updatePermissionDto: UpdatePermissionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessPermissionResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBusinessPermission(permissionId, businessId, updatePermissionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateBusiness(businessId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessValidationResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateBusiness(businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BusinessApi - factory interface
 * @export
 */
export const BusinessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BusinessApiFp(configuration)
    return {
        /**
         * 
         * @summary Create single business permission
         * @param {string} businessId 
         * @param {PermissionDto} permissionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessPermission(businessId: string, permissionDto: PermissionDto, options?: any): AxiosPromise<BusinessPermissionResponseDto> {
            return localVarFp.createBusinessPermission(businessId, permissionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete business permission
         * @param {string} permissionId 
         * @param {any} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBusinessPermission(permissionId: string, businessId: any, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBusinessPermission(permissionId, businessId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId 
         * @param {BusinessCategoryBodyDto} businessCategoryBodyDto Exmaple body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessCategoriesByMenuId(businessId: string, businessCategoryBodyDto: BusinessCategoryBodyDto, options?: any): AxiosPromise<Array<CategoryDto>> {
            return localVarFp.getBusinessCategoriesByMenuId(businessId, businessCategoryBodyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get business menu categories V2
         * @param {string} businessId 
         * @param {BusinessCategoryBodyDto} businessCategoryBodyDto Exmaple body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessCategoriesByMenuIdV2(businessId: string, businessCategoryBodyDto: BusinessCategoryBodyDto, options?: any): AxiosPromise<Array<ExtendedCategoryDto>> {
            return localVarFp.getBusinessCategoriesByMenuIdV2(businessId, businessCategoryBodyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {string} [lang] Language code (default is \&quot;en\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessConfig(businessId: string, lang?: string, options?: any): AxiosPromise<BusinessConfigResponseDto> {
            return localVarFp.getBusinessConfig(businessId, lang, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {string} [lang] Language code (default is \&quot;en\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessConfigById(businessId: string, lang?: string, options?: any): AxiosPromise<ExternalBusinessConfigResponseDto> {
            return localVarFp.getBusinessConfigById(businessId, lang, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} businessId Id of the business
         * @param {string} [lang] Language code (default is \&quot;en\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessConfigByIdV2(businessId: string, lang?: string, options?: any): AxiosPromise<BusinessResponseDto> {
            return localVarFp.getBusinessConfigByIdV2(businessId, lang, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {string} [lang] Language code (default is \&quot;en\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessConfiguration(businessId: string, lang?: string, options?: any): AxiosPromise<BusinessConfigResponseDto> {
            return localVarFp.getBusinessConfiguration(businessId, lang, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId 
         * @param {'pos' | 'kiosk'} menuType Type of menu (e.g., pos)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessMenuByType(businessId: string, menuType: 'pos' | 'kiosk', options?: any): AxiosPromise<Array<MenuDto>> {
            return localVarFp.getBusinessMenuByType(businessId, menuType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get business menu by type V2
         * @param {string} businessId 
         * @param {'pos' | 'kiosk'} menuType Type of menu (e.g., pos)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessMenuByTypeV2(businessId: string, menuType: 'pos' | 'kiosk', options?: any): AxiosPromise<Array<MenuDto>> {
            return localVarFp.getBusinessMenuByTypeV2(businessId, menuType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get business menu by type V3
         * @param {string} businessId 
         * @param {'pos' | 'kiosk'} menuType Type of menu (e.g., pos)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessMenuByTypeV3(businessId: string, menuType: 'pos' | 'kiosk', options?: any): AxiosPromise<MenuReponseDto> {
            return localVarFp.getBusinessMenuByTypeV3(businessId, menuType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessProviderStatus(businessId: string, options?: any): AxiosPromise<Array<ProviderStatusResponseDto>> {
            return localVarFp.getBusinessProviderStatus(businessId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {ProviderEnum} [channel] Channel like Wolt, Foodora, etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessProviderStatusExternal(businessId: string, channel?: ProviderEnum, options?: any): AxiosPromise<Array<ProviderStatusResponseDto>> {
            return localVarFp.getBusinessProviderStatusExternal(businessId, channel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessTax(options?: any): AxiosPromise<Array<BusinessTaxResponseDto>> {
            return localVarFp.getBusinessTax(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {ProviderEnum} provider The provider channel like Wolt, Foodora, etc.
         * @param {string} externalId The external identifier for the provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleBusinessProviderStatus(businessId: string, provider: ProviderEnum, externalId: string, options?: any): AxiosPromise<SingleProviderStatusResponseDto> {
            return localVarFp.getSingleBusinessProviderStatus(businessId, provider, externalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnifiedDiscounts(businessId: string, options?: any): AxiosPromise<UnifiedDiscountsResponseDto> {
            return localVarFp.getUnifiedDiscounts(businessId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {BusinessStatusDto} businessStatusDto Update business status body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBusinessStatus(businessId: string, businessStatusDto: BusinessStatusDto, options?: any): AxiosPromise<UpdateStatusResponseDto> {
            return localVarFp.setBusinessStatus(businessId, businessStatusDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} businessId 
         * @param {BusinessStatusDto} businessStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBusinessStatusSchedule(businessId: number, businessStatusDto: BusinessStatusDto, options?: any): AxiosPromise<void> {
            return localVarFp.setBusinessStatusSchedule(businessId, businessStatusDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update single business permission
         * @param {string} permissionId 
         * @param {any} businessId 
         * @param {UpdatePermissionDto} updatePermissionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBusinessPermission(permissionId: string, businessId: any, updatePermissionDto: UpdatePermissionDto, options?: any): AxiosPromise<BusinessPermissionResponseDto> {
            return localVarFp.updateBusinessPermission(permissionId, businessId, updatePermissionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId Id of the business
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateBusiness(businessId: string, options?: any): AxiosPromise<BusinessValidationResponseDto> {
            return localVarFp.validateBusiness(businessId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BusinessApi - interface
 * @export
 * @interface BusinessApi
 */
export interface BusinessApiInterface {
    /**
     * 
     * @summary Create single business permission
     * @param {string} businessId 
     * @param {PermissionDto} permissionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    createBusinessPermission(businessId: string, permissionDto: PermissionDto, options?: AxiosRequestConfig): AxiosPromise<BusinessPermissionResponseDto>;

    /**
     * 
     * @summary Delete business permission
     * @param {string} permissionId 
     * @param {any} businessId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    deleteBusinessPermission(permissionId: string, businessId: any, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} businessId 
     * @param {BusinessCategoryBodyDto} businessCategoryBodyDto Exmaple body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    getBusinessCategoriesByMenuId(businessId: string, businessCategoryBodyDto: BusinessCategoryBodyDto, options?: AxiosRequestConfig): AxiosPromise<Array<CategoryDto>>;

    /**
     * 
     * @summary Get business menu categories V2
     * @param {string} businessId 
     * @param {BusinessCategoryBodyDto} businessCategoryBodyDto Exmaple body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    getBusinessCategoriesByMenuIdV2(businessId: string, businessCategoryBodyDto: BusinessCategoryBodyDto, options?: AxiosRequestConfig): AxiosPromise<Array<ExtendedCategoryDto>>;

    /**
     * 
     * @param {string} businessId Id of the business
     * @param {string} [lang] Language code (default is \&quot;en\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    getBusinessConfig(businessId: string, lang?: string, options?: AxiosRequestConfig): AxiosPromise<BusinessConfigResponseDto>;

    /**
     * 
     * @param {string} businessId Id of the business
     * @param {string} [lang] Language code (default is \&quot;en\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    getBusinessConfigById(businessId: string, lang?: string, options?: AxiosRequestConfig): AxiosPromise<ExternalBusinessConfigResponseDto>;

    /**
     * 
     * @summary 
     * @param {string} businessId Id of the business
     * @param {string} [lang] Language code (default is \&quot;en\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    getBusinessConfigByIdV2(businessId: string, lang?: string, options?: AxiosRequestConfig): AxiosPromise<BusinessResponseDto>;

    /**
     * 
     * @param {string} businessId Id of the business
     * @param {string} [lang] Language code (default is \&quot;en\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    getBusinessConfiguration(businessId: string, lang?: string, options?: AxiosRequestConfig): AxiosPromise<BusinessConfigResponseDto>;

    /**
     * 
     * @param {string} businessId 
     * @param {'pos' | 'kiosk'} menuType Type of menu (e.g., pos)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    getBusinessMenuByType(businessId: string, menuType: 'pos' | 'kiosk', options?: AxiosRequestConfig): AxiosPromise<Array<MenuDto>>;

    /**
     * 
     * @summary Get business menu by type V2
     * @param {string} businessId 
     * @param {'pos' | 'kiosk'} menuType Type of menu (e.g., pos)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    getBusinessMenuByTypeV2(businessId: string, menuType: 'pos' | 'kiosk', options?: AxiosRequestConfig): AxiosPromise<Array<MenuDto>>;

    /**
     * 
     * @summary Get business menu by type V3
     * @param {string} businessId 
     * @param {'pos' | 'kiosk'} menuType Type of menu (e.g., pos)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    getBusinessMenuByTypeV3(businessId: string, menuType: 'pos' | 'kiosk', options?: AxiosRequestConfig): AxiosPromise<MenuReponseDto>;

    /**
     * 
     * @param {string} businessId Id of the business
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    getBusinessProviderStatus(businessId: string, options?: AxiosRequestConfig): AxiosPromise<Array<ProviderStatusResponseDto>>;

    /**
     * 
     * @param {string} businessId Id of the business
     * @param {ProviderEnum} [channel] Channel like Wolt, Foodora, etc.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    getBusinessProviderStatusExternal(businessId: string, channel?: ProviderEnum, options?: AxiosRequestConfig): AxiosPromise<Array<ProviderStatusResponseDto>>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    getBusinessTax(options?: AxiosRequestConfig): AxiosPromise<Array<BusinessTaxResponseDto>>;

    /**
     * 
     * @param {string} businessId Id of the business
     * @param {ProviderEnum} provider The provider channel like Wolt, Foodora, etc.
     * @param {string} externalId The external identifier for the provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    getSingleBusinessProviderStatus(businessId: string, provider: ProviderEnum, externalId: string, options?: AxiosRequestConfig): AxiosPromise<SingleProviderStatusResponseDto>;

    /**
     * 
     * @param {string} businessId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    getUnifiedDiscounts(businessId: string, options?: AxiosRequestConfig): AxiosPromise<UnifiedDiscountsResponseDto>;

    /**
     * 
     * @param {string} businessId Id of the business
     * @param {BusinessStatusDto} businessStatusDto Update business status body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    setBusinessStatus(businessId: string, businessStatusDto: BusinessStatusDto, options?: AxiosRequestConfig): AxiosPromise<UpdateStatusResponseDto>;

    /**
     * 
     * @param {number} businessId 
     * @param {BusinessStatusDto} businessStatusDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    setBusinessStatusSchedule(businessId: number, businessStatusDto: BusinessStatusDto, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Update single business permission
     * @param {string} permissionId 
     * @param {any} businessId 
     * @param {UpdatePermissionDto} updatePermissionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    updateBusinessPermission(permissionId: string, businessId: any, updatePermissionDto: UpdatePermissionDto, options?: AxiosRequestConfig): AxiosPromise<BusinessPermissionResponseDto>;

    /**
     * 
     * @param {string} businessId Id of the business
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApiInterface
     */
    validateBusiness(businessId: string, options?: AxiosRequestConfig): AxiosPromise<BusinessValidationResponseDto>;

}

/**
 * BusinessApi - object-oriented interface
 * @export
 * @class BusinessApi
 * @extends {BaseAPI}
 */
export class BusinessApi extends BaseAPI implements BusinessApiInterface {
    /**
     * 
     * @summary Create single business permission
     * @param {string} businessId 
     * @param {PermissionDto} permissionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public createBusinessPermission(businessId: string, permissionDto: PermissionDto, options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).createBusinessPermission(businessId, permissionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete business permission
     * @param {string} permissionId 
     * @param {any} businessId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public deleteBusinessPermission(permissionId: string, businessId: any, options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).deleteBusinessPermission(permissionId, businessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId 
     * @param {BusinessCategoryBodyDto} businessCategoryBodyDto Exmaple body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public getBusinessCategoriesByMenuId(businessId: string, businessCategoryBodyDto: BusinessCategoryBodyDto, options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).getBusinessCategoriesByMenuId(businessId, businessCategoryBodyDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get business menu categories V2
     * @param {string} businessId 
     * @param {BusinessCategoryBodyDto} businessCategoryBodyDto Exmaple body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public getBusinessCategoriesByMenuIdV2(businessId: string, businessCategoryBodyDto: BusinessCategoryBodyDto, options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).getBusinessCategoriesByMenuIdV2(businessId, businessCategoryBodyDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId Id of the business
     * @param {string} [lang] Language code (default is \&quot;en\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public getBusinessConfig(businessId: string, lang?: string, options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).getBusinessConfig(businessId, lang, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId Id of the business
     * @param {string} [lang] Language code (default is \&quot;en\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public getBusinessConfigById(businessId: string, lang?: string, options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).getBusinessConfigById(businessId, lang, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} businessId Id of the business
     * @param {string} [lang] Language code (default is \&quot;en\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public getBusinessConfigByIdV2(businessId: string, lang?: string, options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).getBusinessConfigByIdV2(businessId, lang, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId Id of the business
     * @param {string} [lang] Language code (default is \&quot;en\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public getBusinessConfiguration(businessId: string, lang?: string, options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).getBusinessConfiguration(businessId, lang, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId 
     * @param {'pos' | 'kiosk'} menuType Type of menu (e.g., pos)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public getBusinessMenuByType(businessId: string, menuType: 'pos' | 'kiosk', options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).getBusinessMenuByType(businessId, menuType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get business menu by type V2
     * @param {string} businessId 
     * @param {'pos' | 'kiosk'} menuType Type of menu (e.g., pos)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public getBusinessMenuByTypeV2(businessId: string, menuType: 'pos' | 'kiosk', options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).getBusinessMenuByTypeV2(businessId, menuType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get business menu by type V3
     * @param {string} businessId 
     * @param {'pos' | 'kiosk'} menuType Type of menu (e.g., pos)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public getBusinessMenuByTypeV3(businessId: string, menuType: 'pos' | 'kiosk', options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).getBusinessMenuByTypeV3(businessId, menuType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId Id of the business
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public getBusinessProviderStatus(businessId: string, options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).getBusinessProviderStatus(businessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId Id of the business
     * @param {ProviderEnum} [channel] Channel like Wolt, Foodora, etc.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public getBusinessProviderStatusExternal(businessId: string, channel?: ProviderEnum, options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).getBusinessProviderStatusExternal(businessId, channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public getBusinessTax(options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).getBusinessTax(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId Id of the business
     * @param {ProviderEnum} provider The provider channel like Wolt, Foodora, etc.
     * @param {string} externalId The external identifier for the provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public getSingleBusinessProviderStatus(businessId: string, provider: ProviderEnum, externalId: string, options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).getSingleBusinessProviderStatus(businessId, provider, externalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public getUnifiedDiscounts(businessId: string, options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).getUnifiedDiscounts(businessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId Id of the business
     * @param {BusinessStatusDto} businessStatusDto Update business status body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public setBusinessStatus(businessId: string, businessStatusDto: BusinessStatusDto, options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).setBusinessStatus(businessId, businessStatusDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} businessId 
     * @param {BusinessStatusDto} businessStatusDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public setBusinessStatusSchedule(businessId: number, businessStatusDto: BusinessStatusDto, options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).setBusinessStatusSchedule(businessId, businessStatusDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update single business permission
     * @param {string} permissionId 
     * @param {any} businessId 
     * @param {UpdatePermissionDto} updatePermissionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public updateBusinessPermission(permissionId: string, businessId: any, updatePermissionDto: UpdatePermissionDto, options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).updateBusinessPermission(permissionId, businessId, updatePermissionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId Id of the business
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public validateBusiness(businessId: string, options?: AxiosRequestConfig) {
        return BusinessApiFp(this.configuration).validateBusiness(businessId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CashManagementApi - axios parameter creator
 * @export
 */
export const CashManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} businessId 
         * @param {CashSessionDto} cashSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (businessId: string, cashSessionDto: CashSessionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('create', 'businessId', businessId)
            // verify required parameter 'cashSessionDto' is not null or undefined
            assertParamExists('create', 'cashSessionDto', cashSessionDto)
            const localVarPath = `/api/v1/cash-management/{businessId}/create`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cashSessionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCashSession: async (businessId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getCashSession', 'businessId', businessId)
            const localVarPath = `/api/v1/cash-management/{businessId}/active-session`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId 
         * @param {CashLogDto} cashLogDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordCashLog: async (businessId: string, cashLogDto: CashLogDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('recordCashLog', 'businessId', businessId)
            // verify required parameter 'cashLogDto' is not null or undefined
            assertParamExists('recordCashLog', 'cashLogDto', cashLogDto)
            const localVarPath = `/api/v1/cash-management/{businessId}/log`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cashLogDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CashManagementApi - functional programming interface
 * @export
 */
export const CashManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CashManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} businessId 
         * @param {CashSessionDto} cashSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(businessId: string, cashSessionDto: CashSessionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashSessionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(businessId, cashSessionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCashSession(businessId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashSessionResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCashSession(businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId 
         * @param {CashLogDto} cashLogDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordCashLog(businessId: string, cashLogDto: CashLogDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashLogDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordCashLog(businessId, cashLogDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CashManagementApi - factory interface
 * @export
 */
export const CashManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CashManagementApiFp(configuration)
    return {
        /**
         * 
         * @param {string} businessId 
         * @param {CashSessionDto} cashSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(businessId: string, cashSessionDto: CashSessionDto, options?: any): AxiosPromise<CashSessionDto> {
            return localVarFp.create(businessId, cashSessionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCashSession(businessId: string, options?: any): AxiosPromise<CashSessionResponseDto> {
            return localVarFp.getCashSession(businessId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId 
         * @param {CashLogDto} cashLogDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordCashLog(businessId: string, cashLogDto: CashLogDto, options?: any): AxiosPromise<CashLogDto> {
            return localVarFp.recordCashLog(businessId, cashLogDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CashManagementApi - interface
 * @export
 * @interface CashManagementApi
 */
export interface CashManagementApiInterface {
    /**
     * 
     * @param {string} businessId 
     * @param {CashSessionDto} cashSessionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashManagementApiInterface
     */
    create(businessId: string, cashSessionDto: CashSessionDto, options?: AxiosRequestConfig): AxiosPromise<CashSessionDto>;

    /**
     * 
     * @param {string} businessId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashManagementApiInterface
     */
    getCashSession(businessId: string, options?: AxiosRequestConfig): AxiosPromise<CashSessionResponseDto>;

    /**
     * 
     * @param {string} businessId 
     * @param {CashLogDto} cashLogDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashManagementApiInterface
     */
    recordCashLog(businessId: string, cashLogDto: CashLogDto, options?: AxiosRequestConfig): AxiosPromise<CashLogDto>;

}

/**
 * CashManagementApi - object-oriented interface
 * @export
 * @class CashManagementApi
 * @extends {BaseAPI}
 */
export class CashManagementApi extends BaseAPI implements CashManagementApiInterface {
    /**
     * 
     * @param {string} businessId 
     * @param {CashSessionDto} cashSessionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashManagementApi
     */
    public create(businessId: string, cashSessionDto: CashSessionDto, options?: AxiosRequestConfig) {
        return CashManagementApiFp(this.configuration).create(businessId, cashSessionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashManagementApi
     */
    public getCashSession(businessId: string, options?: AxiosRequestConfig) {
        return CashManagementApiFp(this.configuration).getCashSession(businessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId 
     * @param {CashLogDto} cashLogDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashManagementApi
     */
    public recordCashLog(businessId: string, cashLogDto: CashLogDto, options?: AxiosRequestConfig) {
        return CashManagementApiFp(this.configuration).recordCashLog(businessId, cashLogDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EmployeesApi - axios parameter creator
 * @export
 */
export const EmployeesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} businessId 
         * @param {CreateEmployeeAssignmentDto} createEmployeeAssignmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssignment: async (businessId: number, createEmployeeAssignmentDto: CreateEmployeeAssignmentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('createAssignment', 'businessId', businessId)
            // verify required parameter 'createEmployeeAssignmentDto' is not null or undefined
            assertParamExists('createAssignment', 'createEmployeeAssignmentDto', createEmployeeAssignmentDto)
            const localVarPath = `/api/v1/businesses/{businessId}/assignments`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEmployeeAssignmentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateEmployeeDto} createEmployeeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmployee: async (createEmployeeDto: CreateEmployeeDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEmployeeDto' is not null or undefined
            assertParamExists('createEmployee', 'createEmployeeDto', createEmployeeDto)
            const localVarPath = `/api/v1/employees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEmployeeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} merchantId 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmployees: async (merchantId: string, limit?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'merchantId' is not null or undefined
            assertParamExists('getEmployees', 'merchantId', merchantId)
            const localVarPath = `/api/v1/employees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (merchantId !== undefined) {
                localVarQueryParameter['merchantId'] = merchantId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmployeesApi - functional programming interface
 * @export
 */
export const EmployeesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmployeesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} businessId 
         * @param {CreateEmployeeAssignmentDto} createEmployeeAssignmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAssignment(businessId: number, createEmployeeAssignmentDto: CreateEmployeeAssignmentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeAssignmentResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAssignment(businessId, createEmployeeAssignmentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateEmployeeDto} createEmployeeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmployee(createEmployeeDto: CreateEmployeeDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEmployee(createEmployeeDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} merchantId 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmployees(merchantId: string, limit?: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedEmployeesResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmployees(merchantId, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EmployeesApi - factory interface
 * @export
 */
export const EmployeesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmployeesApiFp(configuration)
    return {
        /**
         * 
         * @param {number} businessId 
         * @param {CreateEmployeeAssignmentDto} createEmployeeAssignmentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssignment(businessId: number, createEmployeeAssignmentDto: CreateEmployeeAssignmentDto, options?: any): AxiosPromise<EmployeeAssignmentResponseDto> {
            return localVarFp.createAssignment(businessId, createEmployeeAssignmentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateEmployeeDto} createEmployeeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmployee(createEmployeeDto: CreateEmployeeDto, options?: any): AxiosPromise<EmployeeResponseDto> {
            return localVarFp.createEmployee(createEmployeeDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} merchantId 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmployees(merchantId: string, limit?: number, page?: number, options?: any): AxiosPromise<PaginatedEmployeesResponseDto> {
            return localVarFp.getEmployees(merchantId, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmployeesApi - interface
 * @export
 * @interface EmployeesApi
 */
export interface EmployeesApiInterface {
    /**
     * 
     * @param {number} businessId 
     * @param {CreateEmployeeAssignmentDto} createEmployeeAssignmentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiInterface
     */
    createAssignment(businessId: number, createEmployeeAssignmentDto: CreateEmployeeAssignmentDto, options?: AxiosRequestConfig): AxiosPromise<EmployeeAssignmentResponseDto>;

    /**
     * 
     * @param {CreateEmployeeDto} createEmployeeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiInterface
     */
    createEmployee(createEmployeeDto: CreateEmployeeDto, options?: AxiosRequestConfig): AxiosPromise<EmployeeResponseDto>;

    /**
     * 
     * @param {string} merchantId 
     * @param {number} [limit] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApiInterface
     */
    getEmployees(merchantId: string, limit?: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedEmployeesResponseDto>;

}

/**
 * EmployeesApi - object-oriented interface
 * @export
 * @class EmployeesApi
 * @extends {BaseAPI}
 */
export class EmployeesApi extends BaseAPI implements EmployeesApiInterface {
    /**
     * 
     * @param {number} businessId 
     * @param {CreateEmployeeAssignmentDto} createEmployeeAssignmentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApi
     */
    public createAssignment(businessId: number, createEmployeeAssignmentDto: CreateEmployeeAssignmentDto, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).createAssignment(businessId, createEmployeeAssignmentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateEmployeeDto} createEmployeeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApi
     */
    public createEmployee(createEmployeeDto: CreateEmployeeDto, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).createEmployee(createEmployeeDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} merchantId 
     * @param {number} [limit] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApi
     */
    public getEmployees(merchantId: string, limit?: number, page?: number, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).getEmployees(merchantId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GiftcardApi - axios parameter creator
 * @export
 */
export const GiftcardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Redeem gift card
         * @param {RedeemGiftCardDto} redeemGiftCardDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeemGiftCard: async (redeemGiftCardDto: RedeemGiftCardDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redeemGiftCardDto' is not null or undefined
            assertParamExists('redeemGiftCard', 'redeemGiftCardDto', redeemGiftCardDto)
            const localVarPath = `/api/v1/giftcard/redeem`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(redeemGiftCardDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate gift card
         * @param {ValidateGiftCardDto} validateGiftCardDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateGiftCard: async (validateGiftCardDto: ValidateGiftCardDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validateGiftCardDto' is not null or undefined
            assertParamExists('validateGiftCard', 'validateGiftCardDto', validateGiftCardDto)
            const localVarPath = `/api/v1/giftcard/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validateGiftCardDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GiftcardApi - functional programming interface
 * @export
 */
export const GiftcardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GiftcardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Redeem gift card
         * @param {RedeemGiftCardDto} redeemGiftCardDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeemGiftCard(redeemGiftCardDto: RedeemGiftCardDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RedeemGiftCardResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeemGiftCard(redeemGiftCardDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validate gift card
         * @param {ValidateGiftCardDto} validateGiftCardDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateGiftCard(validateGiftCardDto: ValidateGiftCardDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateGiftCardResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateGiftCard(validateGiftCardDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GiftcardApi - factory interface
 * @export
 */
export const GiftcardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GiftcardApiFp(configuration)
    return {
        /**
         * 
         * @summary Redeem gift card
         * @param {RedeemGiftCardDto} redeemGiftCardDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeemGiftCard(redeemGiftCardDto: RedeemGiftCardDto, options?: any): AxiosPromise<RedeemGiftCardResponseDto> {
            return localVarFp.redeemGiftCard(redeemGiftCardDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate gift card
         * @param {ValidateGiftCardDto} validateGiftCardDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateGiftCard(validateGiftCardDto: ValidateGiftCardDto, options?: any): AxiosPromise<ValidateGiftCardResponseDto> {
            return localVarFp.validateGiftCard(validateGiftCardDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GiftcardApi - interface
 * @export
 * @interface GiftcardApi
 */
export interface GiftcardApiInterface {
    /**
     * 
     * @summary Redeem gift card
     * @param {RedeemGiftCardDto} redeemGiftCardDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftcardApiInterface
     */
    redeemGiftCard(redeemGiftCardDto: RedeemGiftCardDto, options?: AxiosRequestConfig): AxiosPromise<RedeemGiftCardResponseDto>;

    /**
     * 
     * @summary Validate gift card
     * @param {ValidateGiftCardDto} validateGiftCardDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftcardApiInterface
     */
    validateGiftCard(validateGiftCardDto: ValidateGiftCardDto, options?: AxiosRequestConfig): AxiosPromise<ValidateGiftCardResponseDto>;

}

/**
 * GiftcardApi - object-oriented interface
 * @export
 * @class GiftcardApi
 * @extends {BaseAPI}
 */
export class GiftcardApi extends BaseAPI implements GiftcardApiInterface {
    /**
     * 
     * @summary Redeem gift card
     * @param {RedeemGiftCardDto} redeemGiftCardDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftcardApi
     */
    public redeemGiftCard(redeemGiftCardDto: RedeemGiftCardDto, options?: AxiosRequestConfig) {
        return GiftcardApiFp(this.configuration).redeemGiftCard(redeemGiftCardDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate gift card
     * @param {ValidateGiftCardDto} validateGiftCardDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiftcardApi
     */
    public validateGiftCard(validateGiftCardDto: ValidateGiftCardDto, options?: AxiosRequestConfig) {
        return GiftcardApiFp(this.configuration).validateGiftCard(validateGiftCardDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HistoryApi - axios parameter creator
 * @export
 */
export const HistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get order history
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalOrderHistoryOnline: async (businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('getInternalOrderHistoryOnline', 'businessIds', businessIds)
            const localVarPath = `/api/v1/history/internal/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeSpan !== undefined) {
                localVarQueryParameter['timeSpan'] = timeSpan;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (businessIds) {
                localVarQueryParameter['businessIds'] = businessIds;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (rowPerPage !== undefined) {
                localVarQueryParameter['rowPerPage'] = rowPerPage;
            }

            if (provider) {
                localVarQueryParameter['provider'] = provider;
            }

            if (paymentType) {
                localVarQueryParameter['paymentType'] = paymentType;
            }

            if (orderStatus) {
                localVarQueryParameter['orderStatus'] = orderStatus;
            }

            if (paymentStatus) {
                localVarQueryParameter['paymentStatus'] = paymentStatus;
            }

            if (orderType) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (paymentTypePos) {
                localVarQueryParameter['paymentTypePos'] = paymentTypePos;
            }

            if (invoiceCompanyId !== undefined) {
                localVarQueryParameter['invoiceCompanyId'] = invoiceCompanyId;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get order history
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderHistoryOnline: async (businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('getOrderHistoryOnline', 'businessIds', businessIds)
            const localVarPath = `/api/v1/history/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeSpan !== undefined) {
                localVarQueryParameter['timeSpan'] = timeSpan;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (businessIds) {
                localVarQueryParameter['businessIds'] = businessIds;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (rowPerPage !== undefined) {
                localVarQueryParameter['rowPerPage'] = rowPerPage;
            }

            if (provider) {
                localVarQueryParameter['provider'] = provider;
            }

            if (paymentType) {
                localVarQueryParameter['paymentType'] = paymentType;
            }

            if (orderStatus) {
                localVarQueryParameter['orderStatus'] = orderStatus;
            }

            if (paymentStatus) {
                localVarQueryParameter['paymentStatus'] = paymentStatus;
            }

            if (orderType) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (paymentTypePos) {
                localVarQueryParameter['paymentTypePos'] = paymentTypePos;
            }

            if (invoiceCompanyId !== undefined) {
                localVarQueryParameter['invoiceCompanyId'] = invoiceCompanyId;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get order history for POS
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderHistoryPOS: async (businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('getOrderHistoryPOS', 'businessIds', businessIds)
            const localVarPath = `/api/v1/history/orders/pos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeSpan !== undefined) {
                localVarQueryParameter['timeSpan'] = timeSpan;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (businessIds) {
                localVarQueryParameter['businessIds'] = businessIds;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (rowPerPage !== undefined) {
                localVarQueryParameter['rowPerPage'] = rowPerPage;
            }

            if (provider) {
                localVarQueryParameter['provider'] = provider;
            }

            if (paymentType) {
                localVarQueryParameter['paymentType'] = paymentType;
            }

            if (orderStatus) {
                localVarQueryParameter['orderStatus'] = orderStatus;
            }

            if (paymentStatus) {
                localVarQueryParameter['paymentStatus'] = paymentStatus;
            }

            if (orderType) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (paymentTypePos) {
                localVarQueryParameter['paymentTypePos'] = paymentTypePos;
            }

            if (invoiceCompanyId !== undefined) {
                localVarQueryParameter['invoiceCompanyId'] = invoiceCompanyId;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get order history for POS V2
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderHistoryPOSV2: async (businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('getOrderHistoryPOSV2', 'businessIds', businessIds)
            const localVarPath = `/api/v2/history/orders/pos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (timeSpan !== undefined) {
                localVarQueryParameter['timeSpan'] = timeSpan;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (businessIds) {
                localVarQueryParameter['businessIds'] = businessIds;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (rowPerPage !== undefined) {
                localVarQueryParameter['rowPerPage'] = rowPerPage;
            }

            if (provider) {
                localVarQueryParameter['provider'] = provider;
            }

            if (paymentType) {
                localVarQueryParameter['paymentType'] = paymentType;
            }

            if (orderStatus) {
                localVarQueryParameter['orderStatus'] = orderStatus;
            }

            if (paymentStatus) {
                localVarQueryParameter['paymentStatus'] = paymentStatus;
            }

            if (orderType) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (paymentTypePos) {
                localVarQueryParameter['paymentTypePos'] = paymentTypePos;
            }

            if (invoiceCompanyId !== undefined) {
                localVarQueryParameter['invoiceCompanyId'] = invoiceCompanyId;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get order history for POS V3
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderHistoryPOSV3: async (businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('getOrderHistoryPOSV3', 'businessIds', businessIds)
            const localVarPath = `/api/v3/history/orders/pos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (timeSpan !== undefined) {
                localVarQueryParameter['timeSpan'] = timeSpan;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (businessIds) {
                localVarQueryParameter['businessIds'] = businessIds;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (rowPerPage !== undefined) {
                localVarQueryParameter['rowPerPage'] = rowPerPage;
            }

            if (provider) {
                localVarQueryParameter['provider'] = provider;
            }

            if (paymentType) {
                localVarQueryParameter['paymentType'] = paymentType;
            }

            if (orderStatus) {
                localVarQueryParameter['orderStatus'] = orderStatus;
            }

            if (paymentStatus) {
                localVarQueryParameter['paymentStatus'] = paymentStatus;
            }

            if (orderType) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (paymentTypePos) {
                localVarQueryParameter['paymentTypePos'] = paymentTypePos;
            }

            if (invoiceCompanyId !== undefined) {
                localVarQueryParameter['invoiceCompanyId'] = invoiceCompanyId;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get order history for POS V4
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderHistoryPOSV4: async (businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('getOrderHistoryPOSV4', 'businessIds', businessIds)
            const localVarPath = `/api/v4/history/orders/pos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (timeSpan !== undefined) {
                localVarQueryParameter['timeSpan'] = timeSpan;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (businessIds) {
                localVarQueryParameter['businessIds'] = businessIds;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (rowPerPage !== undefined) {
                localVarQueryParameter['rowPerPage'] = rowPerPage;
            }

            if (provider) {
                localVarQueryParameter['provider'] = provider;
            }

            if (paymentType) {
                localVarQueryParameter['paymentType'] = paymentType;
            }

            if (orderStatus) {
                localVarQueryParameter['orderStatus'] = orderStatus;
            }

            if (paymentStatus) {
                localVarQueryParameter['paymentStatus'] = paymentStatus;
            }

            if (orderType) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (paymentTypePos) {
                localVarQueryParameter['paymentTypePos'] = paymentTypePos;
            }

            if (invoiceCompanyId !== undefined) {
                localVarQueryParameter['invoiceCompanyId'] = invoiceCompanyId;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get order history for POS V5
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderHistoryPOSV5: async (businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('getOrderHistoryPOSV5', 'businessIds', businessIds)
            const localVarPath = `/api/v5/history/orders/pos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (timeSpan !== undefined) {
                localVarQueryParameter['timeSpan'] = timeSpan;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (businessIds) {
                localVarQueryParameter['businessIds'] = businessIds;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (rowPerPage !== undefined) {
                localVarQueryParameter['rowPerPage'] = rowPerPage;
            }

            if (provider) {
                localVarQueryParameter['provider'] = provider;
            }

            if (paymentType) {
                localVarQueryParameter['paymentType'] = paymentType;
            }

            if (orderStatus) {
                localVarQueryParameter['orderStatus'] = orderStatus;
            }

            if (paymentStatus) {
                localVarQueryParameter['paymentStatus'] = paymentStatus;
            }

            if (orderType) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (paymentTypePos) {
                localVarQueryParameter['paymentTypePos'] = paymentTypePos;
            }

            if (invoiceCompanyId !== undefined) {
                localVarQueryParameter['invoiceCompanyId'] = invoiceCompanyId;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get order history for POS V5
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderHistoryPOSV5Internal: async (businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('getOrderHistoryPOSV5Internal', 'businessIds', businessIds)
            const localVarPath = `/api/v5/history/internal/orders/pos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (timeSpan !== undefined) {
                localVarQueryParameter['timeSpan'] = timeSpan;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (businessIds) {
                localVarQueryParameter['businessIds'] = businessIds;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (rowPerPage !== undefined) {
                localVarQueryParameter['rowPerPage'] = rowPerPage;
            }

            if (provider) {
                localVarQueryParameter['provider'] = provider;
            }

            if (paymentType) {
                localVarQueryParameter['paymentType'] = paymentType;
            }

            if (orderStatus) {
                localVarQueryParameter['orderStatus'] = orderStatus;
            }

            if (paymentStatus) {
                localVarQueryParameter['paymentStatus'] = paymentStatus;
            }

            if (orderType) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (paymentTypePos) {
                localVarQueryParameter['paymentTypePos'] = paymentTypePos;
            }

            if (invoiceCompanyId !== undefined) {
                localVarQueryParameter['invoiceCompanyId'] = invoiceCompanyId;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HistoryApi - functional programming interface
 * @export
 */
export const HistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get order history
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInternalOrderHistoryOnline(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderHistoryResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInternalOrderHistoryOnline(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get order history
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderHistoryOnline(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderHistoryResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderHistoryOnline(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get order history for POS
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderHistoryPOS(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderHistoryPosResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderHistoryPOS(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get order history for POS V2
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderHistoryPOSV2(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderHistoryPosResponseDtoV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderHistoryPOSV2(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get order history for POS V3
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderHistoryPOSV3(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderHistoryPosResponseDtoV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderHistoryPOSV3(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get order history for POS V4
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderHistoryPOSV4(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderHistoryPosResponseDtoV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderHistoryPOSV4(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get order history for POS V5
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderHistoryPOSV5(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderHistoryPosResponseDtoV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderHistoryPOSV5(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get order history for POS V5
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderHistoryPOSV5Internal(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderHistoryPosResponseDtoV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderHistoryPOSV5Internal(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HistoryApi - factory interface
 * @export
 */
export const HistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HistoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Get order history
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalOrderHistoryOnline(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: any): AxiosPromise<OrderHistoryResponseDto> {
            return localVarFp.getInternalOrderHistoryOnline(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get order history
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderHistoryOnline(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: any): AxiosPromise<OrderHistoryResponseDto> {
            return localVarFp.getOrderHistoryOnline(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get order history for POS
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderHistoryPOS(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: any): AxiosPromise<OrderHistoryPosResponseDto> {
            return localVarFp.getOrderHistoryPOS(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get order history for POS V2
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderHistoryPOSV2(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: any): AxiosPromise<OrderHistoryPosResponseDtoV2> {
            return localVarFp.getOrderHistoryPOSV2(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get order history for POS V3
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderHistoryPOSV3(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: any): AxiosPromise<OrderHistoryPosResponseDtoV2> {
            return localVarFp.getOrderHistoryPOSV3(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get order history for POS V4
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderHistoryPOSV4(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: any): AxiosPromise<OrderHistoryPosResponseDtoV2> {
            return localVarFp.getOrderHistoryPOSV4(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get order history for POS V5
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderHistoryPOSV5(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: any): AxiosPromise<OrderHistoryPosResponseDtoV2> {
            return localVarFp.getOrderHistoryPOSV5(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get order history for POS V5
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {number} [page] Page number
         * @param {number} [rowPerPage] Number of rows per page
         * @param {Array<ProviderEnum>} [provider] Provider
         * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
         * @param {Array<OrderStatusEnum>} [orderStatus] Order status
         * @param {Array<PaymentStatus>} [paymentStatus] Payment status
         * @param {Array<OrderType>} [orderType] Order type
         * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
         * @param {string} [invoiceCompanyId] Filter by invoice company ID
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderHistoryPOSV5Internal(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: any): AxiosPromise<OrderHistoryPosResponseDtoV2> {
            return localVarFp.getOrderHistoryPOSV5Internal(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HistoryApi - interface
 * @export
 * @interface HistoryApi
 */
export interface HistoryApiInterface {
    /**
     * 
     * @summary Get order history
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {number} [page] Page number
     * @param {number} [rowPerPage] Number of rows per page
     * @param {Array<ProviderEnum>} [provider] Provider
     * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
     * @param {Array<OrderStatusEnum>} [orderStatus] Order status
     * @param {Array<PaymentStatus>} [paymentStatus] Payment status
     * @param {Array<OrderType>} [orderType] Order type
     * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
     * @param {string} [invoiceCompanyId] Filter by invoice company ID
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApiInterface
     */
    getInternalOrderHistoryOnline(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig): AxiosPromise<OrderHistoryResponseDto>;

    /**
     * 
     * @summary Get order history
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {number} [page] Page number
     * @param {number} [rowPerPage] Number of rows per page
     * @param {Array<ProviderEnum>} [provider] Provider
     * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
     * @param {Array<OrderStatusEnum>} [orderStatus] Order status
     * @param {Array<PaymentStatus>} [paymentStatus] Payment status
     * @param {Array<OrderType>} [orderType] Order type
     * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
     * @param {string} [invoiceCompanyId] Filter by invoice company ID
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApiInterface
     */
    getOrderHistoryOnline(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig): AxiosPromise<OrderHistoryResponseDto>;

    /**
     * 
     * @summary Get order history for POS
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {number} [page] Page number
     * @param {number} [rowPerPage] Number of rows per page
     * @param {Array<ProviderEnum>} [provider] Provider
     * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
     * @param {Array<OrderStatusEnum>} [orderStatus] Order status
     * @param {Array<PaymentStatus>} [paymentStatus] Payment status
     * @param {Array<OrderType>} [orderType] Order type
     * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
     * @param {string} [invoiceCompanyId] Filter by invoice company ID
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApiInterface
     */
    getOrderHistoryPOS(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig): AxiosPromise<OrderHistoryPosResponseDto>;

    /**
     * 
     * @summary Get order history for POS V2
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {number} [page] Page number
     * @param {number} [rowPerPage] Number of rows per page
     * @param {Array<ProviderEnum>} [provider] Provider
     * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
     * @param {Array<OrderStatusEnum>} [orderStatus] Order status
     * @param {Array<PaymentStatus>} [paymentStatus] Payment status
     * @param {Array<OrderType>} [orderType] Order type
     * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
     * @param {string} [invoiceCompanyId] Filter by invoice company ID
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApiInterface
     */
    getOrderHistoryPOSV2(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig): AxiosPromise<OrderHistoryPosResponseDtoV2>;

    /**
     * 
     * @summary Get order history for POS V3
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {number} [page] Page number
     * @param {number} [rowPerPage] Number of rows per page
     * @param {Array<ProviderEnum>} [provider] Provider
     * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
     * @param {Array<OrderStatusEnum>} [orderStatus] Order status
     * @param {Array<PaymentStatus>} [paymentStatus] Payment status
     * @param {Array<OrderType>} [orderType] Order type
     * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
     * @param {string} [invoiceCompanyId] Filter by invoice company ID
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApiInterface
     */
    getOrderHistoryPOSV3(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig): AxiosPromise<OrderHistoryPosResponseDtoV2>;

    /**
     * 
     * @summary Get order history for POS V4
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {number} [page] Page number
     * @param {number} [rowPerPage] Number of rows per page
     * @param {Array<ProviderEnum>} [provider] Provider
     * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
     * @param {Array<OrderStatusEnum>} [orderStatus] Order status
     * @param {Array<PaymentStatus>} [paymentStatus] Payment status
     * @param {Array<OrderType>} [orderType] Order type
     * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
     * @param {string} [invoiceCompanyId] Filter by invoice company ID
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApiInterface
     */
    getOrderHistoryPOSV4(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig): AxiosPromise<OrderHistoryPosResponseDtoV2>;

    /**
     * 
     * @summary Get order history for POS V5
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {number} [page] Page number
     * @param {number} [rowPerPage] Number of rows per page
     * @param {Array<ProviderEnum>} [provider] Provider
     * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
     * @param {Array<OrderStatusEnum>} [orderStatus] Order status
     * @param {Array<PaymentStatus>} [paymentStatus] Payment status
     * @param {Array<OrderType>} [orderType] Order type
     * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
     * @param {string} [invoiceCompanyId] Filter by invoice company ID
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApiInterface
     */
    getOrderHistoryPOSV5(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig): AxiosPromise<OrderHistoryPosResponseDtoV2>;

    /**
     * 
     * @summary Get order history for POS V5
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {number} [page] Page number
     * @param {number} [rowPerPage] Number of rows per page
     * @param {Array<ProviderEnum>} [provider] Provider
     * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
     * @param {Array<OrderStatusEnum>} [orderStatus] Order status
     * @param {Array<PaymentStatus>} [paymentStatus] Payment status
     * @param {Array<OrderType>} [orderType] Order type
     * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
     * @param {string} [invoiceCompanyId] Filter by invoice company ID
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApiInterface
     */
    getOrderHistoryPOSV5Internal(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig): AxiosPromise<OrderHistoryPosResponseDtoV2>;

}

/**
 * HistoryApi - object-oriented interface
 * @export
 * @class HistoryApi
 * @extends {BaseAPI}
 */
export class HistoryApi extends BaseAPI implements HistoryApiInterface {
    /**
     * 
     * @summary Get order history
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {number} [page] Page number
     * @param {number} [rowPerPage] Number of rows per page
     * @param {Array<ProviderEnum>} [provider] Provider
     * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
     * @param {Array<OrderStatusEnum>} [orderStatus] Order status
     * @param {Array<PaymentStatus>} [paymentStatus] Payment status
     * @param {Array<OrderType>} [orderType] Order type
     * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
     * @param {string} [invoiceCompanyId] Filter by invoice company ID
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getInternalOrderHistoryOnline(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).getInternalOrderHistoryOnline(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get order history
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {number} [page] Page number
     * @param {number} [rowPerPage] Number of rows per page
     * @param {Array<ProviderEnum>} [provider] Provider
     * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
     * @param {Array<OrderStatusEnum>} [orderStatus] Order status
     * @param {Array<PaymentStatus>} [paymentStatus] Payment status
     * @param {Array<OrderType>} [orderType] Order type
     * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
     * @param {string} [invoiceCompanyId] Filter by invoice company ID
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getOrderHistoryOnline(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).getOrderHistoryOnline(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get order history for POS
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {number} [page] Page number
     * @param {number} [rowPerPage] Number of rows per page
     * @param {Array<ProviderEnum>} [provider] Provider
     * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
     * @param {Array<OrderStatusEnum>} [orderStatus] Order status
     * @param {Array<PaymentStatus>} [paymentStatus] Payment status
     * @param {Array<OrderType>} [orderType] Order type
     * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
     * @param {string} [invoiceCompanyId] Filter by invoice company ID
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getOrderHistoryPOS(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).getOrderHistoryPOS(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get order history for POS V2
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {number} [page] Page number
     * @param {number} [rowPerPage] Number of rows per page
     * @param {Array<ProviderEnum>} [provider] Provider
     * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
     * @param {Array<OrderStatusEnum>} [orderStatus] Order status
     * @param {Array<PaymentStatus>} [paymentStatus] Payment status
     * @param {Array<OrderType>} [orderType] Order type
     * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
     * @param {string} [invoiceCompanyId] Filter by invoice company ID
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getOrderHistoryPOSV2(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).getOrderHistoryPOSV2(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get order history for POS V3
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {number} [page] Page number
     * @param {number} [rowPerPage] Number of rows per page
     * @param {Array<ProviderEnum>} [provider] Provider
     * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
     * @param {Array<OrderStatusEnum>} [orderStatus] Order status
     * @param {Array<PaymentStatus>} [paymentStatus] Payment status
     * @param {Array<OrderType>} [orderType] Order type
     * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
     * @param {string} [invoiceCompanyId] Filter by invoice company ID
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getOrderHistoryPOSV3(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).getOrderHistoryPOSV3(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get order history for POS V4
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {number} [page] Page number
     * @param {number} [rowPerPage] Number of rows per page
     * @param {Array<ProviderEnum>} [provider] Provider
     * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
     * @param {Array<OrderStatusEnum>} [orderStatus] Order status
     * @param {Array<PaymentStatus>} [paymentStatus] Payment status
     * @param {Array<OrderType>} [orderType] Order type
     * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
     * @param {string} [invoiceCompanyId] Filter by invoice company ID
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getOrderHistoryPOSV4(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).getOrderHistoryPOSV4(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get order history for POS V5
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {number} [page] Page number
     * @param {number} [rowPerPage] Number of rows per page
     * @param {Array<ProviderEnum>} [provider] Provider
     * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
     * @param {Array<OrderStatusEnum>} [orderStatus] Order status
     * @param {Array<PaymentStatus>} [paymentStatus] Payment status
     * @param {Array<OrderType>} [orderType] Order type
     * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
     * @param {string} [invoiceCompanyId] Filter by invoice company ID
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getOrderHistoryPOSV5(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).getOrderHistoryPOSV5(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get order history for POS V5
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {number} [page] Page number
     * @param {number} [rowPerPage] Number of rows per page
     * @param {Array<ProviderEnum>} [provider] Provider
     * @param {Array<PaymentTypeEnum>} [paymentType] Payment type
     * @param {Array<OrderStatusEnum>} [orderStatus] Order status
     * @param {Array<PaymentStatus>} [paymentStatus] Payment status
     * @param {Array<OrderType>} [orderType] Order type
     * @param {Array<PaymentMethod>} [paymentTypePos] Payment type POS
     * @param {string} [invoiceCompanyId] Filter by invoice company ID
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getOrderHistoryPOSV5Internal(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, page?: number, rowPerPage?: number, provider?: Array<ProviderEnum>, paymentType?: Array<PaymentTypeEnum>, orderStatus?: Array<OrderStatusEnum>, paymentStatus?: Array<PaymentStatus>, orderType?: Array<OrderType>, paymentTypePos?: Array<PaymentMethod>, invoiceCompanyId?: string, timezone?: string, options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).getOrderHistoryPOSV5Internal(businessIds, timeSpan, start, end, page, rowPerPage, provider, paymentType, orderStatus, paymentStatus, orderType, paymentTypePos, invoiceCompanyId, timezone, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvoiceCompaniesApi - axios parameter creator
 * @export
 */
export const InvoiceCompaniesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new invoice company
         * @param {number} businessId 
         * @param {CreateInvoiceCompanyDto} createInvoiceCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceCompany: async (businessId: number, createInvoiceCompanyDto: CreateInvoiceCompanyDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('createInvoiceCompany', 'businessId', businessId)
            // verify required parameter 'createInvoiceCompanyDto' is not null or undefined
            assertParamExists('createInvoiceCompany', 'createInvoiceCompanyDto', createInvoiceCompanyDto)
            const localVarPath = `/api/v1/invoice-companies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (businessId !== undefined) {
                localVarQueryParameter['businessId'] = businessId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createInvoiceCompanyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an invoice company
         * @param {string} id 
         * @param {number} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceCompany: async (id: string, businessId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteInvoiceCompany', 'id', id)
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('deleteInvoiceCompany', 'businessId', businessId)
            const localVarPath = `/api/v1/invoice-companies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (businessId !== undefined) {
                localVarQueryParameter['businessId'] = businessId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all invoice companies for a business
         * @param {number} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceCompanies: async (businessId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getInvoiceCompanies', 'businessId', businessId)
            const localVarPath = `/api/v1/invoice-companies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (businessId !== undefined) {
                localVarQueryParameter['businessId'] = businessId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single invoice company by ID
         * @param {string} id 
         * @param {number} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceCompanyById: async (id: string, businessId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getInvoiceCompanyById', 'id', id)
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getInvoiceCompanyById', 'businessId', businessId)
            const localVarPath = `/api/v1/invoice-companies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (businessId !== undefined) {
                localVarQueryParameter['businessId'] = businessId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search invoice companies by name, email, or ytunnus
         * @param {number} businessId 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInvoiceCompanies: async (businessId: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('searchInvoiceCompanies', 'businessId', businessId)
            const localVarPath = `/api/v1/invoice-companies/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (businessId !== undefined) {
                localVarQueryParameter['businessId'] = businessId;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an invoice company
         * @param {string} id 
         * @param {number} businessId 
         * @param {UpdateInvoiceCompanyDto} updateInvoiceCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoiceCompany: async (id: string, businessId: number, updateInvoiceCompanyDto: UpdateInvoiceCompanyDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateInvoiceCompany', 'id', id)
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('updateInvoiceCompany', 'businessId', businessId)
            // verify required parameter 'updateInvoiceCompanyDto' is not null or undefined
            assertParamExists('updateInvoiceCompany', 'updateInvoiceCompanyDto', updateInvoiceCompanyDto)
            const localVarPath = `/api/v1/invoice-companies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (businessId !== undefined) {
                localVarQueryParameter['businessId'] = businessId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateInvoiceCompanyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceCompaniesApi - functional programming interface
 * @export
 */
export const InvoiceCompaniesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoiceCompaniesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new invoice company
         * @param {number} businessId 
         * @param {CreateInvoiceCompanyDto} createInvoiceCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoiceCompany(businessId: number, createInvoiceCompanyDto: CreateInvoiceCompanyDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceCompanyResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvoiceCompany(businessId, createInvoiceCompanyDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an invoice company
         * @param {string} id 
         * @param {number} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoiceCompany(id: string, businessId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvoiceCompany(id, businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all invoice companies for a business
         * @param {number} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceCompanies(businessId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvoiceCompanyResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceCompanies(businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single invoice company by ID
         * @param {string} id 
         * @param {number} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceCompanyById(id: string, businessId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceCompanyResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceCompanyById(id, businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search invoice companies by name, email, or ytunnus
         * @param {number} businessId 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchInvoiceCompanies(businessId: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvoiceCompanyResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchInvoiceCompanies(businessId, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an invoice company
         * @param {string} id 
         * @param {number} businessId 
         * @param {UpdateInvoiceCompanyDto} updateInvoiceCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInvoiceCompany(id: string, businessId: number, updateInvoiceCompanyDto: UpdateInvoiceCompanyDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceCompanyResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInvoiceCompany(id, businessId, updateInvoiceCompanyDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvoiceCompaniesApi - factory interface
 * @export
 */
export const InvoiceCompaniesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoiceCompaniesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new invoice company
         * @param {number} businessId 
         * @param {CreateInvoiceCompanyDto} createInvoiceCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceCompany(businessId: number, createInvoiceCompanyDto: CreateInvoiceCompanyDto, options?: any): AxiosPromise<InvoiceCompanyResponseDto> {
            return localVarFp.createInvoiceCompany(businessId, createInvoiceCompanyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an invoice company
         * @param {string} id 
         * @param {number} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceCompany(id: string, businessId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteInvoiceCompany(id, businessId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all invoice companies for a business
         * @param {number} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceCompanies(businessId: number, options?: any): AxiosPromise<Array<InvoiceCompanyResponseDto>> {
            return localVarFp.getInvoiceCompanies(businessId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single invoice company by ID
         * @param {string} id 
         * @param {number} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceCompanyById(id: string, businessId: number, options?: any): AxiosPromise<InvoiceCompanyResponseDto> {
            return localVarFp.getInvoiceCompanyById(id, businessId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search invoice companies by name, email, or ytunnus
         * @param {number} businessId 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInvoiceCompanies(businessId: number, search?: string, options?: any): AxiosPromise<Array<InvoiceCompanyResponseDto>> {
            return localVarFp.searchInvoiceCompanies(businessId, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an invoice company
         * @param {string} id 
         * @param {number} businessId 
         * @param {UpdateInvoiceCompanyDto} updateInvoiceCompanyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoiceCompany(id: string, businessId: number, updateInvoiceCompanyDto: UpdateInvoiceCompanyDto, options?: any): AxiosPromise<InvoiceCompanyResponseDto> {
            return localVarFp.updateInvoiceCompany(id, businessId, updateInvoiceCompanyDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoiceCompaniesApi - interface
 * @export
 * @interface InvoiceCompaniesApi
 */
export interface InvoiceCompaniesApiInterface {
    /**
     * 
     * @summary Create a new invoice company
     * @param {number} businessId 
     * @param {CreateInvoiceCompanyDto} createInvoiceCompanyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceCompaniesApiInterface
     */
    createInvoiceCompany(businessId: number, createInvoiceCompanyDto: CreateInvoiceCompanyDto, options?: AxiosRequestConfig): AxiosPromise<InvoiceCompanyResponseDto>;

    /**
     * 
     * @summary Delete an invoice company
     * @param {string} id 
     * @param {number} businessId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceCompaniesApiInterface
     */
    deleteInvoiceCompany(id: string, businessId: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary List all invoice companies for a business
     * @param {number} businessId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceCompaniesApiInterface
     */
    getInvoiceCompanies(businessId: number, options?: AxiosRequestConfig): AxiosPromise<Array<InvoiceCompanyResponseDto>>;

    /**
     * 
     * @summary Get a single invoice company by ID
     * @param {string} id 
     * @param {number} businessId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceCompaniesApiInterface
     */
    getInvoiceCompanyById(id: string, businessId: number, options?: AxiosRequestConfig): AxiosPromise<InvoiceCompanyResponseDto>;

    /**
     * 
     * @summary Search invoice companies by name, email, or ytunnus
     * @param {number} businessId 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceCompaniesApiInterface
     */
    searchInvoiceCompanies(businessId: number, search?: string, options?: AxiosRequestConfig): AxiosPromise<Array<InvoiceCompanyResponseDto>>;

    /**
     * 
     * @summary Update an invoice company
     * @param {string} id 
     * @param {number} businessId 
     * @param {UpdateInvoiceCompanyDto} updateInvoiceCompanyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceCompaniesApiInterface
     */
    updateInvoiceCompany(id: string, businessId: number, updateInvoiceCompanyDto: UpdateInvoiceCompanyDto, options?: AxiosRequestConfig): AxiosPromise<InvoiceCompanyResponseDto>;

}

/**
 * InvoiceCompaniesApi - object-oriented interface
 * @export
 * @class InvoiceCompaniesApi
 * @extends {BaseAPI}
 */
export class InvoiceCompaniesApi extends BaseAPI implements InvoiceCompaniesApiInterface {
    /**
     * 
     * @summary Create a new invoice company
     * @param {number} businessId 
     * @param {CreateInvoiceCompanyDto} createInvoiceCompanyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceCompaniesApi
     */
    public createInvoiceCompany(businessId: number, createInvoiceCompanyDto: CreateInvoiceCompanyDto, options?: AxiosRequestConfig) {
        return InvoiceCompaniesApiFp(this.configuration).createInvoiceCompany(businessId, createInvoiceCompanyDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an invoice company
     * @param {string} id 
     * @param {number} businessId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceCompaniesApi
     */
    public deleteInvoiceCompany(id: string, businessId: number, options?: AxiosRequestConfig) {
        return InvoiceCompaniesApiFp(this.configuration).deleteInvoiceCompany(id, businessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all invoice companies for a business
     * @param {number} businessId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceCompaniesApi
     */
    public getInvoiceCompanies(businessId: number, options?: AxiosRequestConfig) {
        return InvoiceCompaniesApiFp(this.configuration).getInvoiceCompanies(businessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single invoice company by ID
     * @param {string} id 
     * @param {number} businessId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceCompaniesApi
     */
    public getInvoiceCompanyById(id: string, businessId: number, options?: AxiosRequestConfig) {
        return InvoiceCompaniesApiFp(this.configuration).getInvoiceCompanyById(id, businessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search invoice companies by name, email, or ytunnus
     * @param {number} businessId 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceCompaniesApi
     */
    public searchInvoiceCompanies(businessId: number, search?: string, options?: AxiosRequestConfig) {
        return InvoiceCompaniesApiFp(this.configuration).searchInvoiceCompanies(businessId, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an invoice company
     * @param {string} id 
     * @param {number} businessId 
     * @param {UpdateInvoiceCompanyDto} updateInvoiceCompanyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceCompaniesApi
     */
    public updateInvoiceCompany(id: string, businessId: number, updateInvoiceCompanyDto: UpdateInvoiceCompanyDto, options?: AxiosRequestConfig) {
        return InvoiceCompaniesApiFp(this.configuration).updateInvoiceCompany(id, businessId, updateInvoiceCompanyDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * KiosksApi - axios parameter creator
 * @export
 */
export const KiosksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateKioskDto} createKioskDto Required data for the Kiosk check-in process, including Kiosk ID, Business ID, and the target Payment Terminal ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIn: async (createKioskDto: CreateKioskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createKioskDto' is not null or undefined
            assertParamExists('checkIn', 'createKioskDto', createKioskDto)
            const localVarPath = `/api/v1/kiosk/checkin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createKioskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} kioskId The unique ID of the kiosk device to validate against the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKiosk: async (kioskId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'kioskId' is not null or undefined
            assertParamExists('getKiosk', 'kioskId', kioskId)
            const localVarPath = `/api/v1/kiosk/{kioskId}`
                .replace(`{${"kioskId"}}`, encodeURIComponent(String(kioskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId The unique ID of the order to validate against the system.
         * @param {string} businessId The unique ID of the business to validate against the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderStatus: async (orderId: string, businessId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrderStatus', 'orderId', orderId)
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getOrderStatus', 'businessId', businessId)
            const localVarPath = `/api/v1/kiosk/orders/{orderId}/{businessId}/status`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} kioskId The unique ID of the kiosk device to validate against the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeKiosk: async (kioskId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'kioskId' is not null or undefined
            assertParamExists('removeKiosk', 'kioskId', kioskId)
            const localVarPath = `/api/v1/kiosk/deactivate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (kioskId !== undefined) {
                localVarQueryParameter['kioskId'] = kioskId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} terminalId The unique ID of the terminal to validate against the system.
         * @param {string} provider The payment provider of the terminal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validate: async (terminalId: string, provider: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terminalId' is not null or undefined
            assertParamExists('validate', 'terminalId', terminalId)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('validate', 'provider', provider)
            const localVarPath = `/api/v1/kiosk/terminal/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (terminalId !== undefined) {
                localVarQueryParameter['terminalId'] = terminalId;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KiosksApi - functional programming interface
 * @export
 */
export const KiosksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KiosksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateKioskDto} createKioskDto Required data for the Kiosk check-in process, including Kiosk ID, Business ID, and the target Payment Terminal ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkIn(createKioskDto: CreateKioskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckInResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkIn(createKioskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} kioskId The unique ID of the kiosk device to validate against the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKiosk(kioskId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KioskResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKiosk(kioskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderId The unique ID of the order to validate against the system.
         * @param {string} businessId The unique ID of the business to validate against the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderStatus(orderId: string, businessId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderStatus(orderId, businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} kioskId The unique ID of the kiosk device to validate against the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeKiosk(kioskId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeKiosk(kioskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} terminalId The unique ID of the terminal to validate against the system.
         * @param {string} provider The payment provider of the terminal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validate(terminalId: string, provider: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerminalValidationResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validate(terminalId, provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * KiosksApi - factory interface
 * @export
 */
export const KiosksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KiosksApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateKioskDto} createKioskDto Required data for the Kiosk check-in process, including Kiosk ID, Business ID, and the target Payment Terminal ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIn(createKioskDto: CreateKioskDto, options?: any): AxiosPromise<CheckInResponseDto> {
            return localVarFp.checkIn(createKioskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} kioskId The unique ID of the kiosk device to validate against the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKiosk(kioskId: string, options?: any): AxiosPromise<KioskResponseDto> {
            return localVarFp.getKiosk(kioskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId The unique ID of the order to validate against the system.
         * @param {string} businessId The unique ID of the business to validate against the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderStatus(orderId: string, businessId: string, options?: any): AxiosPromise<PaymentStatusDto> {
            return localVarFp.getOrderStatus(orderId, businessId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} kioskId The unique ID of the kiosk device to validate against the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeKiosk(kioskId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeKiosk(kioskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} terminalId The unique ID of the terminal to validate against the system.
         * @param {string} provider The payment provider of the terminal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validate(terminalId: string, provider: string, options?: any): AxiosPromise<TerminalValidationResponseDto> {
            return localVarFp.validate(terminalId, provider, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KiosksApi - interface
 * @export
 * @interface KiosksApi
 */
export interface KiosksApiInterface {
    /**
     * 
     * @param {CreateKioskDto} createKioskDto Required data for the Kiosk check-in process, including Kiosk ID, Business ID, and the target Payment Terminal ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KiosksApiInterface
     */
    checkIn(createKioskDto: CreateKioskDto, options?: AxiosRequestConfig): AxiosPromise<CheckInResponseDto>;

    /**
     * 
     * @param {string} kioskId The unique ID of the kiosk device to validate against the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KiosksApiInterface
     */
    getKiosk(kioskId: string, options?: AxiosRequestConfig): AxiosPromise<KioskResponseDto>;

    /**
     * 
     * @param {string} orderId The unique ID of the order to validate against the system.
     * @param {string} businessId The unique ID of the business to validate against the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KiosksApiInterface
     */
    getOrderStatus(orderId: string, businessId: string, options?: AxiosRequestConfig): AxiosPromise<PaymentStatusDto>;

    /**
     * 
     * @param {string} kioskId The unique ID of the kiosk device to validate against the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KiosksApiInterface
     */
    removeKiosk(kioskId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} terminalId The unique ID of the terminal to validate against the system.
     * @param {string} provider The payment provider of the terminal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KiosksApiInterface
     */
    validate(terminalId: string, provider: string, options?: AxiosRequestConfig): AxiosPromise<TerminalValidationResponseDto>;

}

/**
 * KiosksApi - object-oriented interface
 * @export
 * @class KiosksApi
 * @extends {BaseAPI}
 */
export class KiosksApi extends BaseAPI implements KiosksApiInterface {
    /**
     * 
     * @param {CreateKioskDto} createKioskDto Required data for the Kiosk check-in process, including Kiosk ID, Business ID, and the target Payment Terminal ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KiosksApi
     */
    public checkIn(createKioskDto: CreateKioskDto, options?: AxiosRequestConfig) {
        return KiosksApiFp(this.configuration).checkIn(createKioskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} kioskId The unique ID of the kiosk device to validate against the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KiosksApi
     */
    public getKiosk(kioskId: string, options?: AxiosRequestConfig) {
        return KiosksApiFp(this.configuration).getKiosk(kioskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId The unique ID of the order to validate against the system.
     * @param {string} businessId The unique ID of the business to validate against the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KiosksApi
     */
    public getOrderStatus(orderId: string, businessId: string, options?: AxiosRequestConfig) {
        return KiosksApiFp(this.configuration).getOrderStatus(orderId, businessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} kioskId The unique ID of the kiosk device to validate against the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KiosksApi
     */
    public removeKiosk(kioskId: string, options?: AxiosRequestConfig) {
        return KiosksApiFp(this.configuration).removeKiosk(kioskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} terminalId The unique ID of the terminal to validate against the system.
     * @param {string} provider The payment provider of the terminal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KiosksApi
     */
    public validate(terminalId: string, provider: string, options?: AxiosRequestConfig) {
        return KiosksApiFp(this.configuration).validate(terminalId, provider, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoyaltyIntegerationsApi - axios parameter creator
 * @export
 */
export const LoyaltyIntegerationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get admin transaction history
         * @param {number} businessId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminTransactions: async (businessId: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getAdminTransactions', 'businessId', businessId)
            const localVarPath = `/api/v1/loyalty/admin/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (businessId !== undefined) {
                localVarQueryParameter['businessId'] = businessId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get loyalty program info
         * @param {number} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoyaltyInfo: async (businessId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getLoyaltyInfo', 'businessId', businessId)
            const localVarPath = `/api/v1/loyalty/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (businessId !== undefined) {
                localVarQueryParameter['businessId'] = businessId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user by ID
         * @param {number} businessId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (businessId: number, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getUserById', 'businessId', businessId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserById', 'userId', userId)
            const localVarPath = `/api/v1/loyalty/users/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (businessId !== undefined) {
                localVarQueryParameter['businessId'] = businessId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search user by phone or email
         * @param {string} businessId 
         * @param {string} [phone] 
         * @param {string} [countryCode] 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUser: async (businessId: string, phone?: string, countryCode?: string, email?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('searchUser', 'businessId', businessId)
            const localVarPath = `/api/v1/loyalty/users/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (phone !== undefined) {
                localVarQueryParameter['phone'] = phone;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (businessId !== undefined) {
                localVarQueryParameter['businessId'] = businessId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user points
         * @param {number} businessId 
         * @param {PointsUpdatePayloadDto} pointsUpdatePayloadDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePoints: async (businessId: number, pointsUpdatePayloadDto: PointsUpdatePayloadDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('updatePoints', 'businessId', businessId)
            // verify required parameter 'pointsUpdatePayloadDto' is not null or undefined
            assertParamExists('updatePoints', 'pointsUpdatePayloadDto', pointsUpdatePayloadDto)
            const localVarPath = `/api/v1/loyalty/update-user-points`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (businessId !== undefined) {
                localVarQueryParameter['businessId'] = businessId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pointsUpdatePayloadDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoyaltyIntegerationsApi - functional programming interface
 * @export
 */
export const LoyaltyIntegerationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoyaltyIntegerationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get admin transaction history
         * @param {number} businessId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdminTransactions(businessId: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminTransactionResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdminTransactions(businessId, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get loyalty program info
         * @param {number} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoyaltyInfo(businessId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoyaltyInfoResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoyaltyInfo(businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user by ID
         * @param {number} businessId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(businessId: number, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoyaltyUserInfoResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(businessId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search user by phone or email
         * @param {string} businessId 
         * @param {string} [phone] 
         * @param {string} [countryCode] 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUser(businessId: string, phone?: string, countryCode?: string, email?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchUserInfoResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUser(businessId, phone, countryCode, email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user points
         * @param {number} businessId 
         * @param {PointsUpdatePayloadDto} pointsUpdatePayloadDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePoints(businessId: number, pointsUpdatePayloadDto: PointsUpdatePayloadDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointsUpdateResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePoints(businessId, pointsUpdatePayloadDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LoyaltyIntegerationsApi - factory interface
 * @export
 */
export const LoyaltyIntegerationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoyaltyIntegerationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get admin transaction history
         * @param {number} businessId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminTransactions(businessId: number, page?: number, limit?: number, options?: any): AxiosPromise<AdminTransactionResponseDto> {
            return localVarFp.getAdminTransactions(businessId, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get loyalty program info
         * @param {number} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoyaltyInfo(businessId: number, options?: any): AxiosPromise<LoyaltyInfoResponseDto> {
            return localVarFp.getLoyaltyInfo(businessId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user by ID
         * @param {number} businessId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(businessId: number, userId: string, options?: any): AxiosPromise<LoyaltyUserInfoResponseDto> {
            return localVarFp.getUserById(businessId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search user by phone or email
         * @param {string} businessId 
         * @param {string} [phone] 
         * @param {string} [countryCode] 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUser(businessId: string, phone?: string, countryCode?: string, email?: string, options?: any): AxiosPromise<SearchUserInfoResponseDto> {
            return localVarFp.searchUser(businessId, phone, countryCode, email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user points
         * @param {number} businessId 
         * @param {PointsUpdatePayloadDto} pointsUpdatePayloadDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePoints(businessId: number, pointsUpdatePayloadDto: PointsUpdatePayloadDto, options?: any): AxiosPromise<PointsUpdateResponseDto> {
            return localVarFp.updatePoints(businessId, pointsUpdatePayloadDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoyaltyIntegerationsApi - interface
 * @export
 * @interface LoyaltyIntegerationsApi
 */
export interface LoyaltyIntegerationsApiInterface {
    /**
     * 
     * @summary Get admin transaction history
     * @param {number} businessId 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoyaltyIntegerationsApiInterface
     */
    getAdminTransactions(businessId: number, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<AdminTransactionResponseDto>;

    /**
     * 
     * @summary Get loyalty program info
     * @param {number} businessId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoyaltyIntegerationsApiInterface
     */
    getLoyaltyInfo(businessId: number, options?: AxiosRequestConfig): AxiosPromise<LoyaltyInfoResponseDto>;

    /**
     * 
     * @summary Get user by ID
     * @param {number} businessId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoyaltyIntegerationsApiInterface
     */
    getUserById(businessId: number, userId: string, options?: AxiosRequestConfig): AxiosPromise<LoyaltyUserInfoResponseDto>;

    /**
     * 
     * @summary Search user by phone or email
     * @param {string} businessId 
     * @param {string} [phone] 
     * @param {string} [countryCode] 
     * @param {string} [email] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoyaltyIntegerationsApiInterface
     */
    searchUser(businessId: string, phone?: string, countryCode?: string, email?: string, options?: AxiosRequestConfig): AxiosPromise<SearchUserInfoResponseDto>;

    /**
     * 
     * @summary Update user points
     * @param {number} businessId 
     * @param {PointsUpdatePayloadDto} pointsUpdatePayloadDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoyaltyIntegerationsApiInterface
     */
    updatePoints(businessId: number, pointsUpdatePayloadDto: PointsUpdatePayloadDto, options?: AxiosRequestConfig): AxiosPromise<PointsUpdateResponseDto>;

}

/**
 * LoyaltyIntegerationsApi - object-oriented interface
 * @export
 * @class LoyaltyIntegerationsApi
 * @extends {BaseAPI}
 */
export class LoyaltyIntegerationsApi extends BaseAPI implements LoyaltyIntegerationsApiInterface {
    /**
     * 
     * @summary Get admin transaction history
     * @param {number} businessId 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoyaltyIntegerationsApi
     */
    public getAdminTransactions(businessId: number, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return LoyaltyIntegerationsApiFp(this.configuration).getAdminTransactions(businessId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get loyalty program info
     * @param {number} businessId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoyaltyIntegerationsApi
     */
    public getLoyaltyInfo(businessId: number, options?: AxiosRequestConfig) {
        return LoyaltyIntegerationsApiFp(this.configuration).getLoyaltyInfo(businessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user by ID
     * @param {number} businessId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoyaltyIntegerationsApi
     */
    public getUserById(businessId: number, userId: string, options?: AxiosRequestConfig) {
        return LoyaltyIntegerationsApiFp(this.configuration).getUserById(businessId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search user by phone or email
     * @param {string} businessId 
     * @param {string} [phone] 
     * @param {string} [countryCode] 
     * @param {string} [email] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoyaltyIntegerationsApi
     */
    public searchUser(businessId: string, phone?: string, countryCode?: string, email?: string, options?: AxiosRequestConfig) {
        return LoyaltyIntegerationsApiFp(this.configuration).searchUser(businessId, phone, countryCode, email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user points
     * @param {number} businessId 
     * @param {PointsUpdatePayloadDto} pointsUpdatePayloadDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoyaltyIntegerationsApi
     */
    public updatePoints(businessId: number, pointsUpdatePayloadDto: PointsUpdatePayloadDto, options?: AxiosRequestConfig) {
        return LoyaltyIntegerationsApiFp(this.configuration).updatePoints(businessId, pointsUpdatePayloadDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MenuApi - axios parameter creator
 * @export
 */
export const MenuApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update product status (enabled/disabled) for a business
         * @param {string} businessId Unique identifier of the business
         * @param {Array<MenuProductDto>} menuProductDto List of products with updated status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editBusinessProduct: async (businessId: string, menuProductDto: Array<MenuProductDto>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('editBusinessProduct', 'businessId', businessId)
            // verify required parameter 'menuProductDto' is not null or undefined
            assertParamExists('editBusinessProduct', 'menuProductDto', menuProductDto)
            const localVarPath = `/api/v1/menu/{businessId}/product`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(menuProductDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update product status (enabled/disabled) for a business
         * @param {string} businessId Unique identifier of the business
         * @param {Array<MenuProductDtoV2>} menuProductDtoV2 List of products with updated status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editBusinessProductV2: async (businessId: string, menuProductDtoV2: Array<MenuProductDtoV2>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('editBusinessProductV2', 'businessId', businessId)
            // verify required parameter 'menuProductDtoV2' is not null or undefined
            assertParamExists('editBusinessProductV2', 'menuProductDtoV2', menuProductDtoV2)
            const localVarPath = `/api/v2/menu/{businessId}/product`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(menuProductDtoV2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get business product extras
         * @param {string} businessId Business ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessExtras: async (businessId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getBusinessExtras', 'businessId', businessId)
            const localVarPath = `/api/v1/menu/{businessId}/extras`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get products by categories from MongoDB
         * @param {string} businessId Unique identifier of the business
         * @param {'available' | 'unavailable'} [filter] Filter products by availability status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsByCategoriesV2: async (businessId: string, filter?: 'available' | 'unavailable', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getProductsByCategoriesV2', 'businessId', businessId)
            const localVarPath = `/api/v2/menu/{businessId}/categories`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ResetEodDto} resetEodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetProductEod: async (resetEodDto: ResetEodDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetEodDto' is not null or undefined
            assertParamExists('resetProductEod', 'resetEodDto', resetEodDto)
            const localVarPath = `/api/v1/menu/availability/reset-eod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetEodDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MenuApi - functional programming interface
 * @export
 */
export const MenuApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MenuApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update product status (enabled/disabled) for a business
         * @param {string} businessId Unique identifier of the business
         * @param {Array<MenuProductDto>} menuProductDto List of products with updated status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editBusinessProduct(businessId: string, menuProductDto: Array<MenuProductDto>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderMapResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editBusinessProduct(businessId, menuProductDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update product status (enabled/disabled) for a business
         * @param {string} businessId Unique identifier of the business
         * @param {Array<MenuProductDtoV2>} menuProductDtoV2 List of products with updated status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editBusinessProductV2(businessId: string, menuProductDtoV2: Array<MenuProductDtoV2>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderMapResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editBusinessProductV2(businessId, menuProductDtoV2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get business product extras
         * @param {string} businessId Business ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessExtras(businessId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MenuProductExtraDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessExtras(businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get products by categories from MongoDB
         * @param {string} businessId Unique identifier of the business
         * @param {'available' | 'unavailable'} [filter] Filter products by availability status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsByCategoriesV2(businessId: string, filter?: 'available' | 'unavailable', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsByCategoriesResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductsByCategoriesV2(businessId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ResetEodDto} resetEodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetProductEod(resetEodDto: ResetEodDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetProductEod(resetEodDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MenuApi - factory interface
 * @export
 */
export const MenuApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MenuApiFp(configuration)
    return {
        /**
         * 
         * @summary Update product status (enabled/disabled) for a business
         * @param {string} businessId Unique identifier of the business
         * @param {Array<MenuProductDto>} menuProductDto List of products with updated status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editBusinessProduct(businessId: string, menuProductDto: Array<MenuProductDto>, options?: any): AxiosPromise<ProviderMapResponseDto> {
            return localVarFp.editBusinessProduct(businessId, menuProductDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update product status (enabled/disabled) for a business
         * @param {string} businessId Unique identifier of the business
         * @param {Array<MenuProductDtoV2>} menuProductDtoV2 List of products with updated status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editBusinessProductV2(businessId: string, menuProductDtoV2: Array<MenuProductDtoV2>, options?: any): AxiosPromise<ProviderMapResponseDto> {
            return localVarFp.editBusinessProductV2(businessId, menuProductDtoV2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get business product extras
         * @param {string} businessId Business ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessExtras(businessId: string, options?: any): AxiosPromise<Array<MenuProductExtraDto>> {
            return localVarFp.getBusinessExtras(businessId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get products by categories from MongoDB
         * @param {string} businessId Unique identifier of the business
         * @param {'available' | 'unavailable'} [filter] Filter products by availability status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsByCategoriesV2(businessId: string, filter?: 'available' | 'unavailable', options?: any): AxiosPromise<ProductsByCategoriesResponseDto> {
            return localVarFp.getProductsByCategoriesV2(businessId, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ResetEodDto} resetEodDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetProductEod(resetEodDto: ResetEodDto, options?: any): AxiosPromise<void> {
            return localVarFp.resetProductEod(resetEodDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MenuApi - interface
 * @export
 * @interface MenuApi
 */
export interface MenuApiInterface {
    /**
     * 
     * @summary Update product status (enabled/disabled) for a business
     * @param {string} businessId Unique identifier of the business
     * @param {Array<MenuProductDto>} menuProductDto List of products with updated status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApiInterface
     */
    editBusinessProduct(businessId: string, menuProductDto: Array<MenuProductDto>, options?: AxiosRequestConfig): AxiosPromise<ProviderMapResponseDto>;

    /**
     * 
     * @summary Update product status (enabled/disabled) for a business
     * @param {string} businessId Unique identifier of the business
     * @param {Array<MenuProductDtoV2>} menuProductDtoV2 List of products with updated status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApiInterface
     */
    editBusinessProductV2(businessId: string, menuProductDtoV2: Array<MenuProductDtoV2>, options?: AxiosRequestConfig): AxiosPromise<ProviderMapResponseDto>;

    /**
     * 
     * @summary Get business product extras
     * @param {string} businessId Business ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApiInterface
     */
    getBusinessExtras(businessId: string, options?: AxiosRequestConfig): AxiosPromise<Array<MenuProductExtraDto>>;

    /**
     * 
     * @summary Get products by categories from MongoDB
     * @param {string} businessId Unique identifier of the business
     * @param {'available' | 'unavailable'} [filter] Filter products by availability status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApiInterface
     */
    getProductsByCategoriesV2(businessId: string, filter?: 'available' | 'unavailable', options?: AxiosRequestConfig): AxiosPromise<ProductsByCategoriesResponseDto>;

    /**
     * 
     * @param {ResetEodDto} resetEodDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApiInterface
     */
    resetProductEod(resetEodDto: ResetEodDto, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * MenuApi - object-oriented interface
 * @export
 * @class MenuApi
 * @extends {BaseAPI}
 */
export class MenuApi extends BaseAPI implements MenuApiInterface {
    /**
     * 
     * @summary Update product status (enabled/disabled) for a business
     * @param {string} businessId Unique identifier of the business
     * @param {Array<MenuProductDto>} menuProductDto List of products with updated status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public editBusinessProduct(businessId: string, menuProductDto: Array<MenuProductDto>, options?: AxiosRequestConfig) {
        return MenuApiFp(this.configuration).editBusinessProduct(businessId, menuProductDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update product status (enabled/disabled) for a business
     * @param {string} businessId Unique identifier of the business
     * @param {Array<MenuProductDtoV2>} menuProductDtoV2 List of products with updated status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public editBusinessProductV2(businessId: string, menuProductDtoV2: Array<MenuProductDtoV2>, options?: AxiosRequestConfig) {
        return MenuApiFp(this.configuration).editBusinessProductV2(businessId, menuProductDtoV2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get business product extras
     * @param {string} businessId Business ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public getBusinessExtras(businessId: string, options?: AxiosRequestConfig) {
        return MenuApiFp(this.configuration).getBusinessExtras(businessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get products by categories from MongoDB
     * @param {string} businessId Unique identifier of the business
     * @param {'available' | 'unavailable'} [filter] Filter products by availability status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public getProductsByCategoriesV2(businessId: string, filter?: 'available' | 'unavailable', options?: AxiosRequestConfig) {
        return MenuApiFp(this.configuration).getProductsByCategoriesV2(businessId, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ResetEodDto} resetEodDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public resetProductEod(resetEodDto: ResetEodDto, options?: AxiosRequestConfig) {
        return MenuApiFp(this.configuration).resetProductEod(resetEodDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MerchantsApi - axios parameter creator
 * @export
 */
export const MerchantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateMerchantDto} createMerchantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMerchant: async (createMerchantDto: CreateMerchantDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMerchantDto' is not null or undefined
            assertParamExists('createMerchant', 'createMerchantDto', createMerchantDto)
            const localVarPath = `/api/v1/merchants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMerchantDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MerchantsApi - functional programming interface
 * @export
 */
export const MerchantsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MerchantsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateMerchantDto} createMerchantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMerchant(createMerchantDto: CreateMerchantDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMerchant(createMerchantDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MerchantsApi - factory interface
 * @export
 */
export const MerchantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MerchantsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateMerchantDto} createMerchantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMerchant(createMerchantDto: CreateMerchantDto, options?: any): AxiosPromise<MerchantResponseDto> {
            return localVarFp.createMerchant(createMerchantDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MerchantsApi - interface
 * @export
 * @interface MerchantsApi
 */
export interface MerchantsApiInterface {
    /**
     * 
     * @param {CreateMerchantDto} createMerchantDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantsApiInterface
     */
    createMerchant(createMerchantDto: CreateMerchantDto, options?: AxiosRequestConfig): AxiosPromise<MerchantResponseDto>;

}

/**
 * MerchantsApi - object-oriented interface
 * @export
 * @class MerchantsApi
 * @extends {BaseAPI}
 */
export class MerchantsApi extends BaseAPI implements MerchantsApiInterface {
    /**
     * 
     * @param {CreateMerchantDto} createMerchantDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantsApi
     */
    public createMerchant(createMerchantDto: CreateMerchantDto, options?: AxiosRequestConfig) {
        return MerchantsApiFp(this.configuration).createMerchant(createMerchantDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVenueSubscriptions: async (deviceSubscriptionDto: DeviceSubscriptionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceSubscriptionDto' is not null or undefined
            assertParamExists('addVenueSubscriptions', 'deviceSubscriptionDto', deviceSubscriptionDto)
            const localVarPath = `/api/v1/notification/add-venue-subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceSubscriptionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subscribe a device to multiple venue/business notifications using OneSignal ID and hardware ID.
         * @summary Add venue subscriptions for push notifications
         * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVenueSubscriptionsV2: async (deviceSubscriptionDto: DeviceSubscriptionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceSubscriptionDto' is not null or undefined
            assertParamExists('addVenueSubscriptionsV2', 'deviceSubscriptionDto', deviceSubscriptionDto)
            const localVarPath = `/api/v2/notification/add-venue-subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceSubscriptionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeVenueSubscriptions: async (deviceSubscriptionDto: DeviceSubscriptionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceSubscriptionDto' is not null or undefined
            assertParamExists('removeVenueSubscriptions', 'deviceSubscriptionDto', deviceSubscriptionDto)
            const localVarPath = `/api/v1/notification/remove-venue-subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceSubscriptionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unsubscribe a device from multiple venue/business notifications using hardware ID.
         * @summary Remove venue subscriptions for push notifications
         * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeVenueSubscriptionsV2: async (deviceSubscriptionDto: DeviceSubscriptionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceSubscriptionDto' is not null or undefined
            assertParamExists('removeVenueSubscriptionsV2', 'deviceSubscriptionDto', deviceSubscriptionDto)
            const localVarPath = `/api/v2/notification/remove-venue-subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceSubscriptionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addVenueSubscriptions(deviceSubscriptionDto: DeviceSubscriptionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addVenueSubscriptions(deviceSubscriptionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Subscribe a device to multiple venue/business notifications using OneSignal ID and hardware ID.
         * @summary Add venue subscriptions for push notifications
         * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addVenueSubscriptionsV2(deviceSubscriptionDto: DeviceSubscriptionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addVenueSubscriptionsV2(deviceSubscriptionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeVenueSubscriptions(deviceSubscriptionDto: DeviceSubscriptionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeVenueSubscriptions(deviceSubscriptionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unsubscribe a device from multiple venue/business notifications using hardware ID.
         * @summary Remove venue subscriptions for push notifications
         * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeVenueSubscriptionsV2(deviceSubscriptionDto: DeviceSubscriptionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeVenueSubscriptionsV2(deviceSubscriptionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationApiFp(configuration)
    return {
        /**
         * 
         * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVenueSubscriptions(deviceSubscriptionDto: DeviceSubscriptionDto, options?: any): AxiosPromise<void> {
            return localVarFp.addVenueSubscriptions(deviceSubscriptionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Subscribe a device to multiple venue/business notifications using OneSignal ID and hardware ID.
         * @summary Add venue subscriptions for push notifications
         * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVenueSubscriptionsV2(deviceSubscriptionDto: DeviceSubscriptionDto, options?: any): AxiosPromise<void> {
            return localVarFp.addVenueSubscriptionsV2(deviceSubscriptionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeVenueSubscriptions(deviceSubscriptionDto: DeviceSubscriptionDto, options?: any): AxiosPromise<void> {
            return localVarFp.removeVenueSubscriptions(deviceSubscriptionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Unsubscribe a device from multiple venue/business notifications using hardware ID.
         * @summary Remove venue subscriptions for push notifications
         * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeVenueSubscriptionsV2(deviceSubscriptionDto: DeviceSubscriptionDto, options?: any): AxiosPromise<void> {
            return localVarFp.removeVenueSubscriptionsV2(deviceSubscriptionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationApi - interface
 * @export
 * @interface NotificationApi
 */
export interface NotificationApiInterface {
    /**
     * 
     * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApiInterface
     */
    addVenueSubscriptions(deviceSubscriptionDto: DeviceSubscriptionDto, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Subscribe a device to multiple venue/business notifications using OneSignal ID and hardware ID.
     * @summary Add venue subscriptions for push notifications
     * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApiInterface
     */
    addVenueSubscriptionsV2(deviceSubscriptionDto: DeviceSubscriptionDto, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApiInterface
     */
    removeVenueSubscriptions(deviceSubscriptionDto: DeviceSubscriptionDto, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Unsubscribe a device from multiple venue/business notifications using hardware ID.
     * @summary Remove venue subscriptions for push notifications
     * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApiInterface
     */
    removeVenueSubscriptionsV2(deviceSubscriptionDto: DeviceSubscriptionDto, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI implements NotificationApiInterface {
    /**
     * 
     * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public addVenueSubscriptions(deviceSubscriptionDto: DeviceSubscriptionDto, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).addVenueSubscriptions(deviceSubscriptionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subscribe a device to multiple venue/business notifications using OneSignal ID and hardware ID.
     * @summary Add venue subscriptions for push notifications
     * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public addVenueSubscriptionsV2(deviceSubscriptionDto: DeviceSubscriptionDto, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).addVenueSubscriptionsV2(deviceSubscriptionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public removeVenueSubscriptions(deviceSubscriptionDto: DeviceSubscriptionDto, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).removeVenueSubscriptions(deviceSubscriptionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unsubscribe a device from multiple venue/business notifications using hardware ID.
     * @summary Remove venue subscriptions for push notifications
     * @param {DeviceSubscriptionDto} deviceSubscriptionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public removeVenueSubscriptionsV2(deviceSubscriptionDto: DeviceSubscriptionDto, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).removeVenueSubscriptionsV2(deviceSubscriptionDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrderingCoApi - axios parameter creator
 * @export
 */
export const OrderingCoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update tax rate for businesses
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxRate: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateTaxRate', 'body', body)
            const localVarPath = `/api/v1/ordering/update-tax-rate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderingCoApi - functional programming interface
 * @export
 */
export const OrderingCoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderingCoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update tax rate for businesses
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTaxRate(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTaxRate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrderingCoApi - factory interface
 * @export
 */
export const OrderingCoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderingCoApiFp(configuration)
    return {
        /**
         * 
         * @summary Update tax rate for businesses
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxRate(body: object, options?: any): AxiosPromise<void> {
            return localVarFp.updateTaxRate(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderingCoApi - interface
 * @export
 * @interface OrderingCoApi
 */
export interface OrderingCoApiInterface {
    /**
     * 
     * @summary Update tax rate for businesses
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderingCoApiInterface
     */
    updateTaxRate(body: object, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * OrderingCoApi - object-oriented interface
 * @export
 * @class OrderingCoApi
 * @extends {BaseAPI}
 */
export class OrderingCoApi extends BaseAPI implements OrderingCoApiInterface {
    /**
     * 
     * @summary Update tax rate for businesses
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderingCoApi
     */
    public updateTaxRate(body: object, options?: AxiosRequestConfig) {
        return OrderingCoApiFp(this.configuration).updateTaxRate(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accept an order
         * @param {AcceptOrderDto} acceptOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptOrder: async (acceptOrderDto: AcceptOrderDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptOrderDto' is not null or undefined
            assertParamExists('acceptOrder', 'acceptOrderDto', acceptOrderDto)
            const localVarPath = `/api/v1/orders/accept`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acceptOrderDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Confirm a pre-order
         * @param {ConfirmPreorderDto} confirmPreorderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmPreOrder: async (confirmPreorderDto: ConfirmPreorderDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'confirmPreorderDto' is not null or undefined
            assertParamExists('confirmPreOrder', 'confirmPreorderDto', confirmPreorderDto)
            const localVarPath = `/api/v1/orders/confirm/preOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmPreorderDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a parked pos order
         * @param {DeletePosOrderDto} deletePosOrderDto Id of the pos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePosParkedOrder: async (deletePosOrderDto: DeletePosOrderDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deletePosOrderDto' is not null or undefined
            assertParamExists('deletePosParkedOrder', 'deletePosOrderDto', deletePosOrderDto)
            const localVarPath = `/api/v1/orders/pos/park`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deletePosOrderDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a parked pos order
         * @param {DeletePosOrderDto} deletePosOrderDto Id of the pos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePosParkedOrderV2: async (deletePosOrderDto: DeletePosOrderDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deletePosOrderDto' is not null or undefined
            assertParamExists('deletePosParkedOrderV2', 'deletePosOrderDto', deletePosOrderDto)
            const localVarPath = `/api/v2/orders/pos/park`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deletePosOrderDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark an order as delivered to customer or picked-up by driver
         * @param {DeliveredOrderDto} deliveredOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliverOrder: async (deliveredOrderDto: DeliveredOrderDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deliveredOrderDto' is not null or undefined
            assertParamExists('deliverOrder', 'deliveredOrderDto', deliveredOrderDto)
            const localVarPath = `/api/v1/orders/delivered`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deliveredOrderDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all orders across all statuses
         * @param {string} businessIds Comma-separated list of business IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrdersV2: async (businessIds: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('getAllOrdersV2', 'businessIds', businessIds)
            const localVarPath = `/api/v2/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (businessIds !== undefined) {
                localVarQueryParameter['businessIds'] = businessIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns paginated orders sorted by status-specific logic. Database and POS orders are combined and sorted before pagination is applied.
         * @summary Get all orders across all statuses with pagination
         * @param {string} businessIds Comma-separated list of business IDs
         * @param {number} [limit] Number of items per page (max 100)
         * @param {number} [page] Page number (starts from 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrdersV3: async (businessIds: string, limit?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('getAllOrdersV3', 'businessIds', businessIds)
            const localVarPath = `/api/v3/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (businessIds !== undefined) {
                localVarQueryParameter['businessIds'] = businessIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get orders by status
         * @param {'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft'} status Order status filter
         * @param {string} businessIds Comma-separated list of business IDs
         * @param {string} [posBusinessId] Id of the pos
         * @param {'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk'} [extraProvider] Extra attributes to get POS orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersV2: async (status: 'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft', businessIds: string, posBusinessId?: string, extraProvider?: 'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('getOrdersV2', 'status', status)
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('getOrdersV2', 'businessIds', businessIds)
            const localVarPath = `/api/v2/orders/{status}`
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (posBusinessId !== undefined) {
                localVarQueryParameter['posBusinessId'] = posBusinessId;
            }

            if (extraProvider !== undefined) {
                localVarQueryParameter['extraProvider'] = extraProvider;
            }

            if (businessIds !== undefined) {
                localVarQueryParameter['businessIds'] = businessIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns paginated orders filtered by status and sorted by status-specific logic. Database and POS orders are combined and sorted before pagination is applied.
         * @summary Get orders by status with pagination
         * @param {'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft'} status Order status filter
         * @param {string} businessIds Comma-separated list of business IDs
         * @param {number} [limit] Number of items per page (max 100)
         * @param {number} [page] Page number (starts from 1)
         * @param {string} [posBusinessId] Id of the pos
         * @param {'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk'} [extraProvider] Extra attributes to get POS orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersV3: async (status: 'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft', businessIds: string, limit?: number, page?: number, posBusinessId?: string, extraProvider?: 'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('getOrdersV3', 'status', status)
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('getOrdersV3', 'businessIds', businessIds)
            const localVarPath = `/api/v3/orders/{status}`
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (posBusinessId !== undefined) {
                localVarQueryParameter['posBusinessId'] = posBusinessId;
            }

            if (extraProvider !== undefined) {
                localVarQueryParameter['extraProvider'] = extraProvider;
            }

            if (businessIds !== undefined) {
                localVarQueryParameter['businessIds'] = businessIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Pos park order
         * @param {string} businessId Id of the pos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParkedPosOrder: async (businessId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getParkedPosOrder', 'businessId', businessId)
            const localVarPath = `/api/v1/orders/pos/park`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (businessId !== undefined) {
                localVarQueryParameter['businessId'] = businessId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Pos park order
         * @param {string} businessId Id of the pos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParkedPosOrderV2: async (businessId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getParkedPosOrderV2', 'businessId', businessId)
            const localVarPath = `/api/v2/orders/pos/park`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (businessId !== undefined) {
                localVarQueryParameter['businessId'] = businessId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark an order as ready for pickup/delivery
         * @param {ReadyOrderDto} readyOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markOrderAsReady: async (readyOrderDto: ReadyOrderDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'readyOrderDto' is not null or undefined
            assertParamExists('markOrderAsReady', 'readyOrderDto', readyOrderDto)
            const localVarPath = `/api/v1/orders/ready`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(readyOrderDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Place an POS order
         * @param {PosOrderPayloadDto} posOrderPayloadDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placePosOrder: async (posOrderPayloadDto: PosOrderPayloadDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'posOrderPayloadDto' is not null or undefined
            assertParamExists('placePosOrder', 'posOrderPayloadDto', posOrderPayloadDto)
            const localVarPath = `/api/v1/orders/pos/place`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(posOrderPayloadDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Place an POS order
         * @param {PosOrderPayloadDto} posOrderPayloadDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placePosOrderV2: async (posOrderPayloadDto: PosOrderPayloadDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'posOrderPayloadDto' is not null or undefined
            assertParamExists('placePosOrderV2', 'posOrderPayloadDto', posOrderPayloadDto)
            const localVarPath = `/api/v2/orders/pos/place`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(posOrderPayloadDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Place an POS order
         * @param {PosOrderPayloadDto} posOrderPayloadDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placePosOrderV3: async (posOrderPayloadDto: PosOrderPayloadDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'posOrderPayloadDto' is not null or undefined
            assertParamExists('placePosOrderV3', 'posOrderPayloadDto', posOrderPayloadDto)
            const localVarPath = `/api/v3/orders/pos/place`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(posOrderPayloadDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Place an POS order
         * @param {PosOrderPayloadDto} posOrderPayloadDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placePosOrderV4: async (posOrderPayloadDto: PosOrderPayloadDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'posOrderPayloadDto' is not null or undefined
            assertParamExists('placePosOrderV4', 'posOrderPayloadDto', posOrderPayloadDto)
            const localVarPath = `/api/v4/orders/pos/place`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(posOrderPayloadDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process multiple actions for a POS order
         * @summary Process pos order actions
         * @param {ProcessOrderActionsDto} processOrderActionsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPosOrderActions: async (processOrderActionsDto: ProcessOrderActionsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'processOrderActionsDto' is not null or undefined
            assertParamExists('processPosOrderActions', 'processOrderActionsDto', processOrderActionsDto)
            const localVarPath = `/api/v4/orders/pos/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processOrderActionsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reject an order
         * @param {RejectOrderDto} rejectOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectOrder: async (rejectOrderDto: RejectOrderDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rejectOrderDto' is not null or undefined
            assertParamExists('rejectOrder', 'rejectOrderDto', rejectOrderDto)
            const localVarPath = `/api/v1/orders/reject`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rejectOrderDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send a POS order ticket
         * @param {SendPosOrderTicketDto} sendPosOrderTicketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPosOrderTicket: async (sendPosOrderTicketDto: SendPosOrderTicketDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendPosOrderTicketDto' is not null or undefined
            assertParamExists('sendPosOrderTicket', 'sendPosOrderTicketDto', sendPosOrderTicketDto)
            const localVarPath = `/api/v1/orders/pos/ticket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendPosOrderTicketDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send a POS order ticket
         * @param {SendPosOrderTicketDto} sendPosOrderTicketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPosOrderTicketV2: async (sendPosOrderTicketDto: SendPosOrderTicketDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendPosOrderTicketDto' is not null or undefined
            assertParamExists('sendPosOrderTicketV2', 'sendPosOrderTicketDto', sendPosOrderTicketDto)
            const localVarPath = `/api/v2/orders/pos/ticket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendPosOrderTicketDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a POS order status
         * @param {PosUpdateOrderDto} posUpdateOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePosOrder: async (posUpdateOrderDto: PosUpdateOrderDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'posUpdateOrderDto' is not null or undefined
            assertParamExists('updatePosOrder', 'posUpdateOrderDto', posUpdateOrderDto)
            const localVarPath = `/api/v1/orders/pos/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(posUpdateOrderDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a POS order status
         * @param {PosUpdateOrderDto} posUpdateOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePosOrderV2: async (posUpdateOrderDto: PosUpdateOrderDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'posUpdateOrderDto' is not null or undefined
            assertParamExists('updatePosOrderV2', 'posUpdateOrderDto', posUpdateOrderDto)
            const localVarPath = `/api/v2/orders/pos/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(posUpdateOrderDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Accept an order
         * @param {AcceptOrderDto} acceptOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptOrder(acceptOrderDto: AcceptOrderDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderStatusResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptOrder(acceptOrderDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Confirm a pre-order
         * @param {ConfirmPreorderDto} confirmPreorderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmPreOrder(confirmPreorderDto: ConfirmPreorderDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderStatusResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmPreOrder(confirmPreorderDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a parked pos order
         * @param {DeletePosOrderDto} deletePosOrderDto Id of the pos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePosParkedOrder(deletePosOrderDto: DeletePosOrderDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePosParkedOrder(deletePosOrderDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a parked pos order
         * @param {DeletePosOrderDto} deletePosOrderDto Id of the pos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePosParkedOrderV2(deletePosOrderDto: DeletePosOrderDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePosParkedOrderV2(deletePosOrderDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Mark an order as delivered to customer or picked-up by driver
         * @param {DeliveredOrderDto} deliveredOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliverOrder(deliveredOrderDto: DeliveredOrderDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderStatusResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliverOrder(deliveredOrderDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all orders across all statuses
         * @param {string} businessIds Comma-separated list of business IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOrdersV2(businessIds: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrderResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOrdersV2(businessIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns paginated orders sorted by status-specific logic. Database and POS orders are combined and sorted before pagination is applied.
         * @summary Get all orders across all statuses with pagination
         * @param {string} businessIds Comma-separated list of business IDs
         * @param {number} [limit] Number of items per page (max 100)
         * @param {number} [page] Page number (starts from 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOrdersV3(businessIds: string, limit?: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOrdersV3(businessIds, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get orders by status
         * @param {'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft'} status Order status filter
         * @param {string} businessIds Comma-separated list of business IDs
         * @param {string} [posBusinessId] Id of the pos
         * @param {'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk'} [extraProvider] Extra attributes to get POS orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrdersV2(status: 'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft', businessIds: string, posBusinessId?: string, extraProvider?: 'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrderResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrdersV2(status, businessIds, posBusinessId, extraProvider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns paginated orders filtered by status and sorted by status-specific logic. Database and POS orders are combined and sorted before pagination is applied.
         * @summary Get orders by status with pagination
         * @param {'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft'} status Order status filter
         * @param {string} businessIds Comma-separated list of business IDs
         * @param {number} [limit] Number of items per page (max 100)
         * @param {number} [page] Page number (starts from 1)
         * @param {string} [posBusinessId] Id of the pos
         * @param {'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk'} [extraProvider] Extra attributes to get POS orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrdersV3(status: 'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft', businessIds: string, limit?: number, page?: number, posBusinessId?: string, extraProvider?: 'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrdersV3(status, businessIds, limit, page, posBusinessId, extraProvider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all Pos park order
         * @param {string} businessId Id of the pos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParkedPosOrder(businessId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FirebasePosOrderResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParkedPosOrder(businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all Pos park order
         * @param {string} businessId Id of the pos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParkedPosOrderV2(businessId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PosOrderDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParkedPosOrderV2(businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Mark an order as ready for pickup/delivery
         * @param {ReadyOrderDto} readyOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markOrderAsReady(readyOrderDto: ReadyOrderDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderStatusResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markOrderAsReady(readyOrderDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Place an POS order
         * @param {PosOrderPayloadDto} posOrderPayloadDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placePosOrder(posOrderPayloadDto: PosOrderPayloadDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirebasePosOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placePosOrder(posOrderPayloadDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Place an POS order
         * @param {PosOrderPayloadDto} posOrderPayloadDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placePosOrderV2(posOrderPayloadDto: PosOrderPayloadDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PosOrderDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placePosOrderV2(posOrderPayloadDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Place an POS order
         * @param {PosOrderPayloadDto} posOrderPayloadDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placePosOrderV3(posOrderPayloadDto: PosOrderPayloadDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PosOrderDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placePosOrderV3(posOrderPayloadDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Place an POS order
         * @param {PosOrderPayloadDto} posOrderPayloadDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placePosOrderV4(posOrderPayloadDto: PosOrderPayloadDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PosOrderDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placePosOrderV4(posOrderPayloadDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Process multiple actions for a POS order
         * @summary Process pos order actions
         * @param {ProcessOrderActionsDto} processOrderActionsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processPosOrderActions(processOrderActionsDto: ProcessOrderActionsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessOrderActionsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processPosOrderActions(processOrderActionsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reject an order
         * @param {RejectOrderDto} rejectOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectOrder(rejectOrderDto: RejectOrderDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderStatusResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectOrder(rejectOrderDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send a POS order ticket
         * @param {SendPosOrderTicketDto} sendPosOrderTicketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPosOrderTicket(sendPosOrderTicketDto: SendPosOrderTicketDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirebasePosOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendPosOrderTicket(sendPosOrderTicketDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send a POS order ticket
         * @param {SendPosOrderTicketDto} sendPosOrderTicketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPosOrderTicketV2(sendPosOrderTicketDto: SendPosOrderTicketDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PosOrderDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendPosOrderTicketV2(sendPosOrderTicketDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a POS order status
         * @param {PosUpdateOrderDto} posUpdateOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePosOrder(posUpdateOrderDto: PosUpdateOrderDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderStatusResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePosOrder(posUpdateOrderDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a POS order status
         * @param {PosUpdateOrderDto} posUpdateOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePosOrderV2(posUpdateOrderDto: PosUpdateOrderDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderStatusResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePosOrderV2(posUpdateOrderDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * 
         * @summary Accept an order
         * @param {AcceptOrderDto} acceptOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptOrder(acceptOrderDto: AcceptOrderDto, options?: any): AxiosPromise<OrderStatusResponseDto> {
            return localVarFp.acceptOrder(acceptOrderDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Confirm a pre-order
         * @param {ConfirmPreorderDto} confirmPreorderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmPreOrder(confirmPreorderDto: ConfirmPreorderDto, options?: any): AxiosPromise<OrderStatusResponseDto> {
            return localVarFp.confirmPreOrder(confirmPreorderDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a parked pos order
         * @param {DeletePosOrderDto} deletePosOrderDto Id of the pos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePosParkedOrder(deletePosOrderDto: DeletePosOrderDto, options?: any): AxiosPromise<void> {
            return localVarFp.deletePosParkedOrder(deletePosOrderDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a parked pos order
         * @param {DeletePosOrderDto} deletePosOrderDto Id of the pos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePosParkedOrderV2(deletePosOrderDto: DeletePosOrderDto, options?: any): AxiosPromise<void> {
            return localVarFp.deletePosParkedOrderV2(deletePosOrderDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark an order as delivered to customer or picked-up by driver
         * @param {DeliveredOrderDto} deliveredOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliverOrder(deliveredOrderDto: DeliveredOrderDto, options?: any): AxiosPromise<OrderStatusResponseDto> {
            return localVarFp.deliverOrder(deliveredOrderDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all orders across all statuses
         * @param {string} businessIds Comma-separated list of business IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrdersV2(businessIds: string, options?: any): AxiosPromise<Array<OrderResponseDto>> {
            return localVarFp.getAllOrdersV2(businessIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns paginated orders sorted by status-specific logic. Database and POS orders are combined and sorted before pagination is applied.
         * @summary Get all orders across all statuses with pagination
         * @param {string} businessIds Comma-separated list of business IDs
         * @param {number} [limit] Number of items per page (max 100)
         * @param {number} [page] Page number (starts from 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrdersV3(businessIds: string, limit?: number, page?: number, options?: any): AxiosPromise<PaginatedOrderResponseDto> {
            return localVarFp.getAllOrdersV3(businessIds, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get orders by status
         * @param {'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft'} status Order status filter
         * @param {string} businessIds Comma-separated list of business IDs
         * @param {string} [posBusinessId] Id of the pos
         * @param {'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk'} [extraProvider] Extra attributes to get POS orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersV2(status: 'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft', businessIds: string, posBusinessId?: string, extraProvider?: 'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk', options?: any): AxiosPromise<Array<OrderResponseDto>> {
            return localVarFp.getOrdersV2(status, businessIds, posBusinessId, extraProvider, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns paginated orders filtered by status and sorted by status-specific logic. Database and POS orders are combined and sorted before pagination is applied.
         * @summary Get orders by status with pagination
         * @param {'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft'} status Order status filter
         * @param {string} businessIds Comma-separated list of business IDs
         * @param {number} [limit] Number of items per page (max 100)
         * @param {number} [page] Page number (starts from 1)
         * @param {string} [posBusinessId] Id of the pos
         * @param {'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk'} [extraProvider] Extra attributes to get POS orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersV3(status: 'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft', businessIds: string, limit?: number, page?: number, posBusinessId?: string, extraProvider?: 'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk', options?: any): AxiosPromise<PaginatedOrderResponseDto> {
            return localVarFp.getOrdersV3(status, businessIds, limit, page, posBusinessId, extraProvider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all Pos park order
         * @param {string} businessId Id of the pos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParkedPosOrder(businessId: string, options?: any): AxiosPromise<Array<FirebasePosOrderResponse>> {
            return localVarFp.getParkedPosOrder(businessId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all Pos park order
         * @param {string} businessId Id of the pos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParkedPosOrderV2(businessId: string, options?: any): AxiosPromise<Array<PosOrderDto>> {
            return localVarFp.getParkedPosOrderV2(businessId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark an order as ready for pickup/delivery
         * @param {ReadyOrderDto} readyOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markOrderAsReady(readyOrderDto: ReadyOrderDto, options?: any): AxiosPromise<OrderStatusResponseDto> {
            return localVarFp.markOrderAsReady(readyOrderDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Place an POS order
         * @param {PosOrderPayloadDto} posOrderPayloadDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placePosOrder(posOrderPayloadDto: PosOrderPayloadDto, options?: any): AxiosPromise<FirebasePosOrderResponse> {
            return localVarFp.placePosOrder(posOrderPayloadDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Place an POS order
         * @param {PosOrderPayloadDto} posOrderPayloadDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placePosOrderV2(posOrderPayloadDto: PosOrderPayloadDto, options?: any): AxiosPromise<PosOrderDto> {
            return localVarFp.placePosOrderV2(posOrderPayloadDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Place an POS order
         * @param {PosOrderPayloadDto} posOrderPayloadDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placePosOrderV3(posOrderPayloadDto: PosOrderPayloadDto, options?: any): AxiosPromise<PosOrderDto> {
            return localVarFp.placePosOrderV3(posOrderPayloadDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Place an POS order
         * @param {PosOrderPayloadDto} posOrderPayloadDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placePosOrderV4(posOrderPayloadDto: PosOrderPayloadDto, options?: any): AxiosPromise<PosOrderDto> {
            return localVarFp.placePosOrderV4(posOrderPayloadDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Process multiple actions for a POS order
         * @summary Process pos order actions
         * @param {ProcessOrderActionsDto} processOrderActionsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPosOrderActions(processOrderActionsDto: ProcessOrderActionsDto, options?: any): AxiosPromise<ProcessOrderActionsResponseDto> {
            return localVarFp.processPosOrderActions(processOrderActionsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reject an order
         * @param {RejectOrderDto} rejectOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectOrder(rejectOrderDto: RejectOrderDto, options?: any): AxiosPromise<OrderStatusResponseDto> {
            return localVarFp.rejectOrder(rejectOrderDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send a POS order ticket
         * @param {SendPosOrderTicketDto} sendPosOrderTicketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPosOrderTicket(sendPosOrderTicketDto: SendPosOrderTicketDto, options?: any): AxiosPromise<FirebasePosOrderResponse> {
            return localVarFp.sendPosOrderTicket(sendPosOrderTicketDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send a POS order ticket
         * @param {SendPosOrderTicketDto} sendPosOrderTicketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPosOrderTicketV2(sendPosOrderTicketDto: SendPosOrderTicketDto, options?: any): AxiosPromise<PosOrderDto> {
            return localVarFp.sendPosOrderTicketV2(sendPosOrderTicketDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a POS order status
         * @param {PosUpdateOrderDto} posUpdateOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePosOrder(posUpdateOrderDto: PosUpdateOrderDto, options?: any): AxiosPromise<OrderStatusResponseDto> {
            return localVarFp.updatePosOrder(posUpdateOrderDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a POS order status
         * @param {PosUpdateOrderDto} posUpdateOrderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePosOrderV2(posUpdateOrderDto: PosUpdateOrderDto, options?: any): AxiosPromise<OrderStatusResponseDto> {
            return localVarFp.updatePosOrderV2(posUpdateOrderDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - interface
 * @export
 * @interface OrdersApi
 */
export interface OrdersApiInterface {
    /**
     * 
     * @summary Accept an order
     * @param {AcceptOrderDto} acceptOrderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    acceptOrder(acceptOrderDto: AcceptOrderDto, options?: AxiosRequestConfig): AxiosPromise<OrderStatusResponseDto>;

    /**
     * 
     * @summary Confirm a pre-order
     * @param {ConfirmPreorderDto} confirmPreorderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    confirmPreOrder(confirmPreorderDto: ConfirmPreorderDto, options?: AxiosRequestConfig): AxiosPromise<OrderStatusResponseDto>;

    /**
     * 
     * @summary Remove a parked pos order
     * @param {DeletePosOrderDto} deletePosOrderDto Id of the pos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    deletePosParkedOrder(deletePosOrderDto: DeletePosOrderDto, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Remove a parked pos order
     * @param {DeletePosOrderDto} deletePosOrderDto Id of the pos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    deletePosParkedOrderV2(deletePosOrderDto: DeletePosOrderDto, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Mark an order as delivered to customer or picked-up by driver
     * @param {DeliveredOrderDto} deliveredOrderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    deliverOrder(deliveredOrderDto: DeliveredOrderDto, options?: AxiosRequestConfig): AxiosPromise<OrderStatusResponseDto>;

    /**
     * 
     * @summary Get all orders across all statuses
     * @param {string} businessIds Comma-separated list of business IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    getAllOrdersV2(businessIds: string, options?: AxiosRequestConfig): AxiosPromise<Array<OrderResponseDto>>;

    /**
     * Returns paginated orders sorted by status-specific logic. Database and POS orders are combined and sorted before pagination is applied.
     * @summary Get all orders across all statuses with pagination
     * @param {string} businessIds Comma-separated list of business IDs
     * @param {number} [limit] Number of items per page (max 100)
     * @param {number} [page] Page number (starts from 1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    getAllOrdersV3(businessIds: string, limit?: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedOrderResponseDto>;

    /**
     * 
     * @summary Get orders by status
     * @param {'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft'} status Order status filter
     * @param {string} businessIds Comma-separated list of business IDs
     * @param {string} [posBusinessId] Id of the pos
     * @param {'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk'} [extraProvider] Extra attributes to get POS orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    getOrdersV2(status: 'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft', businessIds: string, posBusinessId?: string, extraProvider?: 'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk', options?: AxiosRequestConfig): AxiosPromise<Array<OrderResponseDto>>;

    /**
     * Returns paginated orders filtered by status and sorted by status-specific logic. Database and POS orders are combined and sorted before pagination is applied.
     * @summary Get orders by status with pagination
     * @param {'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft'} status Order status filter
     * @param {string} businessIds Comma-separated list of business IDs
     * @param {number} [limit] Number of items per page (max 100)
     * @param {number} [page] Page number (starts from 1)
     * @param {string} [posBusinessId] Id of the pos
     * @param {'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk'} [extraProvider] Extra attributes to get POS orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    getOrdersV3(status: 'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft', businessIds: string, limit?: number, page?: number, posBusinessId?: string, extraProvider?: 'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk', options?: AxiosRequestConfig): AxiosPromise<PaginatedOrderResponseDto>;

    /**
     * 
     * @summary Get all Pos park order
     * @param {string} businessId Id of the pos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    getParkedPosOrder(businessId: string, options?: AxiosRequestConfig): AxiosPromise<Array<FirebasePosOrderResponse>>;

    /**
     * 
     * @summary Get all Pos park order
     * @param {string} businessId Id of the pos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    getParkedPosOrderV2(businessId: string, options?: AxiosRequestConfig): AxiosPromise<Array<PosOrderDto>>;

    /**
     * 
     * @summary Mark an order as ready for pickup/delivery
     * @param {ReadyOrderDto} readyOrderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    markOrderAsReady(readyOrderDto: ReadyOrderDto, options?: AxiosRequestConfig): AxiosPromise<OrderStatusResponseDto>;

    /**
     * 
     * @summary Place an POS order
     * @param {PosOrderPayloadDto} posOrderPayloadDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    placePosOrder(posOrderPayloadDto: PosOrderPayloadDto, options?: AxiosRequestConfig): AxiosPromise<FirebasePosOrderResponse>;

    /**
     * 
     * @summary Place an POS order
     * @param {PosOrderPayloadDto} posOrderPayloadDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    placePosOrderV2(posOrderPayloadDto: PosOrderPayloadDto, options?: AxiosRequestConfig): AxiosPromise<PosOrderDto>;

    /**
     * 
     * @summary Place an POS order
     * @param {PosOrderPayloadDto} posOrderPayloadDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    placePosOrderV3(posOrderPayloadDto: PosOrderPayloadDto, options?: AxiosRequestConfig): AxiosPromise<PosOrderDto>;

    /**
     * 
     * @summary Place an POS order
     * @param {PosOrderPayloadDto} posOrderPayloadDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    placePosOrderV4(posOrderPayloadDto: PosOrderPayloadDto, options?: AxiosRequestConfig): AxiosPromise<PosOrderDto>;

    /**
     * Process multiple actions for a POS order
     * @summary Process pos order actions
     * @param {ProcessOrderActionsDto} processOrderActionsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    processPosOrderActions(processOrderActionsDto: ProcessOrderActionsDto, options?: AxiosRequestConfig): AxiosPromise<ProcessOrderActionsResponseDto>;

    /**
     * 
     * @summary Reject an order
     * @param {RejectOrderDto} rejectOrderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    rejectOrder(rejectOrderDto: RejectOrderDto, options?: AxiosRequestConfig): AxiosPromise<OrderStatusResponseDto>;

    /**
     * 
     * @summary Send a POS order ticket
     * @param {SendPosOrderTicketDto} sendPosOrderTicketDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    sendPosOrderTicket(sendPosOrderTicketDto: SendPosOrderTicketDto, options?: AxiosRequestConfig): AxiosPromise<FirebasePosOrderResponse>;

    /**
     * 
     * @summary Send a POS order ticket
     * @param {SendPosOrderTicketDto} sendPosOrderTicketDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    sendPosOrderTicketV2(sendPosOrderTicketDto: SendPosOrderTicketDto, options?: AxiosRequestConfig): AxiosPromise<PosOrderDto>;

    /**
     * 
     * @summary Update a POS order status
     * @param {PosUpdateOrderDto} posUpdateOrderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    updatePosOrder(posUpdateOrderDto: PosUpdateOrderDto, options?: AxiosRequestConfig): AxiosPromise<OrderStatusResponseDto>;

    /**
     * 
     * @summary Update a POS order status
     * @param {PosUpdateOrderDto} posUpdateOrderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    updatePosOrderV2(posUpdateOrderDto: PosUpdateOrderDto, options?: AxiosRequestConfig): AxiosPromise<OrderStatusResponseDto>;

}

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI implements OrdersApiInterface {
    /**
     * 
     * @summary Accept an order
     * @param {AcceptOrderDto} acceptOrderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public acceptOrder(acceptOrderDto: AcceptOrderDto, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).acceptOrder(acceptOrderDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Confirm a pre-order
     * @param {ConfirmPreorderDto} confirmPreorderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public confirmPreOrder(confirmPreorderDto: ConfirmPreorderDto, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).confirmPreOrder(confirmPreorderDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a parked pos order
     * @param {DeletePosOrderDto} deletePosOrderDto Id of the pos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public deletePosParkedOrder(deletePosOrderDto: DeletePosOrderDto, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).deletePosParkedOrder(deletePosOrderDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a parked pos order
     * @param {DeletePosOrderDto} deletePosOrderDto Id of the pos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public deletePosParkedOrderV2(deletePosOrderDto: DeletePosOrderDto, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).deletePosParkedOrderV2(deletePosOrderDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark an order as delivered to customer or picked-up by driver
     * @param {DeliveredOrderDto} deliveredOrderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public deliverOrder(deliveredOrderDto: DeliveredOrderDto, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).deliverOrder(deliveredOrderDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all orders across all statuses
     * @param {string} businessIds Comma-separated list of business IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getAllOrdersV2(businessIds: string, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getAllOrdersV2(businessIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns paginated orders sorted by status-specific logic. Database and POS orders are combined and sorted before pagination is applied.
     * @summary Get all orders across all statuses with pagination
     * @param {string} businessIds Comma-separated list of business IDs
     * @param {number} [limit] Number of items per page (max 100)
     * @param {number} [page] Page number (starts from 1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getAllOrdersV3(businessIds: string, limit?: number, page?: number, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getAllOrdersV3(businessIds, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get orders by status
     * @param {'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft'} status Order status filter
     * @param {string} businessIds Comma-separated list of business IDs
     * @param {string} [posBusinessId] Id of the pos
     * @param {'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk'} [extraProvider] Extra attributes to get POS orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrdersV2(status: 'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft', businessIds: string, posBusinessId?: string, extraProvider?: 'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk', options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getOrdersV2(status, businessIds, posBusinessId, extraProvider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns paginated orders filtered by status and sorted by status-specific logic. Database and POS orders are combined and sorted before pagination is applied.
     * @summary Get orders by status with pagination
     * @param {'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft'} status Order status filter
     * @param {string} businessIds Comma-separated list of business IDs
     * @param {number} [limit] Number of items per page (max 100)
     * @param {number} [page] Page number (starts from 1)
     * @param {string} [posBusinessId] Id of the pos
     * @param {'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk'} [extraProvider] Extra attributes to get POS orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrdersV3(status: 'pending' | 'in_progress' | 'ready' | 'delivered' | 'rejected' | 'pick_up_by_driver' | 'preorder' | 'accept_by_driver' | 'parked' | 'refunded' | 'draft', businessIds: string, limit?: number, page?: number, posBusinessId?: string, extraProvider?: 'Wolt' | 'MunchiOnline' | 'MunchiKiosk' | 'MunchiPos' | 'UberEats' | 'Foodora' | 'Bolt' | 'MunchiKioskV2' | 'Kiosk', options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getOrdersV3(status, businessIds, limit, page, posBusinessId, extraProvider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all Pos park order
     * @param {string} businessId Id of the pos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getParkedPosOrder(businessId: string, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getParkedPosOrder(businessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all Pos park order
     * @param {string} businessId Id of the pos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getParkedPosOrderV2(businessId: string, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getParkedPosOrderV2(businessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark an order as ready for pickup/delivery
     * @param {ReadyOrderDto} readyOrderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public markOrderAsReady(readyOrderDto: ReadyOrderDto, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).markOrderAsReady(readyOrderDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Place an POS order
     * @param {PosOrderPayloadDto} posOrderPayloadDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public placePosOrder(posOrderPayloadDto: PosOrderPayloadDto, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).placePosOrder(posOrderPayloadDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Place an POS order
     * @param {PosOrderPayloadDto} posOrderPayloadDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public placePosOrderV2(posOrderPayloadDto: PosOrderPayloadDto, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).placePosOrderV2(posOrderPayloadDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Place an POS order
     * @param {PosOrderPayloadDto} posOrderPayloadDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public placePosOrderV3(posOrderPayloadDto: PosOrderPayloadDto, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).placePosOrderV3(posOrderPayloadDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Place an POS order
     * @param {PosOrderPayloadDto} posOrderPayloadDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public placePosOrderV4(posOrderPayloadDto: PosOrderPayloadDto, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).placePosOrderV4(posOrderPayloadDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process multiple actions for a POS order
     * @summary Process pos order actions
     * @param {ProcessOrderActionsDto} processOrderActionsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public processPosOrderActions(processOrderActionsDto: ProcessOrderActionsDto, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).processPosOrderActions(processOrderActionsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reject an order
     * @param {RejectOrderDto} rejectOrderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public rejectOrder(rejectOrderDto: RejectOrderDto, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).rejectOrder(rejectOrderDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send a POS order ticket
     * @param {SendPosOrderTicketDto} sendPosOrderTicketDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public sendPosOrderTicket(sendPosOrderTicketDto: SendPosOrderTicketDto, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).sendPosOrderTicket(sendPosOrderTicketDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send a POS order ticket
     * @param {SendPosOrderTicketDto} sendPosOrderTicketDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public sendPosOrderTicketV2(sendPosOrderTicketDto: SendPosOrderTicketDto, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).sendPosOrderTicketV2(sendPosOrderTicketDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a POS order status
     * @param {PosUpdateOrderDto} posUpdateOrderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public updatePosOrder(posUpdateOrderDto: PosUpdateOrderDto, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).updatePosOrder(posUpdateOrderDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a POS order status
     * @param {PosUpdateOrderDto} posUpdateOrderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public updatePosOrderV2(posUpdateOrderDto: PosUpdateOrderDto, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).updatePosOrderV2(posUpdateOrderDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * POSSessionApi - axios parameter creator
 * @export
 */
export const POSSessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPosSession: async (businessId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getPosSession', 'businessId', businessId)
            const localVarPath = `/api/v1/pos-session/{businessId}`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * POSSessionApi - functional programming interface
 * @export
 */
export const POSSessionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = POSSessionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPosSession(businessId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PosSessionResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPosSession(businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * POSSessionApi - factory interface
 * @export
 */
export const POSSessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = POSSessionApiFp(configuration)
    return {
        /**
         * 
         * @param {number} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPosSession(businessId: number, options?: any): AxiosPromise<PosSessionResponseDto> {
            return localVarFp.getPosSession(businessId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * POSSessionApi - interface
 * @export
 * @interface POSSessionApi
 */
export interface POSSessionApiInterface {
    /**
     * 
     * @param {number} businessId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof POSSessionApiInterface
     */
    getPosSession(businessId: number, options?: AxiosRequestConfig): AxiosPromise<PosSessionResponseDto>;

}

/**
 * POSSessionApi - object-oriented interface
 * @export
 * @class POSSessionApi
 * @extends {BaseAPI}
 */
export class POSSessionApi extends BaseAPI implements POSSessionApiInterface {
    /**
     * 
     * @param {number} businessId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof POSSessionApi
     */
    public getPosSession(businessId: number, options?: AxiosRequestConfig) {
        return POSSessionApiFp(this.configuration).getPosSession(businessId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PasscodeApi - axios parameter creator
 * @export
 */
export const PasscodeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new passcode
         * @param {CreatePasscodeDto} createPasscodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPasscode: async (createPasscodeDto: CreatePasscodeDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPasscodeDto' is not null or undefined
            assertParamExists('createPasscode', 'createPasscodeDto', createPasscodeDto)
            const localVarPath = `/api/v1/passcode/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPasscodeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete passcode
         * @param {number} passcodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePasscode: async (passcodeId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passcodeId' is not null or undefined
            assertParamExists('deletePasscode', 'passcodeId', passcodeId)
            const localVarPath = `/api/v1/passcode/{passcodeId}`
                .replace(`{${"passcodeId"}}`, encodeURIComponent(String(passcodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all available passcodes (business + chain) and permissions for the business
         * @summary Get passcode options and permissions for business
         * @param {number} businessId Business ordering ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPasscodeOptions: async (businessId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getPasscodeOptions', 'businessId', businessId)
            const localVarPath = `/api/v1/passcode/options/{businessId}`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates passcode against business/chain passcodes and returns permissions if valid
         * @summary Validate passcode (optional server-side validation)
         * @param {ValidatePasscodeDto} validatePasscodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePasscode: async (validatePasscodeDto: ValidatePasscodeDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatePasscodeDto' is not null or undefined
            assertParamExists('validatePasscode', 'validatePasscodeDto', validatePasscodeDto)
            const localVarPath = `/api/v1/passcode/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validatePasscodeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasscodeApi - functional programming interface
 * @export
 */
export const PasscodeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasscodeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new passcode
         * @param {CreatePasscodeDto} createPasscodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPasscode(createPasscodeDto: CreatePasscodeDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePasscodeResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPasscode(createPasscodeDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete passcode
         * @param {number} passcodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePasscode(passcodeId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePasscode(passcodeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all available passcodes (business + chain) and permissions for the business
         * @summary Get passcode options and permissions for business
         * @param {number} businessId Business ordering ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPasscodeOptions(businessId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasscodeOptionsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasscodeOptions(businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validates passcode against business/chain passcodes and returns permissions if valid
         * @summary Validate passcode (optional server-side validation)
         * @param {ValidatePasscodeDto} validatePasscodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatePasscode(validatePasscodeDto: ValidatePasscodeDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatePasscodeResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatePasscode(validatePasscodeDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PasscodeApi - factory interface
 * @export
 */
export const PasscodeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasscodeApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new passcode
         * @param {CreatePasscodeDto} createPasscodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPasscode(createPasscodeDto: CreatePasscodeDto, options?: any): AxiosPromise<CreatePasscodeResponseDto> {
            return localVarFp.createPasscode(createPasscodeDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete passcode
         * @param {number} passcodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePasscode(passcodeId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deletePasscode(passcodeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all available passcodes (business + chain) and permissions for the business
         * @summary Get passcode options and permissions for business
         * @param {number} businessId Business ordering ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPasscodeOptions(businessId: number, options?: any): AxiosPromise<PasscodeOptionsResponseDto> {
            return localVarFp.getPasscodeOptions(businessId, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates passcode against business/chain passcodes and returns permissions if valid
         * @summary Validate passcode (optional server-side validation)
         * @param {ValidatePasscodeDto} validatePasscodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePasscode(validatePasscodeDto: ValidatePasscodeDto, options?: any): AxiosPromise<ValidatePasscodeResponseDto> {
            return localVarFp.validatePasscode(validatePasscodeDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PasscodeApi - interface
 * @export
 * @interface PasscodeApi
 */
export interface PasscodeApiInterface {
    /**
     * 
     * @summary Create new passcode
     * @param {CreatePasscodeDto} createPasscodeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasscodeApiInterface
     */
    createPasscode(createPasscodeDto: CreatePasscodeDto, options?: AxiosRequestConfig): AxiosPromise<CreatePasscodeResponseDto>;

    /**
     * 
     * @summary Delete passcode
     * @param {number} passcodeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasscodeApiInterface
     */
    deletePasscode(passcodeId: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns all available passcodes (business + chain) and permissions for the business
     * @summary Get passcode options and permissions for business
     * @param {number} businessId Business ordering ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasscodeApiInterface
     */
    getPasscodeOptions(businessId: number, options?: AxiosRequestConfig): AxiosPromise<PasscodeOptionsResponseDto>;

    /**
     * Validates passcode against business/chain passcodes and returns permissions if valid
     * @summary Validate passcode (optional server-side validation)
     * @param {ValidatePasscodeDto} validatePasscodeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasscodeApiInterface
     */
    validatePasscode(validatePasscodeDto: ValidatePasscodeDto, options?: AxiosRequestConfig): AxiosPromise<ValidatePasscodeResponseDto>;

}

/**
 * PasscodeApi - object-oriented interface
 * @export
 * @class PasscodeApi
 * @extends {BaseAPI}
 */
export class PasscodeApi extends BaseAPI implements PasscodeApiInterface {
    /**
     * 
     * @summary Create new passcode
     * @param {CreatePasscodeDto} createPasscodeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasscodeApi
     */
    public createPasscode(createPasscodeDto: CreatePasscodeDto, options?: AxiosRequestConfig) {
        return PasscodeApiFp(this.configuration).createPasscode(createPasscodeDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete passcode
     * @param {number} passcodeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasscodeApi
     */
    public deletePasscode(passcodeId: number, options?: AxiosRequestConfig) {
        return PasscodeApiFp(this.configuration).deletePasscode(passcodeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all available passcodes (business + chain) and permissions for the business
     * @summary Get passcode options and permissions for business
     * @param {number} businessId Business ordering ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasscodeApi
     */
    public getPasscodeOptions(businessId: number, options?: AxiosRequestConfig) {
        return PasscodeApiFp(this.configuration).getPasscodeOptions(businessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates passcode against business/chain passcodes and returns permissions if valid
     * @summary Validate passcode (optional server-side validation)
     * @param {ValidatePasscodeDto} validatePasscodeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasscodeApi
     */
    public validatePasscode(validatePasscodeDto: ValidatePasscodeDto, options?: AxiosRequestConfig) {
        return PasscodeApiFp(this.configuration).validatePasscode(validatePasscodeDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentApi - axios parameter creator
 * @export
 */
export const PaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiates a request to cancel a Nets payment on a specified terminal.
         * @summary Request Nets payment cancellation
         * @param {NetsCancelPayloadDto} netsCancelPayloadDto Payload containing the terminal ID for payment cancellation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelNetsTransaction: async (netsCancelPayloadDto: NetsCancelPayloadDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'netsCancelPayloadDto' is not null or undefined
            assertParamExists('cancelNetsTransaction', 'netsCancelPayloadDto', netsCancelPayloadDto)
            const localVarPath = `/api/v2/payment/nets/cancelTransaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(netsCancelPayloadDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels a payment intent that has not yet been captured, releasing the authorization hold on customer funds.
         * @summary Cancel a Stripe payment intent
         * @param {PaymentIntentIdDto} paymentIntentIdDto Payment intent ID to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelStripePayment: async (paymentIntentIdDto: PaymentIntentIdDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentIntentIdDto' is not null or undefined
            assertParamExists('cancelStripePayment', 'paymentIntentIdDto', paymentIntentIdDto)
            const localVarPath = `/api/v1/payment/stripe/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentIntentIdDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels a Viva transaction.
         * @summary Cancel a Viva transaction
         * @param {VivaCancelTransactionDto} vivaCancelTransactionDto Payload to cancel a Viva transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransaction: async (vivaCancelTransactionDto: VivaCancelTransactionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vivaCancelTransactionDto' is not null or undefined
            assertParamExists('cancelTransaction', 'vivaCancelTransactionDto', vivaCancelTransactionDto)
            const localVarPath = `/api/v1/payment/viva/cancelTransaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vivaCancelTransactionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates a request to cancel a Viva payment.
         * @summary Request Viva payment cancellation
         * @param {VivaCancelTransactionDto} vivaCancelTransactionDto Payload containing details for Viva payment cancellation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelVivaTransactionV2: async (vivaCancelTransactionDto: VivaCancelTransactionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vivaCancelTransactionDto' is not null or undefined
            assertParamExists('cancelVivaTransactionV2', 'vivaCancelTransactionDto', vivaCancelTransactionDto)
            const localVarPath = `/api/v2/payment/viva/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vivaCancelTransactionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Captures a previously authorized payment intent, transferring funds from the customer to your account.
         * @summary Capture a Stripe payment intent
         * @param {PaymentIntentIdDto} paymentIntentIdDto Payment intent ID to capture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureStripePayment: async (paymentIntentIdDto: PaymentIntentIdDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentIntentIdDto' is not null or undefined
            assertParamExists('captureStripePayment', 'paymentIntentIdDto', paymentIntentIdDto)
            const localVarPath = `/api/v1/payment/stripe/capture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentIntentIdDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests the cleanup or removal of a Nets transaction, typically one that has failed, is pending, or needs to be voided/refunded due to an issue. This operation aims to revert or finalize the state of the transaction on the Nets terminal.
         * @summary Initiate cleanup or removal of a Nets transaction
         * @param {NetsRemoveFailedTransactionPayloadDto} netsRemoveFailedTransactionPayloadDto Payload containing details for the transaction to be cleaned up or refunded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupNetsTransaction: async (netsRemoveFailedTransactionPayloadDto: NetsRemoveFailedTransactionPayloadDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'netsRemoveFailedTransactionPayloadDto' is not null or undefined
            assertParamExists('cleanupNetsTransaction', 'netsRemoveFailedTransactionPayloadDto', netsRemoveFailedTransactionPayloadDto)
            const localVarPath = `/api/v2/payment/nets/cleanupTransaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(netsRemoveFailedTransactionPayloadDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Connect Nets terminal
         * @summary Connect nets device
         * @param {ConnectTerminalPayloadDto} connectTerminalPayloadDto Payload to specify connect criteria for Nets device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectNetsTerminal: async (connectTerminalPayloadDto: ConnectTerminalPayloadDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectTerminalPayloadDto' is not null or undefined
            assertParamExists('connectNetsTerminal', 'connectTerminalPayloadDto', connectTerminalPayloadDto)
            const localVarPath = `/api/v2/payment/nets/connectTerminal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectTerminalPayloadDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Nets payment intent.
         * @summary Create Nets payment
         * @param {CreateNetsTransactionDto} createNetsTransactionDto Net payment creation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNetsPayment: async (createNetsTransactionDto: CreateNetsTransactionDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createNetsTransactionDto' is not null or undefined
            assertParamExists('createNetsPayment', 'createNetsTransactionDto', createNetsTransactionDto)
            const localVarPath = `/api/v2/payment/nets/createPayment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNetsTransactionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Viva payment intent.
         * @summary Create Viva payment
         * @param {VivaCreatePaymentDto} vivaCreatePaymentDto Viva payment creation payload
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createVivaPayment: async (vivaCreatePaymentDto: VivaCreatePaymentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vivaCreatePaymentDto' is not null or undefined
            assertParamExists('createVivaPayment', 'vivaCreatePaymentDto', vivaCreatePaymentDto)
            const localVarPath = `/api/v1/payment/viva/createPayment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vivaCreatePaymentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Viva payment intent.
         * @summary Create Viva payment
         * @param {VivaCreatePaymentDto} vivaCreatePaymentDto Viva payment creation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVivaPaymentV2: async (vivaCreatePaymentDto: VivaCreatePaymentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vivaCreatePaymentDto' is not null or undefined
            assertParamExists('createVivaPaymentV2', 'vivaCreatePaymentDto', vivaCreatePaymentDto)
            const localVarPath = `/api/v2/payment/viva/createPayment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vivaCreatePaymentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Viva payment intent.
         * @summary Create Viva payment
         * @param {VivaCreatePaymentDto} vivaCreatePaymentDto Viva payment creation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVivaPaymentV3: async (vivaCreatePaymentDto: VivaCreatePaymentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vivaCreatePaymentDto' is not null or undefined
            assertParamExists('createVivaPaymentV3', 'vivaCreatePaymentDto', vivaCreatePaymentDto)
            const localVarPath = `/api/v3/payment/viva/createPayment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vivaCreatePaymentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Viva transaction.
         * @summary Create Viva payment
         * @param {CreateTransactionPayloadDto} createTransactionPayloadDto Viva payment creation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVivaTransactionV3: async (createTransactionPayloadDto: CreateTransactionPayloadDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTransactionPayloadDto' is not null or undefined
            assertParamExists('createVivaTransactionV3', 'createTransactionPayloadDto', createTransactionPayloadDto)
            const localVarPath = `/api/v3/payment/viva/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransactionPayloadDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disconnect Nets terminal
         * @summary Disconnect nets device
         * @param {ConnectTerminalPayloadDto} connectTerminalPayloadDto Payload to specify connect criteria for Nets device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectNetsTerminal: async (connectTerminalPayloadDto: ConnectTerminalPayloadDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectTerminalPayloadDto' is not null or undefined
            assertParamExists('disconnectNetsTerminal', 'connectTerminalPayloadDto', connectTerminalPayloadDto)
            const localVarPath = `/api/v2/payment/nets/disconnectTerminal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectTerminalPayloadDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of available Viva payment devices for the associated merchant.
         * @summary Discover Viva payment devices
         * @param {VivaDiscoverDevicesDto} vivaDiscoverDevicesDto Payload to specify discovery criteria for Viva devices.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverDevices: async (vivaDiscoverDevicesDto: VivaDiscoverDevicesDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vivaDiscoverDevicesDto' is not null or undefined
            assertParamExists('discoverDevices', 'vivaDiscoverDevicesDto', vivaDiscoverDevicesDto)
            const localVarPath = `/api/v1/payment/viva/discoverDevices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vivaDiscoverDevicesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of available Nets payment devices for the associated merchant.
         * @summary Discover Nets devices
         * @param {ShareOrderingBusinessIdPayload} shareOrderingBusinessIdPayload Payload to specify discovery criteria for Nets devices.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverNetsDevices: async (shareOrderingBusinessIdPayload: ShareOrderingBusinessIdPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareOrderingBusinessIdPayload' is not null or undefined
            assertParamExists('discoverNetsDevices', 'shareOrderingBusinessIdPayload', shareOrderingBusinessIdPayload)
            const localVarPath = `/api/v2/payment/nets/discoverDevices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shareOrderingBusinessIdPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a connection token for the specified business.
         * @summary Get connection token
         * @param {ConnectionTokenPayloadDto} connectionTokenPayloadDto Connection token payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionToken: async (connectionTokenPayloadDto: ConnectionTokenPayloadDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionTokenPayloadDto' is not null or undefined
            assertParamExists('getConnectionToken', 'connectionTokenPayloadDto', connectionTokenPayloadDto)
            const localVarPath = `/api/v1/payment/connectionToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectionTokenPayloadDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the current status of a payment transaction by its reference ID.
         * @summary Get payment status
         * @param {GetPaymentStatusDto} getPaymentStatusDto Payment status query parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentStatus: async (getPaymentStatusDto: GetPaymentStatusDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getPaymentStatusDto' is not null or undefined
            assertParamExists('getPaymentStatus', 'getPaymentStatusDto', getPaymentStatusDto)
            const localVarPath = `/api/v1/payment/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPaymentStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Stripe Terminal connection token for the specified business. This token is required to initialize the Stripe Terminal SDK.
         * @summary Get Stripe Terminal connection token
         * @param {string} businessId Unique identifier for the business
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (businessId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getToken', 'businessId', businessId)
            const localVarPath = `/api/v1/payment/stripe/connectionToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (businessId !== undefined) {
                localVarQueryParameter['businessId'] = businessId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiate a terminal transaction
         * @summary Initiate a terminal transaction
         * @param {CreateTerminalPaymentDto} createTerminalPaymentDto Pos order refund payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateTerminalTransaction: async (createTerminalPaymentDto: CreateTerminalPaymentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTerminalPaymentDto' is not null or undefined
            assertParamExists('initiateTerminalTransaction', 'createTerminalPaymentDto', createTerminalPaymentDto)
            const localVarPath = `/api/v4/payment/viva/terminal/initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTerminalPaymentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handles refund processing for orders placed through online channels
         * @summary Process refund for online orders
         * @param {OrderResponseDto} orderResponseDto Order details for refund processing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processOnlineOrderRefund: async (orderResponseDto: OrderResponseDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderResponseDto' is not null or undefined
            assertParamExists('processOnlineOrderRefund', 'orderResponseDto', orderResponseDto)
            const localVarPath = `/api/v1/payment/online-orders/refund`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderResponseDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process a cash refund for a previous cash payment transaction.
         * @summary Refund a cash payment
         * @param {CashRefundPayload} cashRefundPayload Payload containing details for the cash refund.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundCashPayment: async (cashRefundPayload: CashRefundPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cashRefundPayload' is not null or undefined
            assertParamExists('refundCashPayment', 'cashRefundPayload', cashRefundPayload)
            const localVarPath = `/api/v2/payment/cash/refund`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cashRefundPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process a cash refund for a previous cash payment transaction.
         * @summary Refund a cash payment
         * @param {CashRefundPayload} cashRefundPayload Payload containing details for the cash refund.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundCashPaymentV3: async (cashRefundPayload: CashRefundPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cashRefundPayload' is not null or undefined
            assertParamExists('refundCashPaymentV3', 'cashRefundPayload', cashRefundPayload)
            const localVarPath = `/api/v3/payment/cash/refund`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cashRefundPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process a manual refund for a previous cash payment transaction.
         * @summary Refund a manual payment
         * @param {ManualRefundPayload} manualRefundPayload Payload containing details for the manual refund.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundManualPayment: async (manualRefundPayload: ManualRefundPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'manualRefundPayload' is not null or undefined
            assertParamExists('refundManualPayment', 'manualRefundPayload', manualRefundPayload)
            const localVarPath = `/api/v2/payment/manual/refund`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manualRefundPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process a manual refund for a previous payment transaction of any type specified in the payload.
         * @summary Refund a manual payment
         * @param {ManualRefundPayload} manualRefundPayload Payload containing details for the manual refund.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundManualPaymentV3: async (manualRefundPayload: ManualRefundPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'manualRefundPayload' is not null or undefined
            assertParamExists('refundManualPaymentV3', 'manualRefundPayload', manualRefundPayload)
            const localVarPath = `/api/v3/payment/manual/refund`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manualRefundPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refund a pos order
         * @summary Refund a pos order with nets
         * @param {RefundPayloadDto} refundPayloadDto Pos order refund payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundNetsTransaction: async (refundPayloadDto: RefundPayloadDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refundPayloadDto' is not null or undefined
            assertParamExists('refundNetsTransaction', 'refundPayloadDto', refundPayloadDto)
            const localVarPath = `/api/v2/payment/nets/refund`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refundPayloadDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refund a pos order
         * @summary Refund a pos order with nets
         * @param {RefundPayloadDtoV4} refundPayloadDtoV4 Pos order refund payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundNetsTransactionV3: async (refundPayloadDtoV4: RefundPayloadDtoV4, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refundPayloadDtoV4' is not null or undefined
            assertParamExists('refundNetsTransactionV3', 'refundPayloadDtoV4', refundPayloadDtoV4)
            const localVarPath = `/api/v3/payment/nets/refund`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refundPayloadDtoV4, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Viva payment intent.
         * @summary Create Viva payment
         * @param {RefundPayloadDto} refundPayloadDto Viva payment creation payload
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        refundPayment: async (refundPayloadDto: RefundPayloadDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refundPayloadDto' is not null or undefined
            assertParamExists('refundPayment', 'refundPayloadDto', refundPayloadDto)
            const localVarPath = `/api/v1/payment/refund`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refundPayloadDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refund a pos order
         * @summary Refund a pos order
         * @param {RefundPayloadDto} refundPayloadDto Pos order refund payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundVivaTransactionV2: async (refundPayloadDto: RefundPayloadDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refundPayloadDto' is not null or undefined
            assertParamExists('refundVivaTransactionV2', 'refundPayloadDto', refundPayloadDto)
            const localVarPath = `/api/v2/payment/refund`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refundPayloadDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refund a pos order
         * @summary Refund a pos order
         * @param {RefundPayloadDto} refundPayloadDto Pos order refund payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundVivaTransactionV3: async (refundPayloadDto: RefundPayloadDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refundPayloadDto' is not null or undefined
            assertParamExists('refundVivaTransactionV3', 'refundPayloadDto', refundPayloadDto)
            const localVarPath = `/api/v3/payment/refund`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refundPayloadDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refund a pos order
         * @summary Refund a pos order
         * @param {RefundPayloadDtoV4} refundPayloadDtoV4 Pos order refund payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundVivaTransactionV4: async (refundPayloadDtoV4: RefundPayloadDtoV4, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refundPayloadDtoV4' is not null or undefined
            assertParamExists('refundVivaTransactionV4', 'refundPayloadDtoV4', refundPayloadDtoV4)
            const localVarPath = `/api/v4/payment/refund`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refundPayloadDtoV4, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentApi - functional programming interface
 * @export
 */
export const PaymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentApiAxiosParamCreator(configuration)
    return {
        /**
         * Initiates a request to cancel a Nets payment on a specified terminal.
         * @summary Request Nets payment cancellation
         * @param {NetsCancelPayloadDto} netsCancelPayloadDto Payload containing the terminal ID for payment cancellation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelNetsTransaction(netsCancelPayloadDto: NetsCancelPayloadDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelNetsTransaction(netsCancelPayloadDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancels a payment intent that has not yet been captured, releasing the authorization hold on customer funds.
         * @summary Cancel a Stripe payment intent
         * @param {PaymentIntentIdDto} paymentIntentIdDto Payment intent ID to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelStripePayment(paymentIntentIdDto: PaymentIntentIdDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripePaymentIntentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelStripePayment(paymentIntentIdDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancels a Viva transaction.
         * @summary Cancel a Viva transaction
         * @param {VivaCancelTransactionDto} vivaCancelTransactionDto Payload to cancel a Viva transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTransaction(vivaCancelTransactionDto: VivaCancelTransactionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTransaction(vivaCancelTransactionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiates a request to cancel a Viva payment.
         * @summary Request Viva payment cancellation
         * @param {VivaCancelTransactionDto} vivaCancelTransactionDto Payload containing details for Viva payment cancellation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelVivaTransactionV2(vivaCancelTransactionDto: VivaCancelTransactionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelVivaTransactionV2(vivaCancelTransactionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Captures a previously authorized payment intent, transferring funds from the customer to your account.
         * @summary Capture a Stripe payment intent
         * @param {PaymentIntentIdDto} paymentIntentIdDto Payment intent ID to capture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async captureStripePayment(paymentIntentIdDto: PaymentIntentIdDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripePaymentIntentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.captureStripePayment(paymentIntentIdDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Requests the cleanup or removal of a Nets transaction, typically one that has failed, is pending, or needs to be voided/refunded due to an issue. This operation aims to revert or finalize the state of the transaction on the Nets terminal.
         * @summary Initiate cleanup or removal of a Nets transaction
         * @param {NetsRemoveFailedTransactionPayloadDto} netsRemoveFailedTransactionPayloadDto Payload containing details for the transaction to be cleaned up or refunded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanupNetsTransaction(netsRemoveFailedTransactionPayloadDto: NetsRemoveFailedTransactionPayloadDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanupNetsTransaction(netsRemoveFailedTransactionPayloadDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Connect Nets terminal
         * @summary Connect nets device
         * @param {ConnectTerminalPayloadDto} connectTerminalPayloadDto Payload to specify connect criteria for Nets device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectNetsTerminal(connectTerminalPayloadDto: ConnectTerminalPayloadDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConnectTerminaldDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectNetsTerminal(connectTerminalPayloadDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Nets payment intent.
         * @summary Create Nets payment
         * @param {CreateNetsTransactionDto} createNetsTransactionDto Net payment creation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNetsPayment(createNetsTransactionDto: CreateNetsTransactionDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateNetsTransactionResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNetsPayment(createNetsTransactionDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Viva payment intent.
         * @summary Create Viva payment
         * @param {VivaCreatePaymentDto} vivaCreatePaymentDto Viva payment creation payload
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createVivaPayment(vivaCreatePaymentDto: VivaCreatePaymentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VivaPaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVivaPayment(vivaCreatePaymentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Viva payment intent.
         * @summary Create Viva payment
         * @param {VivaCreatePaymentDto} vivaCreatePaymentDto Viva payment creation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVivaPaymentV2(vivaCreatePaymentDto: VivaCreatePaymentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VivaPaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVivaPaymentV2(vivaCreatePaymentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Viva payment intent.
         * @summary Create Viva payment
         * @param {VivaCreatePaymentDto} vivaCreatePaymentDto Viva payment creation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVivaPaymentV3(vivaCreatePaymentDto: VivaCreatePaymentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VivaPaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVivaPaymentV3(vivaCreatePaymentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Viva transaction.
         * @summary Create Viva payment
         * @param {CreateTransactionPayloadDto} createTransactionPayloadDto Viva payment creation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVivaTransactionV3(createTransactionPayloadDto: CreateTransactionPayloadDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VivaPaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVivaTransactionV3(createTransactionPayloadDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disconnect Nets terminal
         * @summary Disconnect nets device
         * @param {ConnectTerminalPayloadDto} connectTerminalPayloadDto Payload to specify connect criteria for Nets device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disconnectNetsTerminal(connectTerminalPayloadDto: ConnectTerminalPayloadDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disconnectNetsTerminal(connectTerminalPayloadDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of available Viva payment devices for the associated merchant.
         * @summary Discover Viva payment devices
         * @param {VivaDiscoverDevicesDto} vivaDiscoverDevicesDto Payload to specify discovery criteria for Viva devices.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discoverDevices(vivaDiscoverDevicesDto: VivaDiscoverDevicesDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VivaDevice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discoverDevices(vivaDiscoverDevicesDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of available Nets payment devices for the associated merchant.
         * @summary Discover Nets devices
         * @param {ShareOrderingBusinessIdPayload} shareOrderingBusinessIdPayload Payload to specify discovery criteria for Nets devices.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discoverNetsDevices(shareOrderingBusinessIdPayload: ShareOrderingBusinessIdPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DiscoveredNetsTerminalDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discoverNetsDevices(shareOrderingBusinessIdPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a connection token for the specified business.
         * @summary Get connection token
         * @param {ConnectionTokenPayloadDto} connectionTokenPayloadDto Connection token payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionToken(connectionTokenPayloadDto: ConnectionTokenPayloadDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionTokenResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectionToken(connectionTokenPayloadDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the current status of a payment transaction by its reference ID.
         * @summary Get payment status
         * @param {GetPaymentStatusDto} getPaymentStatusDto Payment status query parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentStatus(getPaymentStatusDto: GetPaymentStatusDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentStatus(getPaymentStatusDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a Stripe Terminal connection token for the specified business. This token is required to initialize the Stripe Terminal SDK.
         * @summary Get Stripe Terminal connection token
         * @param {string} businessId Unique identifier for the business
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(businessId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripeConnectionTokenDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiate a terminal transaction
         * @summary Initiate a terminal transaction
         * @param {CreateTerminalPaymentDto} createTerminalPaymentDto Pos order refund payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateTerminalTransaction(createTerminalPaymentDto: CreateTerminalPaymentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VivaPaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateTerminalTransaction(createTerminalPaymentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Handles refund processing for orders placed through online channels
         * @summary Process refund for online orders
         * @param {OrderResponseDto} orderResponseDto Order details for refund processing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processOnlineOrderRefund(orderResponseDto: OrderResponseDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processOnlineOrderRefund(orderResponseDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Process a cash refund for a previous cash payment transaction.
         * @summary Refund a cash payment
         * @param {CashRefundPayload} cashRefundPayload Payload containing details for the cash refund.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundCashPayment(cashRefundPayload: CashRefundPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentRefundDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundCashPayment(cashRefundPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Process a cash refund for a previous cash payment transaction.
         * @summary Refund a cash payment
         * @param {CashRefundPayload} cashRefundPayload Payload containing details for the cash refund.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundCashPaymentV3(cashRefundPayload: CashRefundPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentRefundDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundCashPaymentV3(cashRefundPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Process a manual refund for a previous cash payment transaction.
         * @summary Refund a manual payment
         * @param {ManualRefundPayload} manualRefundPayload Payload containing details for the manual refund.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundManualPayment(manualRefundPayload: ManualRefundPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentRefundDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundManualPayment(manualRefundPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Process a manual refund for a previous payment transaction of any type specified in the payload.
         * @summary Refund a manual payment
         * @param {ManualRefundPayload} manualRefundPayload Payload containing details for the manual refund.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundManualPaymentV3(manualRefundPayload: ManualRefundPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentRefundDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundManualPaymentV3(manualRefundPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refund a pos order
         * @summary Refund a pos order with nets
         * @param {RefundPayloadDto} refundPayloadDto Pos order refund payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundNetsTransaction(refundPayloadDto: RefundPayloadDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundNetsTransaction(refundPayloadDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refund a pos order
         * @summary Refund a pos order with nets
         * @param {RefundPayloadDtoV4} refundPayloadDtoV4 Pos order refund payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundNetsTransactionV3(refundPayloadDtoV4: RefundPayloadDtoV4, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundNetsTransactionV3(refundPayloadDtoV4, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Viva payment intent.
         * @summary Create Viva payment
         * @param {RefundPayloadDto} refundPayloadDto Viva payment creation payload
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async refundPayment(refundPayloadDto: RefundPayloadDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundPayment(refundPayloadDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refund a pos order
         * @summary Refund a pos order
         * @param {RefundPayloadDto} refundPayloadDto Pos order refund payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundVivaTransactionV2(refundPayloadDto: RefundPayloadDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentRefundDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundVivaTransactionV2(refundPayloadDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refund a pos order
         * @summary Refund a pos order
         * @param {RefundPayloadDto} refundPayloadDto Pos order refund payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundVivaTransactionV3(refundPayloadDto: RefundPayloadDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentRefundDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundVivaTransactionV3(refundPayloadDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refund a pos order
         * @summary Refund a pos order
         * @param {RefundPayloadDtoV4} refundPayloadDtoV4 Pos order refund payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundVivaTransactionV4(refundPayloadDtoV4: RefundPayloadDtoV4, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VivaPaymentResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundVivaTransactionV4(refundPayloadDtoV4, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentApi - factory interface
 * @export
 */
export const PaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentApiFp(configuration)
    return {
        /**
         * Initiates a request to cancel a Nets payment on a specified terminal.
         * @summary Request Nets payment cancellation
         * @param {NetsCancelPayloadDto} netsCancelPayloadDto Payload containing the terminal ID for payment cancellation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelNetsTransaction(netsCancelPayloadDto: NetsCancelPayloadDto, options?: any): AxiosPromise<void> {
            return localVarFp.cancelNetsTransaction(netsCancelPayloadDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels a payment intent that has not yet been captured, releasing the authorization hold on customer funds.
         * @summary Cancel a Stripe payment intent
         * @param {PaymentIntentIdDto} paymentIntentIdDto Payment intent ID to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelStripePayment(paymentIntentIdDto: PaymentIntentIdDto, options?: any): AxiosPromise<StripePaymentIntentDto> {
            return localVarFp.cancelStripePayment(paymentIntentIdDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels a Viva transaction.
         * @summary Cancel a Viva transaction
         * @param {VivaCancelTransactionDto} vivaCancelTransactionDto Payload to cancel a Viva transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransaction(vivaCancelTransactionDto: VivaCancelTransactionDto, options?: any): AxiosPromise<void> {
            return localVarFp.cancelTransaction(vivaCancelTransactionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates a request to cancel a Viva payment.
         * @summary Request Viva payment cancellation
         * @param {VivaCancelTransactionDto} vivaCancelTransactionDto Payload containing details for Viva payment cancellation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelVivaTransactionV2(vivaCancelTransactionDto: VivaCancelTransactionDto, options?: any): AxiosPromise<void> {
            return localVarFp.cancelVivaTransactionV2(vivaCancelTransactionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Captures a previously authorized payment intent, transferring funds from the customer to your account.
         * @summary Capture a Stripe payment intent
         * @param {PaymentIntentIdDto} paymentIntentIdDto Payment intent ID to capture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureStripePayment(paymentIntentIdDto: PaymentIntentIdDto, options?: any): AxiosPromise<StripePaymentIntentDto> {
            return localVarFp.captureStripePayment(paymentIntentIdDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests the cleanup or removal of a Nets transaction, typically one that has failed, is pending, or needs to be voided/refunded due to an issue. This operation aims to revert or finalize the state of the transaction on the Nets terminal.
         * @summary Initiate cleanup or removal of a Nets transaction
         * @param {NetsRemoveFailedTransactionPayloadDto} netsRemoveFailedTransactionPayloadDto Payload containing details for the transaction to be cleaned up or refunded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupNetsTransaction(netsRemoveFailedTransactionPayloadDto: NetsRemoveFailedTransactionPayloadDto, options?: any): AxiosPromise<string> {
            return localVarFp.cleanupNetsTransaction(netsRemoveFailedTransactionPayloadDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Connect Nets terminal
         * @summary Connect nets device
         * @param {ConnectTerminalPayloadDto} connectTerminalPayloadDto Payload to specify connect criteria for Nets device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectNetsTerminal(connectTerminalPayloadDto: ConnectTerminalPayloadDto, options?: any): AxiosPromise<Array<ConnectTerminaldDto>> {
            return localVarFp.connectNetsTerminal(connectTerminalPayloadDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Nets payment intent.
         * @summary Create Nets payment
         * @param {CreateNetsTransactionDto} createNetsTransactionDto Net payment creation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNetsPayment(createNetsTransactionDto: CreateNetsTransactionDto, options?: any): AxiosPromise<CreateNetsTransactionResponseDto> {
            return localVarFp.createNetsPayment(createNetsTransactionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Viva payment intent.
         * @summary Create Viva payment
         * @param {VivaCreatePaymentDto} vivaCreatePaymentDto Viva payment creation payload
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createVivaPayment(vivaCreatePaymentDto: VivaCreatePaymentDto, options?: any): AxiosPromise<VivaPaymentIntent> {
            return localVarFp.createVivaPayment(vivaCreatePaymentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Viva payment intent.
         * @summary Create Viva payment
         * @param {VivaCreatePaymentDto} vivaCreatePaymentDto Viva payment creation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVivaPaymentV2(vivaCreatePaymentDto: VivaCreatePaymentDto, options?: any): AxiosPromise<VivaPaymentIntent> {
            return localVarFp.createVivaPaymentV2(vivaCreatePaymentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Viva payment intent.
         * @summary Create Viva payment
         * @param {VivaCreatePaymentDto} vivaCreatePaymentDto Viva payment creation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVivaPaymentV3(vivaCreatePaymentDto: VivaCreatePaymentDto, options?: any): AxiosPromise<VivaPaymentIntent> {
            return localVarFp.createVivaPaymentV3(vivaCreatePaymentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Viva transaction.
         * @summary Create Viva payment
         * @param {CreateTransactionPayloadDto} createTransactionPayloadDto Viva payment creation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVivaTransactionV3(createTransactionPayloadDto: CreateTransactionPayloadDto, options?: any): AxiosPromise<VivaPaymentIntent> {
            return localVarFp.createVivaTransactionV3(createTransactionPayloadDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Disconnect Nets terminal
         * @summary Disconnect nets device
         * @param {ConnectTerminalPayloadDto} connectTerminalPayloadDto Payload to specify connect criteria for Nets device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectNetsTerminal(connectTerminalPayloadDto: ConnectTerminalPayloadDto, options?: any): AxiosPromise<void> {
            return localVarFp.disconnectNetsTerminal(connectTerminalPayloadDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of available Viva payment devices for the associated merchant.
         * @summary Discover Viva payment devices
         * @param {VivaDiscoverDevicesDto} vivaDiscoverDevicesDto Payload to specify discovery criteria for Viva devices.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverDevices(vivaDiscoverDevicesDto: VivaDiscoverDevicesDto, options?: any): AxiosPromise<Array<VivaDevice>> {
            return localVarFp.discoverDevices(vivaDiscoverDevicesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of available Nets payment devices for the associated merchant.
         * @summary Discover Nets devices
         * @param {ShareOrderingBusinessIdPayload} shareOrderingBusinessIdPayload Payload to specify discovery criteria for Nets devices.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverNetsDevices(shareOrderingBusinessIdPayload: ShareOrderingBusinessIdPayload, options?: any): AxiosPromise<Array<DiscoveredNetsTerminalDto>> {
            return localVarFp.discoverNetsDevices(shareOrderingBusinessIdPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a connection token for the specified business.
         * @summary Get connection token
         * @param {ConnectionTokenPayloadDto} connectionTokenPayloadDto Connection token payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionToken(connectionTokenPayloadDto: ConnectionTokenPayloadDto, options?: any): AxiosPromise<ConnectionTokenResponseDto> {
            return localVarFp.getConnectionToken(connectionTokenPayloadDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the current status of a payment transaction by its reference ID.
         * @summary Get payment status
         * @param {GetPaymentStatusDto} getPaymentStatusDto Payment status query parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentStatus(getPaymentStatusDto: GetPaymentStatusDto, options?: any): AxiosPromise<PaymentStatusDto> {
            return localVarFp.getPaymentStatus(getPaymentStatusDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Stripe Terminal connection token for the specified business. This token is required to initialize the Stripe Terminal SDK.
         * @summary Get Stripe Terminal connection token
         * @param {string} businessId Unique identifier for the business
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(businessId: string, options?: any): AxiosPromise<StripeConnectionTokenDto> {
            return localVarFp.getToken(businessId, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiate a terminal transaction
         * @summary Initiate a terminal transaction
         * @param {CreateTerminalPaymentDto} createTerminalPaymentDto Pos order refund payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateTerminalTransaction(createTerminalPaymentDto: CreateTerminalPaymentDto, options?: any): AxiosPromise<VivaPaymentIntent> {
            return localVarFp.initiateTerminalTransaction(createTerminalPaymentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Handles refund processing for orders placed through online channels
         * @summary Process refund for online orders
         * @param {OrderResponseDto} orderResponseDto Order details for refund processing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processOnlineOrderRefund(orderResponseDto: OrderResponseDto, options?: any): AxiosPromise<void> {
            return localVarFp.processOnlineOrderRefund(orderResponseDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Process a cash refund for a previous cash payment transaction.
         * @summary Refund a cash payment
         * @param {CashRefundPayload} cashRefundPayload Payload containing details for the cash refund.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundCashPayment(cashRefundPayload: CashRefundPayload, options?: any): AxiosPromise<Array<PaymentRefundDto>> {
            return localVarFp.refundCashPayment(cashRefundPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Process a cash refund for a previous cash payment transaction.
         * @summary Refund a cash payment
         * @param {CashRefundPayload} cashRefundPayload Payload containing details for the cash refund.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundCashPaymentV3(cashRefundPayload: CashRefundPayload, options?: any): AxiosPromise<Array<PaymentRefundDto>> {
            return localVarFp.refundCashPaymentV3(cashRefundPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Process a manual refund for a previous cash payment transaction.
         * @summary Refund a manual payment
         * @param {ManualRefundPayload} manualRefundPayload Payload containing details for the manual refund.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundManualPayment(manualRefundPayload: ManualRefundPayload, options?: any): AxiosPromise<Array<PaymentRefundDto>> {
            return localVarFp.refundManualPayment(manualRefundPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Process a manual refund for a previous payment transaction of any type specified in the payload.
         * @summary Refund a manual payment
         * @param {ManualRefundPayload} manualRefundPayload Payload containing details for the manual refund.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundManualPaymentV3(manualRefundPayload: ManualRefundPayload, options?: any): AxiosPromise<Array<PaymentRefundDto>> {
            return localVarFp.refundManualPaymentV3(manualRefundPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Refund a pos order
         * @summary Refund a pos order with nets
         * @param {RefundPayloadDto} refundPayloadDto Pos order refund payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundNetsTransaction(refundPayloadDto: RefundPayloadDto, options?: any): AxiosPromise<string> {
            return localVarFp.refundNetsTransaction(refundPayloadDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Refund a pos order
         * @summary Refund a pos order with nets
         * @param {RefundPayloadDtoV4} refundPayloadDtoV4 Pos order refund payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundNetsTransactionV3(refundPayloadDtoV4: RefundPayloadDtoV4, options?: any): AxiosPromise<string> {
            return localVarFp.refundNetsTransactionV3(refundPayloadDtoV4, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Viva payment intent.
         * @summary Create Viva payment
         * @param {RefundPayloadDto} refundPayloadDto Viva payment creation payload
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        refundPayment(refundPayloadDto: RefundPayloadDto, options?: any): AxiosPromise<void> {
            return localVarFp.refundPayment(refundPayloadDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Refund a pos order
         * @summary Refund a pos order
         * @param {RefundPayloadDto} refundPayloadDto Pos order refund payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundVivaTransactionV2(refundPayloadDto: RefundPayloadDto, options?: any): AxiosPromise<Array<PaymentRefundDto>> {
            return localVarFp.refundVivaTransactionV2(refundPayloadDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Refund a pos order
         * @summary Refund a pos order
         * @param {RefundPayloadDto} refundPayloadDto Pos order refund payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundVivaTransactionV3(refundPayloadDto: RefundPayloadDto, options?: any): AxiosPromise<Array<PaymentRefundDto>> {
            return localVarFp.refundVivaTransactionV3(refundPayloadDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Refund a pos order
         * @summary Refund a pos order
         * @param {RefundPayloadDtoV4} refundPayloadDtoV4 Pos order refund payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundVivaTransactionV4(refundPayloadDtoV4: RefundPayloadDtoV4, options?: any): AxiosPromise<VivaPaymentResultDto> {
            return localVarFp.refundVivaTransactionV4(refundPayloadDtoV4, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentApi - interface
 * @export
 * @interface PaymentApi
 */
export interface PaymentApiInterface {
    /**
     * Initiates a request to cancel a Nets payment on a specified terminal.
     * @summary Request Nets payment cancellation
     * @param {NetsCancelPayloadDto} netsCancelPayloadDto Payload containing the terminal ID for payment cancellation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    cancelNetsTransaction(netsCancelPayloadDto: NetsCancelPayloadDto, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Cancels a payment intent that has not yet been captured, releasing the authorization hold on customer funds.
     * @summary Cancel a Stripe payment intent
     * @param {PaymentIntentIdDto} paymentIntentIdDto Payment intent ID to cancel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    cancelStripePayment(paymentIntentIdDto: PaymentIntentIdDto, options?: AxiosRequestConfig): AxiosPromise<StripePaymentIntentDto>;

    /**
     * Cancels a Viva transaction.
     * @summary Cancel a Viva transaction
     * @param {VivaCancelTransactionDto} vivaCancelTransactionDto Payload to cancel a Viva transaction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    cancelTransaction(vivaCancelTransactionDto: VivaCancelTransactionDto, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Initiates a request to cancel a Viva payment.
     * @summary Request Viva payment cancellation
     * @param {VivaCancelTransactionDto} vivaCancelTransactionDto Payload containing details for Viva payment cancellation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    cancelVivaTransactionV2(vivaCancelTransactionDto: VivaCancelTransactionDto, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Captures a previously authorized payment intent, transferring funds from the customer to your account.
     * @summary Capture a Stripe payment intent
     * @param {PaymentIntentIdDto} paymentIntentIdDto Payment intent ID to capture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    captureStripePayment(paymentIntentIdDto: PaymentIntentIdDto, options?: AxiosRequestConfig): AxiosPromise<StripePaymentIntentDto>;

    /**
     * Requests the cleanup or removal of a Nets transaction, typically one that has failed, is pending, or needs to be voided/refunded due to an issue. This operation aims to revert or finalize the state of the transaction on the Nets terminal.
     * @summary Initiate cleanup or removal of a Nets transaction
     * @param {NetsRemoveFailedTransactionPayloadDto} netsRemoveFailedTransactionPayloadDto Payload containing details for the transaction to be cleaned up or refunded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    cleanupNetsTransaction(netsRemoveFailedTransactionPayloadDto: NetsRemoveFailedTransactionPayloadDto, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * Connect Nets terminal
     * @summary Connect nets device
     * @param {ConnectTerminalPayloadDto} connectTerminalPayloadDto Payload to specify connect criteria for Nets device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    connectNetsTerminal(connectTerminalPayloadDto: ConnectTerminalPayloadDto, options?: AxiosRequestConfig): AxiosPromise<Array<ConnectTerminaldDto>>;

    /**
     * Creates a new Nets payment intent.
     * @summary Create Nets payment
     * @param {CreateNetsTransactionDto} createNetsTransactionDto Net payment creation payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    createNetsPayment(createNetsTransactionDto: CreateNetsTransactionDto, options?: AxiosRequestConfig): AxiosPromise<CreateNetsTransactionResponseDto>;

    /**
     * Creates a new Viva payment intent.
     * @summary Create Viva payment
     * @param {VivaCreatePaymentDto} vivaCreatePaymentDto Viva payment creation payload
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    createVivaPayment(vivaCreatePaymentDto: VivaCreatePaymentDto, options?: AxiosRequestConfig): AxiosPromise<VivaPaymentIntent>;

    /**
     * Creates a new Viva payment intent.
     * @summary Create Viva payment
     * @param {VivaCreatePaymentDto} vivaCreatePaymentDto Viva payment creation payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    createVivaPaymentV2(vivaCreatePaymentDto: VivaCreatePaymentDto, options?: AxiosRequestConfig): AxiosPromise<VivaPaymentIntent>;

    /**
     * Creates a new Viva payment intent.
     * @summary Create Viva payment
     * @param {VivaCreatePaymentDto} vivaCreatePaymentDto Viva payment creation payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    createVivaPaymentV3(vivaCreatePaymentDto: VivaCreatePaymentDto, options?: AxiosRequestConfig): AxiosPromise<VivaPaymentIntent>;

    /**
     * Creates a new Viva transaction.
     * @summary Create Viva payment
     * @param {CreateTransactionPayloadDto} createTransactionPayloadDto Viva payment creation payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    createVivaTransactionV3(createTransactionPayloadDto: CreateTransactionPayloadDto, options?: AxiosRequestConfig): AxiosPromise<VivaPaymentIntent>;

    /**
     * Disconnect Nets terminal
     * @summary Disconnect nets device
     * @param {ConnectTerminalPayloadDto} connectTerminalPayloadDto Payload to specify connect criteria for Nets device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    disconnectNetsTerminal(connectTerminalPayloadDto: ConnectTerminalPayloadDto, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieves a list of available Viva payment devices for the associated merchant.
     * @summary Discover Viva payment devices
     * @param {VivaDiscoverDevicesDto} vivaDiscoverDevicesDto Payload to specify discovery criteria for Viva devices.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    discoverDevices(vivaDiscoverDevicesDto: VivaDiscoverDevicesDto, options?: AxiosRequestConfig): AxiosPromise<Array<VivaDevice>>;

    /**
     * Retrieves a list of available Nets payment devices for the associated merchant.
     * @summary Discover Nets devices
     * @param {ShareOrderingBusinessIdPayload} shareOrderingBusinessIdPayload Payload to specify discovery criteria for Nets devices.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    discoverNetsDevices(shareOrderingBusinessIdPayload: ShareOrderingBusinessIdPayload, options?: AxiosRequestConfig): AxiosPromise<Array<DiscoveredNetsTerminalDto>>;

    /**
     * Retrieves a connection token for the specified business.
     * @summary Get connection token
     * @param {ConnectionTokenPayloadDto} connectionTokenPayloadDto Connection token payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    getConnectionToken(connectionTokenPayloadDto: ConnectionTokenPayloadDto, options?: AxiosRequestConfig): AxiosPromise<ConnectionTokenResponseDto>;

    /**
     * Retrieves the current status of a payment transaction by its reference ID.
     * @summary Get payment status
     * @param {GetPaymentStatusDto} getPaymentStatusDto Payment status query parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    getPaymentStatus(getPaymentStatusDto: GetPaymentStatusDto, options?: AxiosRequestConfig): AxiosPromise<PaymentStatusDto>;

    /**
     * Retrieves a Stripe Terminal connection token for the specified business. This token is required to initialize the Stripe Terminal SDK.
     * @summary Get Stripe Terminal connection token
     * @param {string} businessId Unique identifier for the business
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    getToken(businessId: string, options?: AxiosRequestConfig): AxiosPromise<StripeConnectionTokenDto>;

    /**
     * Initiate a terminal transaction
     * @summary Initiate a terminal transaction
     * @param {CreateTerminalPaymentDto} createTerminalPaymentDto Pos order refund payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    initiateTerminalTransaction(createTerminalPaymentDto: CreateTerminalPaymentDto, options?: AxiosRequestConfig): AxiosPromise<VivaPaymentIntent>;

    /**
     * Handles refund processing for orders placed through online channels
     * @summary Process refund for online orders
     * @param {OrderResponseDto} orderResponseDto Order details for refund processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    processOnlineOrderRefund(orderResponseDto: OrderResponseDto, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Process a cash refund for a previous cash payment transaction.
     * @summary Refund a cash payment
     * @param {CashRefundPayload} cashRefundPayload Payload containing details for the cash refund.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    refundCashPayment(cashRefundPayload: CashRefundPayload, options?: AxiosRequestConfig): AxiosPromise<Array<PaymentRefundDto>>;

    /**
     * Process a cash refund for a previous cash payment transaction.
     * @summary Refund a cash payment
     * @param {CashRefundPayload} cashRefundPayload Payload containing details for the cash refund.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    refundCashPaymentV3(cashRefundPayload: CashRefundPayload, options?: AxiosRequestConfig): AxiosPromise<Array<PaymentRefundDto>>;

    /**
     * Process a manual refund for a previous cash payment transaction.
     * @summary Refund a manual payment
     * @param {ManualRefundPayload} manualRefundPayload Payload containing details for the manual refund.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    refundManualPayment(manualRefundPayload: ManualRefundPayload, options?: AxiosRequestConfig): AxiosPromise<Array<PaymentRefundDto>>;

    /**
     * Process a manual refund for a previous payment transaction of any type specified in the payload.
     * @summary Refund a manual payment
     * @param {ManualRefundPayload} manualRefundPayload Payload containing details for the manual refund.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    refundManualPaymentV3(manualRefundPayload: ManualRefundPayload, options?: AxiosRequestConfig): AxiosPromise<Array<PaymentRefundDto>>;

    /**
     * Refund a pos order
     * @summary Refund a pos order with nets
     * @param {RefundPayloadDto} refundPayloadDto Pos order refund payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    refundNetsTransaction(refundPayloadDto: RefundPayloadDto, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * Refund a pos order
     * @summary Refund a pos order with nets
     * @param {RefundPayloadDtoV4} refundPayloadDtoV4 Pos order refund payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    refundNetsTransactionV3(refundPayloadDtoV4: RefundPayloadDtoV4, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * Creates a new Viva payment intent.
     * @summary Create Viva payment
     * @param {RefundPayloadDto} refundPayloadDto Viva payment creation payload
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    refundPayment(refundPayloadDto: RefundPayloadDto, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Refund a pos order
     * @summary Refund a pos order
     * @param {RefundPayloadDto} refundPayloadDto Pos order refund payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    refundVivaTransactionV2(refundPayloadDto: RefundPayloadDto, options?: AxiosRequestConfig): AxiosPromise<Array<PaymentRefundDto>>;

    /**
     * Refund a pos order
     * @summary Refund a pos order
     * @param {RefundPayloadDto} refundPayloadDto Pos order refund payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    refundVivaTransactionV3(refundPayloadDto: RefundPayloadDto, options?: AxiosRequestConfig): AxiosPromise<Array<PaymentRefundDto>>;

    /**
     * Refund a pos order
     * @summary Refund a pos order
     * @param {RefundPayloadDtoV4} refundPayloadDtoV4 Pos order refund payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    refundVivaTransactionV4(refundPayloadDtoV4: RefundPayloadDtoV4, options?: AxiosRequestConfig): AxiosPromise<VivaPaymentResultDto>;

}

/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
export class PaymentApi extends BaseAPI implements PaymentApiInterface {
    /**
     * Initiates a request to cancel a Nets payment on a specified terminal.
     * @summary Request Nets payment cancellation
     * @param {NetsCancelPayloadDto} netsCancelPayloadDto Payload containing the terminal ID for payment cancellation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public cancelNetsTransaction(netsCancelPayloadDto: NetsCancelPayloadDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).cancelNetsTransaction(netsCancelPayloadDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels a payment intent that has not yet been captured, releasing the authorization hold on customer funds.
     * @summary Cancel a Stripe payment intent
     * @param {PaymentIntentIdDto} paymentIntentIdDto Payment intent ID to cancel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public cancelStripePayment(paymentIntentIdDto: PaymentIntentIdDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).cancelStripePayment(paymentIntentIdDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels a Viva transaction.
     * @summary Cancel a Viva transaction
     * @param {VivaCancelTransactionDto} vivaCancelTransactionDto Payload to cancel a Viva transaction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public cancelTransaction(vivaCancelTransactionDto: VivaCancelTransactionDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).cancelTransaction(vivaCancelTransactionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates a request to cancel a Viva payment.
     * @summary Request Viva payment cancellation
     * @param {VivaCancelTransactionDto} vivaCancelTransactionDto Payload containing details for Viva payment cancellation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public cancelVivaTransactionV2(vivaCancelTransactionDto: VivaCancelTransactionDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).cancelVivaTransactionV2(vivaCancelTransactionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Captures a previously authorized payment intent, transferring funds from the customer to your account.
     * @summary Capture a Stripe payment intent
     * @param {PaymentIntentIdDto} paymentIntentIdDto Payment intent ID to capture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public captureStripePayment(paymentIntentIdDto: PaymentIntentIdDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).captureStripePayment(paymentIntentIdDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requests the cleanup or removal of a Nets transaction, typically one that has failed, is pending, or needs to be voided/refunded due to an issue. This operation aims to revert or finalize the state of the transaction on the Nets terminal.
     * @summary Initiate cleanup or removal of a Nets transaction
     * @param {NetsRemoveFailedTransactionPayloadDto} netsRemoveFailedTransactionPayloadDto Payload containing details for the transaction to be cleaned up or refunded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public cleanupNetsTransaction(netsRemoveFailedTransactionPayloadDto: NetsRemoveFailedTransactionPayloadDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).cleanupNetsTransaction(netsRemoveFailedTransactionPayloadDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Connect Nets terminal
     * @summary Connect nets device
     * @param {ConnectTerminalPayloadDto} connectTerminalPayloadDto Payload to specify connect criteria for Nets device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public connectNetsTerminal(connectTerminalPayloadDto: ConnectTerminalPayloadDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).connectNetsTerminal(connectTerminalPayloadDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Nets payment intent.
     * @summary Create Nets payment
     * @param {CreateNetsTransactionDto} createNetsTransactionDto Net payment creation payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public createNetsPayment(createNetsTransactionDto: CreateNetsTransactionDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).createNetsPayment(createNetsTransactionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Viva payment intent.
     * @summary Create Viva payment
     * @param {VivaCreatePaymentDto} vivaCreatePaymentDto Viva payment creation payload
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public createVivaPayment(vivaCreatePaymentDto: VivaCreatePaymentDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).createVivaPayment(vivaCreatePaymentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Viva payment intent.
     * @summary Create Viva payment
     * @param {VivaCreatePaymentDto} vivaCreatePaymentDto Viva payment creation payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public createVivaPaymentV2(vivaCreatePaymentDto: VivaCreatePaymentDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).createVivaPaymentV2(vivaCreatePaymentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Viva payment intent.
     * @summary Create Viva payment
     * @param {VivaCreatePaymentDto} vivaCreatePaymentDto Viva payment creation payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public createVivaPaymentV3(vivaCreatePaymentDto: VivaCreatePaymentDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).createVivaPaymentV3(vivaCreatePaymentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Viva transaction.
     * @summary Create Viva payment
     * @param {CreateTransactionPayloadDto} createTransactionPayloadDto Viva payment creation payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public createVivaTransactionV3(createTransactionPayloadDto: CreateTransactionPayloadDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).createVivaTransactionV3(createTransactionPayloadDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disconnect Nets terminal
     * @summary Disconnect nets device
     * @param {ConnectTerminalPayloadDto} connectTerminalPayloadDto Payload to specify connect criteria for Nets device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public disconnectNetsTerminal(connectTerminalPayloadDto: ConnectTerminalPayloadDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).disconnectNetsTerminal(connectTerminalPayloadDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of available Viva payment devices for the associated merchant.
     * @summary Discover Viva payment devices
     * @param {VivaDiscoverDevicesDto} vivaDiscoverDevicesDto Payload to specify discovery criteria for Viva devices.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public discoverDevices(vivaDiscoverDevicesDto: VivaDiscoverDevicesDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).discoverDevices(vivaDiscoverDevicesDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of available Nets payment devices for the associated merchant.
     * @summary Discover Nets devices
     * @param {ShareOrderingBusinessIdPayload} shareOrderingBusinessIdPayload Payload to specify discovery criteria for Nets devices.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public discoverNetsDevices(shareOrderingBusinessIdPayload: ShareOrderingBusinessIdPayload, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).discoverNetsDevices(shareOrderingBusinessIdPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a connection token for the specified business.
     * @summary Get connection token
     * @param {ConnectionTokenPayloadDto} connectionTokenPayloadDto Connection token payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getConnectionToken(connectionTokenPayloadDto: ConnectionTokenPayloadDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).getConnectionToken(connectionTokenPayloadDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the current status of a payment transaction by its reference ID.
     * @summary Get payment status
     * @param {GetPaymentStatusDto} getPaymentStatusDto Payment status query parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPaymentStatus(getPaymentStatusDto: GetPaymentStatusDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).getPaymentStatus(getPaymentStatusDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Stripe Terminal connection token for the specified business. This token is required to initialize the Stripe Terminal SDK.
     * @summary Get Stripe Terminal connection token
     * @param {string} businessId Unique identifier for the business
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getToken(businessId: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).getToken(businessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiate a terminal transaction
     * @summary Initiate a terminal transaction
     * @param {CreateTerminalPaymentDto} createTerminalPaymentDto Pos order refund payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public initiateTerminalTransaction(createTerminalPaymentDto: CreateTerminalPaymentDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).initiateTerminalTransaction(createTerminalPaymentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handles refund processing for orders placed through online channels
     * @summary Process refund for online orders
     * @param {OrderResponseDto} orderResponseDto Order details for refund processing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public processOnlineOrderRefund(orderResponseDto: OrderResponseDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).processOnlineOrderRefund(orderResponseDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process a cash refund for a previous cash payment transaction.
     * @summary Refund a cash payment
     * @param {CashRefundPayload} cashRefundPayload Payload containing details for the cash refund.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public refundCashPayment(cashRefundPayload: CashRefundPayload, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).refundCashPayment(cashRefundPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process a cash refund for a previous cash payment transaction.
     * @summary Refund a cash payment
     * @param {CashRefundPayload} cashRefundPayload Payload containing details for the cash refund.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public refundCashPaymentV3(cashRefundPayload: CashRefundPayload, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).refundCashPaymentV3(cashRefundPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process a manual refund for a previous cash payment transaction.
     * @summary Refund a manual payment
     * @param {ManualRefundPayload} manualRefundPayload Payload containing details for the manual refund.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public refundManualPayment(manualRefundPayload: ManualRefundPayload, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).refundManualPayment(manualRefundPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Process a manual refund for a previous payment transaction of any type specified in the payload.
     * @summary Refund a manual payment
     * @param {ManualRefundPayload} manualRefundPayload Payload containing details for the manual refund.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public refundManualPaymentV3(manualRefundPayload: ManualRefundPayload, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).refundManualPaymentV3(manualRefundPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refund a pos order
     * @summary Refund a pos order with nets
     * @param {RefundPayloadDto} refundPayloadDto Pos order refund payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public refundNetsTransaction(refundPayloadDto: RefundPayloadDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).refundNetsTransaction(refundPayloadDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refund a pos order
     * @summary Refund a pos order with nets
     * @param {RefundPayloadDtoV4} refundPayloadDtoV4 Pos order refund payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public refundNetsTransactionV3(refundPayloadDtoV4: RefundPayloadDtoV4, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).refundNetsTransactionV3(refundPayloadDtoV4, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Viva payment intent.
     * @summary Create Viva payment
     * @param {RefundPayloadDto} refundPayloadDto Viva payment creation payload
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public refundPayment(refundPayloadDto: RefundPayloadDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).refundPayment(refundPayloadDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refund a pos order
     * @summary Refund a pos order
     * @param {RefundPayloadDto} refundPayloadDto Pos order refund payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public refundVivaTransactionV2(refundPayloadDto: RefundPayloadDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).refundVivaTransactionV2(refundPayloadDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refund a pos order
     * @summary Refund a pos order
     * @param {RefundPayloadDto} refundPayloadDto Pos order refund payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public refundVivaTransactionV3(refundPayloadDto: RefundPayloadDto, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).refundVivaTransactionV3(refundPayloadDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refund a pos order
     * @summary Refund a pos order
     * @param {RefundPayloadDtoV4} refundPayloadDtoV4 Pos order refund payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public refundVivaTransactionV4(refundPayloadDtoV4: RefundPayloadDtoV4, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).refundVivaTransactionV4(refundPayloadDtoV4, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PluginApi - axios parameter creator
 * @export
 */
export const PluginApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadConfigFile: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/plugin/config.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertBusiness: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/plugin/business/upsert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PluginApi - functional programming interface
 * @export
 */
export const PluginApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PluginApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadConfigFile(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loadConfigFile(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertBusiness(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsertBusiness(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PluginApi - factory interface
 * @export
 */
export const PluginApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PluginApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadConfigFile(options?: any): AxiosPromise<void> {
            return localVarFp.loadConfigFile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertBusiness(options?: any): AxiosPromise<void> {
            return localVarFp.upsertBusiness(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PluginApi - interface
 * @export
 * @interface PluginApi
 */
export interface PluginApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginApiInterface
     */
    loadConfigFile(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginApiInterface
     */
    upsertBusiness(options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * PluginApi - object-oriented interface
 * @export
 * @class PluginApi
 * @extends {BaseAPI}
 */
export class PluginApi extends BaseAPI implements PluginApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginApi
     */
    public loadConfigFile(options?: AxiosRequestConfig) {
        return PluginApiFp(this.configuration).loadConfigFile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginApi
     */
    public upsertBusiness(options?: AxiosRequestConfig) {
        return PluginApiFp(this.configuration).upsertBusiness(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update inventory settings for multiple channels at once
         * @summary Update channel inventory (POS, Kiosk, etc.)
         * @param {string} businessId Business ID
         * @param {string} categoryId Category ID
         * @param {string} productId Product ID
         * @param {UpdateChannelInventoryDto} updateChannelInventoryDto Channel inventory updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChannelInventoryV2: async (businessId: string, categoryId: string, productId: string, updateChannelInventoryDto: UpdateChannelInventoryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('updateChannelInventoryV2', 'businessId', businessId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('updateChannelInventoryV2', 'categoryId', categoryId)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('updateChannelInventoryV2', 'productId', productId)
            // verify required parameter 'updateChannelInventoryDto' is not null or undefined
            assertParamExists('updateChannelInventoryV2', 'updateChannelInventoryDto', updateChannelInventoryDto)
            const localVarPath = `/api/v2/business/{businessId}/categories/{categoryId}/products/{productId}/channel-inventory`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)))
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateChannelInventoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update POS inventory settings
         * @param {string} businessId Business ID
         * @param {string} categoryId Category ID
         * @param {string} productId Product ID
         * @param {UpdatePosInventoryDto} updatePosInventoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePosInventory: async (businessId: string, categoryId: string, productId: string, updatePosInventoryDto: UpdatePosInventoryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('updatePosInventory', 'businessId', businessId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('updatePosInventory', 'categoryId', categoryId)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('updatePosInventory', 'productId', productId)
            // verify required parameter 'updatePosInventoryDto' is not null or undefined
            assertParamExists('updatePosInventory', 'updatePosInventoryDto', updatePosInventoryDto)
            const localVarPath = `/api/v1/business/{businessId}/categories/{categoryId}/products/{productId}/pos-inventory`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)))
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePosInventoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * Update inventory settings for multiple channels at once
         * @summary Update channel inventory (POS, Kiosk, etc.)
         * @param {string} businessId Business ID
         * @param {string} categoryId Category ID
         * @param {string} productId Product ID
         * @param {UpdateChannelInventoryDto} updateChannelInventoryDto Channel inventory updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateChannelInventoryV2(businessId: string, categoryId: string, productId: string, updateChannelInventoryDto: UpdateChannelInventoryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChannelInventoryResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateChannelInventoryV2(businessId, categoryId, productId, updateChannelInventoryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update POS inventory settings
         * @param {string} businessId Business ID
         * @param {string} categoryId Category ID
         * @param {string} productId Product ID
         * @param {UpdatePosInventoryDto} updatePosInventoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePosInventory(businessId: string, categoryId: string, productId: string, updatePosInventoryDto: UpdatePosInventoryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PosInventoryStatusResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePosInventory(businessId, categoryId, productId, updatePosInventoryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * Update inventory settings for multiple channels at once
         * @summary Update channel inventory (POS, Kiosk, etc.)
         * @param {string} businessId Business ID
         * @param {string} categoryId Category ID
         * @param {string} productId Product ID
         * @param {UpdateChannelInventoryDto} updateChannelInventoryDto Channel inventory updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChannelInventoryV2(businessId: string, categoryId: string, productId: string, updateChannelInventoryDto: UpdateChannelInventoryDto, options?: any): AxiosPromise<Array<ChannelInventoryResponseDto>> {
            return localVarFp.updateChannelInventoryV2(businessId, categoryId, productId, updateChannelInventoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update POS inventory settings
         * @param {string} businessId Business ID
         * @param {string} categoryId Category ID
         * @param {string} productId Product ID
         * @param {UpdatePosInventoryDto} updatePosInventoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePosInventory(businessId: string, categoryId: string, productId: string, updatePosInventoryDto: UpdatePosInventoryDto, options?: any): AxiosPromise<PosInventoryStatusResponseDto> {
            return localVarFp.updatePosInventory(businessId, categoryId, productId, updatePosInventoryDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - interface
 * @export
 * @interface ProductApi
 */
export interface ProductApiInterface {
    /**
     * Update inventory settings for multiple channels at once
     * @summary Update channel inventory (POS, Kiosk, etc.)
     * @param {string} businessId Business ID
     * @param {string} categoryId Category ID
     * @param {string} productId Product ID
     * @param {UpdateChannelInventoryDto} updateChannelInventoryDto Channel inventory updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApiInterface
     */
    updateChannelInventoryV2(businessId: string, categoryId: string, productId: string, updateChannelInventoryDto: UpdateChannelInventoryDto, options?: AxiosRequestConfig): AxiosPromise<Array<ChannelInventoryResponseDto>>;

    /**
     * 
     * @summary Update POS inventory settings
     * @param {string} businessId Business ID
     * @param {string} categoryId Category ID
     * @param {string} productId Product ID
     * @param {UpdatePosInventoryDto} updatePosInventoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApiInterface
     */
    updatePosInventory(businessId: string, categoryId: string, productId: string, updatePosInventoryDto: UpdatePosInventoryDto, options?: AxiosRequestConfig): AxiosPromise<PosInventoryStatusResponseDto>;

}

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI implements ProductApiInterface {
    /**
     * Update inventory settings for multiple channels at once
     * @summary Update channel inventory (POS, Kiosk, etc.)
     * @param {string} businessId Business ID
     * @param {string} categoryId Category ID
     * @param {string} productId Product ID
     * @param {UpdateChannelInventoryDto} updateChannelInventoryDto Channel inventory updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public updateChannelInventoryV2(businessId: string, categoryId: string, productId: string, updateChannelInventoryDto: UpdateChannelInventoryDto, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).updateChannelInventoryV2(businessId, categoryId, productId, updateChannelInventoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update POS inventory settings
     * @param {string} businessId Business ID
     * @param {string} categoryId Category ID
     * @param {string} productId Product ID
     * @param {UpdatePosInventoryDto} updatePosInventoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public updatePosInventory(businessId: string, categoryId: string, productId: string, updatePosInventoryDto: UpdatePosInventoryDto, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).updatePosInventory(businessId, categoryId, productId, updatePosInventoryDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProviderApi - axios parameter creator
 * @export
 */
export const ProviderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get supported channels for a business
         * @param {number} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportedChannels: async (businessId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getSupportedChannels', 'businessId', businessId)
            const localVarPath = `/api/v1/provider/supported-channels/{businessId}`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerCredential: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('registerCredential', 'body', body)
            const localVarPath = `/api/v1/provider/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerProvider: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('registerProvider', 'body', body)
            const localVarPath = `/api/v1/provider`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderApi - functional programming interface
 * @export
 */
export const ProviderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProviderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get supported channels for a business
         * @param {number} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupportedChannels(businessId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSupportedChannelsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSupportedChannels(businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerCredential(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerCredential(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerProvider(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerProvider(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProviderApi - factory interface
 * @export
 */
export const ProviderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProviderApiFp(configuration)
    return {
        /**
         * 
         * @summary Get supported channels for a business
         * @param {number} businessId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportedChannels(businessId: number, options?: any): AxiosPromise<GetSupportedChannelsResponseDto> {
            return localVarFp.getSupportedChannels(businessId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerCredential(body: object, options?: any): AxiosPromise<void> {
            return localVarFp.registerCredential(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerProvider(body: object, options?: any): AxiosPromise<void> {
            return localVarFp.registerProvider(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProviderApi - interface
 * @export
 * @interface ProviderApi
 */
export interface ProviderApiInterface {
    /**
     * 
     * @summary Get supported channels for a business
     * @param {number} businessId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    getSupportedChannels(businessId: number, options?: AxiosRequestConfig): AxiosPromise<GetSupportedChannelsResponseDto>;

    /**
     * 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    registerCredential(body: object, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    registerProvider(body: object, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * ProviderApi - object-oriented interface
 * @export
 * @class ProviderApi
 * @extends {BaseAPI}
 */
export class ProviderApi extends BaseAPI implements ProviderApiInterface {
    /**
     * 
     * @summary Get supported channels for a business
     * @param {number} businessId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public getSupportedChannels(businessId: number, options?: AxiosRequestConfig) {
        return ProviderApiFp(this.configuration).getSupportedChannels(businessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public registerCredential(body: object, options?: AxiosRequestConfig) {
        return ProviderApiFp(this.configuration).registerCredential(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public registerProvider(body: object, options?: AxiosRequestConfig) {
        return ProviderApiFp(this.configuration).registerProvider(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RefundsApi - axios parameter creator
 * @export
 */
export const RefundsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} businessId 
         * @param {string} orderId 
         * @param {string} refundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPlan: async (businessId: string, orderId: string, refundId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('cancelPlan', 'businessId', businessId)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('cancelPlan', 'orderId', orderId)
            // verify required parameter 'refundId' is not null or undefined
            assertParamExists('cancelPlan', 'refundId', refundId)
            const localVarPath = `/api/v1/refunds/businesses/{businessId}/orders/{orderId}/plan/{refundId}/cancel`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"refundId"}}`, encodeURIComponent(String(refundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId 
         * @param {string} orderId 
         * @param {CreateRefundPlanDto} createRefundPlanDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefundPlan: async (businessId: string, orderId: string, createRefundPlanDto: CreateRefundPlanDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('createRefundPlan', 'businessId', businessId)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('createRefundPlan', 'orderId', orderId)
            // verify required parameter 'createRefundPlanDto' is not null or undefined
            assertParamExists('createRefundPlan', 'createRefundPlanDto', createRefundPlanDto)
            const localVarPath = `/api/v1/refunds/businesses/{businessId}/orders/{orderId}/plan`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRefundPlanDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId 
         * @param {string} orderId 
         * @param {any} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefundPlan: async (businessId: string, orderId: string, status: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getRefundPlan', 'businessId', businessId)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getRefundPlan', 'orderId', orderId)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('getRefundPlan', 'status', status)
            const localVarPath = `/api/v1/refunds/businesses/{businessId}/orders/{orderId}/refunds`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId 
         * @param {string} orderId 
         * @param {string} refundId 
         * @param {CompletedStepDto} completedStepDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordRefundPlan: async (businessId: string, orderId: string, refundId: string, completedStepDto: CompletedStepDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('recordRefundPlan', 'businessId', businessId)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('recordRefundPlan', 'orderId', orderId)
            // verify required parameter 'refundId' is not null or undefined
            assertParamExists('recordRefundPlan', 'refundId', refundId)
            // verify required parameter 'completedStepDto' is not null or undefined
            assertParamExists('recordRefundPlan', 'completedStepDto', completedStepDto)
            const localVarPath = `/api/v1/refunds/businesses/{businessId}/orders/{orderId}/plan/{refundId}/record`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"refundId"}}`, encodeURIComponent(String(refundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completedStepDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId 
         * @param {string} orderId 
         * @param {string} refundId 
         * @param {ResolveChoiceDto} resolveChoiceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveRefundChoice: async (businessId: string, orderId: string, refundId: string, resolveChoiceDto: ResolveChoiceDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('resolveRefundChoice', 'businessId', businessId)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('resolveRefundChoice', 'orderId', orderId)
            // verify required parameter 'refundId' is not null or undefined
            assertParamExists('resolveRefundChoice', 'refundId', refundId)
            // verify required parameter 'resolveChoiceDto' is not null or undefined
            assertParamExists('resolveRefundChoice', 'resolveChoiceDto', resolveChoiceDto)
            const localVarPath = `/api/v1/refunds/businesses/{businessId}/orders/{orderId}/plan/{refundId}/resolve-choice`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"refundId"}}`, encodeURIComponent(String(refundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resolveChoiceDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId 
         * @param {string} orderId 
         * @param {string} refundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessPlan: async (businessId: string, orderId: string, refundId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('startProcessPlan', 'businessId', businessId)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('startProcessPlan', 'orderId', orderId)
            // verify required parameter 'refundId' is not null or undefined
            assertParamExists('startProcessPlan', 'refundId', refundId)
            const localVarPath = `/api/v1/refunds/businesses/{businessId}/orders/{orderId}/plan/{refundId}/start`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"refundId"}}`, encodeURIComponent(String(refundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RefundsApi - functional programming interface
 * @export
 */
export const RefundsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RefundsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} businessId 
         * @param {string} orderId 
         * @param {string} refundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPlan(businessId: string, orderId: string, refundId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPlan(businessId, orderId, refundId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId 
         * @param {string} orderId 
         * @param {CreateRefundPlanDto} createRefundPlanDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRefundPlan(businessId: string, orderId: string, createRefundPlanDto: CreateRefundPlanDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundPlanDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRefundPlan(businessId, orderId, createRefundPlanDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId 
         * @param {string} orderId 
         * @param {any} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRefundPlan(businessId: string, orderId: string, status: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RefundPlanDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRefundPlan(businessId, orderId, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId 
         * @param {string} orderId 
         * @param {string} refundId 
         * @param {CompletedStepDto} completedStepDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordRefundPlan(businessId: string, orderId: string, refundId: string, completedStepDto: CompletedStepDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundPlanDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordRefundPlan(businessId, orderId, refundId, completedStepDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId 
         * @param {string} orderId 
         * @param {string} refundId 
         * @param {ResolveChoiceDto} resolveChoiceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveRefundChoice(businessId: string, orderId: string, refundId: string, resolveChoiceDto: ResolveChoiceDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundPlanDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveRefundChoice(businessId, orderId, refundId, resolveChoiceDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId 
         * @param {string} orderId 
         * @param {string} refundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProcessPlan(businessId: string, orderId: string, refundId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundPlanDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startProcessPlan(businessId, orderId, refundId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RefundsApi - factory interface
 * @export
 */
export const RefundsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RefundsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} businessId 
         * @param {string} orderId 
         * @param {string} refundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPlan(businessId: string, orderId: string, refundId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelPlan(businessId, orderId, refundId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId 
         * @param {string} orderId 
         * @param {CreateRefundPlanDto} createRefundPlanDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefundPlan(businessId: string, orderId: string, createRefundPlanDto: CreateRefundPlanDto, options?: any): AxiosPromise<RefundPlanDto> {
            return localVarFp.createRefundPlan(businessId, orderId, createRefundPlanDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId 
         * @param {string} orderId 
         * @param {any} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefundPlan(businessId: string, orderId: string, status: any, options?: any): AxiosPromise<Array<RefundPlanDto>> {
            return localVarFp.getRefundPlan(businessId, orderId, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId 
         * @param {string} orderId 
         * @param {string} refundId 
         * @param {CompletedStepDto} completedStepDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordRefundPlan(businessId: string, orderId: string, refundId: string, completedStepDto: CompletedStepDto, options?: any): AxiosPromise<RefundPlanDto> {
            return localVarFp.recordRefundPlan(businessId, orderId, refundId, completedStepDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId 
         * @param {string} orderId 
         * @param {string} refundId 
         * @param {ResolveChoiceDto} resolveChoiceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveRefundChoice(businessId: string, orderId: string, refundId: string, resolveChoiceDto: ResolveChoiceDto, options?: any): AxiosPromise<RefundPlanDto> {
            return localVarFp.resolveRefundChoice(businessId, orderId, refundId, resolveChoiceDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId 
         * @param {string} orderId 
         * @param {string} refundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessPlan(businessId: string, orderId: string, refundId: string, options?: any): AxiosPromise<RefundPlanDto> {
            return localVarFp.startProcessPlan(businessId, orderId, refundId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RefundsApi - interface
 * @export
 * @interface RefundsApi
 */
export interface RefundsApiInterface {
    /**
     * 
     * @param {string} businessId 
     * @param {string} orderId 
     * @param {string} refundId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApiInterface
     */
    cancelPlan(businessId: string, orderId: string, refundId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} businessId 
     * @param {string} orderId 
     * @param {CreateRefundPlanDto} createRefundPlanDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApiInterface
     */
    createRefundPlan(businessId: string, orderId: string, createRefundPlanDto: CreateRefundPlanDto, options?: AxiosRequestConfig): AxiosPromise<RefundPlanDto>;

    /**
     * 
     * @param {string} businessId 
     * @param {string} orderId 
     * @param {any} status 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApiInterface
     */
    getRefundPlan(businessId: string, orderId: string, status: any, options?: AxiosRequestConfig): AxiosPromise<Array<RefundPlanDto>>;

    /**
     * 
     * @param {string} businessId 
     * @param {string} orderId 
     * @param {string} refundId 
     * @param {CompletedStepDto} completedStepDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApiInterface
     */
    recordRefundPlan(businessId: string, orderId: string, refundId: string, completedStepDto: CompletedStepDto, options?: AxiosRequestConfig): AxiosPromise<RefundPlanDto>;

    /**
     * 
     * @param {string} businessId 
     * @param {string} orderId 
     * @param {string} refundId 
     * @param {ResolveChoiceDto} resolveChoiceDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApiInterface
     */
    resolveRefundChoice(businessId: string, orderId: string, refundId: string, resolveChoiceDto: ResolveChoiceDto, options?: AxiosRequestConfig): AxiosPromise<RefundPlanDto>;

    /**
     * 
     * @param {string} businessId 
     * @param {string} orderId 
     * @param {string} refundId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApiInterface
     */
    startProcessPlan(businessId: string, orderId: string, refundId: string, options?: AxiosRequestConfig): AxiosPromise<RefundPlanDto>;

}

/**
 * RefundsApi - object-oriented interface
 * @export
 * @class RefundsApi
 * @extends {BaseAPI}
 */
export class RefundsApi extends BaseAPI implements RefundsApiInterface {
    /**
     * 
     * @param {string} businessId 
     * @param {string} orderId 
     * @param {string} refundId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    public cancelPlan(businessId: string, orderId: string, refundId: string, options?: AxiosRequestConfig) {
        return RefundsApiFp(this.configuration).cancelPlan(businessId, orderId, refundId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId 
     * @param {string} orderId 
     * @param {CreateRefundPlanDto} createRefundPlanDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    public createRefundPlan(businessId: string, orderId: string, createRefundPlanDto: CreateRefundPlanDto, options?: AxiosRequestConfig) {
        return RefundsApiFp(this.configuration).createRefundPlan(businessId, orderId, createRefundPlanDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId 
     * @param {string} orderId 
     * @param {any} status 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    public getRefundPlan(businessId: string, orderId: string, status: any, options?: AxiosRequestConfig) {
        return RefundsApiFp(this.configuration).getRefundPlan(businessId, orderId, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId 
     * @param {string} orderId 
     * @param {string} refundId 
     * @param {CompletedStepDto} completedStepDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    public recordRefundPlan(businessId: string, orderId: string, refundId: string, completedStepDto: CompletedStepDto, options?: AxiosRequestConfig) {
        return RefundsApiFp(this.configuration).recordRefundPlan(businessId, orderId, refundId, completedStepDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId 
     * @param {string} orderId 
     * @param {string} refundId 
     * @param {ResolveChoiceDto} resolveChoiceDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    public resolveRefundChoice(businessId: string, orderId: string, refundId: string, resolveChoiceDto: ResolveChoiceDto, options?: AxiosRequestConfig) {
        return RefundsApiFp(this.configuration).resolveRefundChoice(businessId, orderId, refundId, resolveChoiceDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId 
     * @param {string} orderId 
     * @param {string} refundId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    public startProcessPlan(businessId: string, orderId: string, refundId: string, options?: AxiosRequestConfig) {
        return RefundsApiFp(this.configuration).startProcessPlan(businessId, orderId, refundId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReportApi - axios parameter creator
 * @export
 */
export const ReportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get end-of-day financial report for POS
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOSEndOfDayReport: async (businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('getPOSEndOfDayReport', 'businessIds', businessIds)
            const localVarPath = `/api/v1/report/pos/end-of-day`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeSpan !== undefined) {
                localVarQueryParameter['timeSpan'] = timeSpan;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (businessIds) {
                localVarQueryParameter['businessIds'] = businessIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get end-of-day financial report for POS (V2)
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOSEndOfDayReportV2: async (businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('getPOSEndOfDayReportV2', 'businessIds', businessIds)
            const localVarPath = `/api/v2/report/pos/end-of-day`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeSpan !== undefined) {
                localVarQueryParameter['timeSpan'] = timeSpan;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (businessIds) {
                localVarQueryParameter['businessIds'] = businessIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get end-of-day financial report for POS (V3)
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOSEndOfDayReportV3: async (businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, timezone?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('getPOSEndOfDayReportV3', 'businessIds', businessIds)
            const localVarPath = `/api/v3/report/pos/end-of-day`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeSpan !== undefined) {
                localVarQueryParameter['timeSpan'] = timeSpan;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (businessIds) {
                localVarQueryParameter['businessIds'] = businessIds;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get end-of-day financial report for POS (V4)
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOSEndOfDayReportV4: async (businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, timezone?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('getPOSEndOfDayReportV4', 'businessIds', businessIds)
            const localVarPath = `/api/v4/report/pos/end-of-day`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeSpan !== undefined) {
                localVarQueryParameter['timeSpan'] = timeSpan;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (businessIds) {
                localVarQueryParameter['businessIds'] = businessIds;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send end-of-day report via email
         * @param {Array<number>} businessIds Business ID selected
         * @param {SendReportEmailDto} sendReportEmailDto 
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendReportEmail: async (businessIds: Array<number>, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('sendReportEmail', 'businessIds', businessIds)
            // verify required parameter 'sendReportEmailDto' is not null or undefined
            assertParamExists('sendReportEmail', 'sendReportEmailDto', sendReportEmailDto)
            const localVarPath = `/api/v1/report/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeSpan !== undefined) {
                localVarQueryParameter['timeSpan'] = timeSpan;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (businessIds) {
                localVarQueryParameter['businessIds'] = businessIds;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendReportEmailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send end-of-day report via email (V2)
         * @param {Array<number>} businessIds Business ID selected
         * @param {SendReportEmailDto} sendReportEmailDto 
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendReportEmailV2: async (businessIds: Array<number>, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('sendReportEmailV2', 'businessIds', businessIds)
            // verify required parameter 'sendReportEmailDto' is not null or undefined
            assertParamExists('sendReportEmailV2', 'sendReportEmailDto', sendReportEmailDto)
            const localVarPath = `/api/v2/report/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeSpan !== undefined) {
                localVarQueryParameter['timeSpan'] = timeSpan;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (businessIds) {
                localVarQueryParameter['businessIds'] = businessIds;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendReportEmailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send end-of-day report via email (V3)
         * @param {Array<number>} businessIds Business ID selected
         * @param {string} timezone 
         * @param {SendReportEmailDto} sendReportEmailDto 
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendReportEmailV3: async (businessIds: Array<number>, timezone: string, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('sendReportEmailV3', 'businessIds', businessIds)
            // verify required parameter 'timezone' is not null or undefined
            assertParamExists('sendReportEmailV3', 'timezone', timezone)
            // verify required parameter 'sendReportEmailDto' is not null or undefined
            assertParamExists('sendReportEmailV3', 'sendReportEmailDto', sendReportEmailDto)
            const localVarPath = `/api/v3/report/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeSpan !== undefined) {
                localVarQueryParameter['timeSpan'] = timeSpan;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (businessIds) {
                localVarQueryParameter['businessIds'] = businessIds;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendReportEmailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send end-of-day report via email (V4)
         * @param {Array<number>} businessIds Business ID selected
         * @param {string} timezone 
         * @param {SendReportEmailDto} sendReportEmailDto 
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendReportEmailV4: async (businessIds: Array<number>, timezone: string, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessIds' is not null or undefined
            assertParamExists('sendReportEmailV4', 'businessIds', businessIds)
            // verify required parameter 'timezone' is not null or undefined
            assertParamExists('sendReportEmailV4', 'timezone', timezone)
            // verify required parameter 'sendReportEmailDto' is not null or undefined
            assertParamExists('sendReportEmailV4', 'sendReportEmailDto', sendReportEmailDto)
            const localVarPath = `/api/v4/report/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeSpan !== undefined) {
                localVarQueryParameter['timeSpan'] = timeSpan;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (businessIds) {
                localVarQueryParameter['businessIds'] = businessIds;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendReportEmailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportApi - functional programming interface
 * @export
 */
export const ReportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get end-of-day financial report for POS
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPOSEndOfDayReport(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EndOfDayReportDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPOSEndOfDayReport(businessIds, timeSpan, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get end-of-day financial report for POS (V2)
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPOSEndOfDayReportV2(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EndOfDayReportDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPOSEndOfDayReportV2(businessIds, timeSpan, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get end-of-day financial report for POS (V3)
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPOSEndOfDayReportV3(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, timezone?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EndOfDayReportDtoV3>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPOSEndOfDayReportV3(businessIds, timeSpan, start, end, timezone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get end-of-day financial report for POS (V4)
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPOSEndOfDayReportV4(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, timezone?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EndOfDayReportDtoV4>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPOSEndOfDayReportV4(businessIds, timeSpan, start, end, timezone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send end-of-day report via email
         * @param {Array<number>} businessIds Business ID selected
         * @param {SendReportEmailDto} sendReportEmailDto 
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendReportEmail(businessIds: Array<number>, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendReportEmail(businessIds, sendReportEmailDto, timeSpan, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send end-of-day report via email (V2)
         * @param {Array<number>} businessIds Business ID selected
         * @param {SendReportEmailDto} sendReportEmailDto 
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendReportEmailV2(businessIds: Array<number>, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendReportEmailV2(businessIds, sendReportEmailDto, timeSpan, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send end-of-day report via email (V3)
         * @param {Array<number>} businessIds Business ID selected
         * @param {string} timezone 
         * @param {SendReportEmailDto} sendReportEmailDto 
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendReportEmailV3(businessIds: Array<number>, timezone: string, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendReportEmailV3(businessIds, timezone, sendReportEmailDto, timeSpan, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send end-of-day report via email (V4)
         * @param {Array<number>} businessIds Business ID selected
         * @param {string} timezone 
         * @param {SendReportEmailDto} sendReportEmailDto 
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendReportEmailV4(businessIds: Array<number>, timezone: string, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendReportEmailV4(businessIds, timezone, sendReportEmailDto, timeSpan, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReportApi - factory interface
 * @export
 */
export const ReportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportApiFp(configuration)
    return {
        /**
         * 
         * @summary Get end-of-day financial report for POS
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOSEndOfDayReport(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, options?: any): AxiosPromise<EndOfDayReportDto> {
            return localVarFp.getPOSEndOfDayReport(businessIds, timeSpan, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get end-of-day financial report for POS (V2)
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOSEndOfDayReportV2(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, options?: any): AxiosPromise<EndOfDayReportDto> {
            return localVarFp.getPOSEndOfDayReportV2(businessIds, timeSpan, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get end-of-day financial report for POS (V3)
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOSEndOfDayReportV3(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, timezone?: string, options?: any): AxiosPromise<EndOfDayReportDtoV3> {
            return localVarFp.getPOSEndOfDayReportV3(businessIds, timeSpan, start, end, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get end-of-day financial report for POS (V4)
         * @param {Array<number>} businessIds Business ID selected
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPOSEndOfDayReportV4(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, timezone?: string, options?: any): AxiosPromise<EndOfDayReportDtoV4> {
            return localVarFp.getPOSEndOfDayReportV4(businessIds, timeSpan, start, end, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send end-of-day report via email
         * @param {Array<number>} businessIds Business ID selected
         * @param {SendReportEmailDto} sendReportEmailDto 
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendReportEmail(businessIds: Array<number>, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options?: any): AxiosPromise<void> {
            return localVarFp.sendReportEmail(businessIds, sendReportEmailDto, timeSpan, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send end-of-day report via email (V2)
         * @param {Array<number>} businessIds Business ID selected
         * @param {SendReportEmailDto} sendReportEmailDto 
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendReportEmailV2(businessIds: Array<number>, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options?: any): AxiosPromise<void> {
            return localVarFp.sendReportEmailV2(businessIds, sendReportEmailDto, timeSpan, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send end-of-day report via email (V3)
         * @param {Array<number>} businessIds Business ID selected
         * @param {string} timezone 
         * @param {SendReportEmailDto} sendReportEmailDto 
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendReportEmailV3(businessIds: Array<number>, timezone: string, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options?: any): AxiosPromise<void> {
            return localVarFp.sendReportEmailV3(businessIds, timezone, sendReportEmailDto, timeSpan, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send end-of-day report via email (V4)
         * @param {Array<number>} businessIds Business ID selected
         * @param {string} timezone 
         * @param {SendReportEmailDto} sendReportEmailDto 
         * @param {TimeSpan} [timeSpan] Time span
         * @param {string} [start] Start date
         * @param {string} [end] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendReportEmailV4(businessIds: Array<number>, timezone: string, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options?: any): AxiosPromise<void> {
            return localVarFp.sendReportEmailV4(businessIds, timezone, sendReportEmailDto, timeSpan, start, end, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportApi - interface
 * @export
 * @interface ReportApi
 */
export interface ReportApiInterface {
    /**
     * 
     * @summary Get end-of-day financial report for POS
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApiInterface
     */
    getPOSEndOfDayReport(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, options?: AxiosRequestConfig): AxiosPromise<EndOfDayReportDto>;

    /**
     * 
     * @summary Get end-of-day financial report for POS (V2)
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApiInterface
     */
    getPOSEndOfDayReportV2(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, options?: AxiosRequestConfig): AxiosPromise<EndOfDayReportDto>;

    /**
     * 
     * @summary Get end-of-day financial report for POS (V3)
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApiInterface
     */
    getPOSEndOfDayReportV3(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, timezone?: string, options?: AxiosRequestConfig): AxiosPromise<EndOfDayReportDtoV3>;

    /**
     * 
     * @summary Get end-of-day financial report for POS (V4)
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApiInterface
     */
    getPOSEndOfDayReportV4(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, timezone?: string, options?: AxiosRequestConfig): AxiosPromise<EndOfDayReportDtoV4>;

    /**
     * 
     * @summary Send end-of-day report via email
     * @param {Array<number>} businessIds Business ID selected
     * @param {SendReportEmailDto} sendReportEmailDto 
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApiInterface
     */
    sendReportEmail(businessIds: Array<number>, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Send end-of-day report via email (V2)
     * @param {Array<number>} businessIds Business ID selected
     * @param {SendReportEmailDto} sendReportEmailDto 
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApiInterface
     */
    sendReportEmailV2(businessIds: Array<number>, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Send end-of-day report via email (V3)
     * @param {Array<number>} businessIds Business ID selected
     * @param {string} timezone 
     * @param {SendReportEmailDto} sendReportEmailDto 
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApiInterface
     */
    sendReportEmailV3(businessIds: Array<number>, timezone: string, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Send end-of-day report via email (V4)
     * @param {Array<number>} businessIds Business ID selected
     * @param {string} timezone 
     * @param {SendReportEmailDto} sendReportEmailDto 
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApiInterface
     */
    sendReportEmailV4(businessIds: Array<number>, timezone: string, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * ReportApi - object-oriented interface
 * @export
 * @class ReportApi
 * @extends {BaseAPI}
 */
export class ReportApi extends BaseAPI implements ReportApiInterface {
    /**
     * 
     * @summary Get end-of-day financial report for POS
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getPOSEndOfDayReport(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getPOSEndOfDayReport(businessIds, timeSpan, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get end-of-day financial report for POS (V2)
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getPOSEndOfDayReportV2(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getPOSEndOfDayReportV2(businessIds, timeSpan, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get end-of-day financial report for POS (V3)
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getPOSEndOfDayReportV3(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, timezone?: string, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getPOSEndOfDayReportV3(businessIds, timeSpan, start, end, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get end-of-day financial report for POS (V4)
     * @param {Array<number>} businessIds Business ID selected
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {string} [timezone] Timezone (default is \&quot;UTC\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getPOSEndOfDayReportV4(businessIds: Array<number>, timeSpan?: TimeSpan, start?: string, end?: string, timezone?: string, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).getPOSEndOfDayReportV4(businessIds, timeSpan, start, end, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send end-of-day report via email
     * @param {Array<number>} businessIds Business ID selected
     * @param {SendReportEmailDto} sendReportEmailDto 
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public sendReportEmail(businessIds: Array<number>, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).sendReportEmail(businessIds, sendReportEmailDto, timeSpan, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send end-of-day report via email (V2)
     * @param {Array<number>} businessIds Business ID selected
     * @param {SendReportEmailDto} sendReportEmailDto 
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public sendReportEmailV2(businessIds: Array<number>, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).sendReportEmailV2(businessIds, sendReportEmailDto, timeSpan, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send end-of-day report via email (V3)
     * @param {Array<number>} businessIds Business ID selected
     * @param {string} timezone 
     * @param {SendReportEmailDto} sendReportEmailDto 
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public sendReportEmailV3(businessIds: Array<number>, timezone: string, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).sendReportEmailV3(businessIds, timezone, sendReportEmailDto, timeSpan, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send end-of-day report via email (V4)
     * @param {Array<number>} businessIds Business ID selected
     * @param {string} timezone 
     * @param {SendReportEmailDto} sendReportEmailDto 
     * @param {TimeSpan} [timeSpan] Time span
     * @param {string} [start] Start date
     * @param {string} [end] End date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public sendReportEmailV4(businessIds: Array<number>, timezone: string, sendReportEmailDto: SendReportEmailDto, timeSpan?: TimeSpan, start?: string, end?: string, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).sendReportEmailV4(businessIds, timezone, sendReportEmailDto, timeSpan, start, end, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RolesPermissionsApi - axios parameter creator
 * @export
 */
export const RolesPermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateActionPasscodeDto} createActionPasscodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionPasscode: async (createActionPasscodeDto: CreateActionPasscodeDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createActionPasscodeDto' is not null or undefined
            assertParamExists('createActionPasscode', 'createActionPasscodeDto', createActionPasscodeDto)
            const localVarPath = `/api/v1/action-passcodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createActionPasscodeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} businessId 
         * @param {CreateRoleDto} createRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (businessId: number, createRoleDto: CreateRoleDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('createRole', 'businessId', businessId)
            // verify required parameter 'createRoleDto' is not null or undefined
            assertParamExists('createRole', 'createRoleDto', createRoleDto)
            const localVarPath = `/api/v1/businesses/{businessId}/roles`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesPermissionsApi - functional programming interface
 * @export
 */
export const RolesPermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesPermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateActionPasscodeDto} createActionPasscodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActionPasscode(createActionPasscodeDto: CreateActionPasscodeDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionPasscodeResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createActionPasscode(createActionPasscodeDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} businessId 
         * @param {CreateRoleDto} createRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(businessId: number, createRoleDto: CreateRoleDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(businessId, createRoleDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RolesPermissionsApi - factory interface
 * @export
 */
export const RolesPermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesPermissionsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateActionPasscodeDto} createActionPasscodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActionPasscode(createActionPasscodeDto: CreateActionPasscodeDto, options?: any): AxiosPromise<ActionPasscodeResponseDto> {
            return localVarFp.createActionPasscode(createActionPasscodeDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} businessId 
         * @param {CreateRoleDto} createRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(businessId: number, createRoleDto: CreateRoleDto, options?: any): AxiosPromise<RoleResponseDto> {
            return localVarFp.createRole(businessId, createRoleDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesPermissionsApi - interface
 * @export
 * @interface RolesPermissionsApi
 */
export interface RolesPermissionsApiInterface {
    /**
     * 
     * @param {CreateActionPasscodeDto} createActionPasscodeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesPermissionsApiInterface
     */
    createActionPasscode(createActionPasscodeDto: CreateActionPasscodeDto, options?: AxiosRequestConfig): AxiosPromise<ActionPasscodeResponseDto>;

    /**
     * 
     * @param {number} businessId 
     * @param {CreateRoleDto} createRoleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesPermissionsApiInterface
     */
    createRole(businessId: number, createRoleDto: CreateRoleDto, options?: AxiosRequestConfig): AxiosPromise<RoleResponseDto>;

}

/**
 * RolesPermissionsApi - object-oriented interface
 * @export
 * @class RolesPermissionsApi
 * @extends {BaseAPI}
 */
export class RolesPermissionsApi extends BaseAPI implements RolesPermissionsApiInterface {
    /**
     * 
     * @param {CreateActionPasscodeDto} createActionPasscodeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesPermissionsApi
     */
    public createActionPasscode(createActionPasscodeDto: CreateActionPasscodeDto, options?: AxiosRequestConfig) {
        return RolesPermissionsApiFp(this.configuration).createActionPasscode(createActionPasscodeDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} businessId 
     * @param {CreateRoleDto} createRoleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesPermissionsApi
     */
    public createRole(businessId: number, createRoleDto: CreateRoleDto, options?: AxiosRequestConfig) {
        return RolesPermissionsApiFp(this.configuration).createRole(businessId, createRoleDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShiftTrackingApi - axios parameter creator
 * @export
 */
export const ShiftTrackingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} businessId 
         * @param {ClockInRequestDto} clockInRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clockIn: async (businessId: string, clockInRequestDto: ClockInRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('clockIn', 'businessId', businessId)
            // verify required parameter 'clockInRequestDto' is not null or undefined
            assertParamExists('clockIn', 'clockInRequestDto', clockInRequestDto)
            const localVarPath = `/api/v1/businesses/{businessId}/shifts/clock-in`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clockInRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId 
         * @param {ClockOutRequestDto} clockOutRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clockOut: async (businessId: string, clockOutRequestDto: ClockOutRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('clockOut', 'businessId', businessId)
            // verify required parameter 'clockOutRequestDto' is not null or undefined
            assertParamExists('clockOut', 'clockOutRequestDto', clockOutRequestDto)
            const localVarPath = `/api/v1/businesses/{businessId}/shifts/clock-out`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clockOutRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId 
         * @param {number} [page] 
         * @param {number} [limit] Items per page (max 100).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShifts: async (businessId: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getShifts', 'businessId', businessId)
            const localVarPath = `/api/v1/businesses/{businessId}/shifts`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId 
         * @param {string} employeeId The ID of the employee to check.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTodayShift: async (businessId: string, employeeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getTodayShift', 'businessId', businessId)
            // verify required parameter 'employeeId' is not null or undefined
            assertParamExists('getTodayShift', 'employeeId', employeeId)
            const localVarPath = `/api/v1/businesses/{businessId}/shifts/today`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} businessId 
         * @param {UnlockTerminalDto} unlockTerminalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlock: async (businessId: string, unlockTerminalDto: UnlockTerminalDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('unlock', 'businessId', businessId)
            // verify required parameter 'unlockTerminalDto' is not null or undefined
            assertParamExists('unlock', 'unlockTerminalDto', unlockTerminalDto)
            const localVarPath = `/api/v1/businesses/{businessId}/shifts/unlock`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unlockTerminalDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShiftTrackingApi - functional programming interface
 * @export
 */
export const ShiftTrackingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShiftTrackingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} businessId 
         * @param {ClockInRequestDto} clockInRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clockIn(businessId: string, clockInRequestDto: ClockInRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeShiftResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clockIn(businessId, clockInRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId 
         * @param {ClockOutRequestDto} clockOutRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clockOut(businessId: string, clockOutRequestDto: ClockOutRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeShiftResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clockOut(businessId, clockOutRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId 
         * @param {number} [page] 
         * @param {number} [limit] Items per page (max 100).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShifts(businessId: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShifts(businessId, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId 
         * @param {string} employeeId The ID of the employee to check.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTodayShift(businessId: string, employeeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TodayShiftResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTodayShift(businessId, employeeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} businessId 
         * @param {UnlockTerminalDto} unlockTerminalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlock(businessId: string, unlockTerminalDto: UnlockTerminalDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeSessionResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlock(businessId, unlockTerminalDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShiftTrackingApi - factory interface
 * @export
 */
export const ShiftTrackingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShiftTrackingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} businessId 
         * @param {ClockInRequestDto} clockInRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clockIn(businessId: string, clockInRequestDto: ClockInRequestDto, options?: any): AxiosPromise<EmployeeShiftResponseDto> {
            return localVarFp.clockIn(businessId, clockInRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId 
         * @param {ClockOutRequestDto} clockOutRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clockOut(businessId: string, clockOutRequestDto: ClockOutRequestDto, options?: any): AxiosPromise<EmployeeShiftResponseDto> {
            return localVarFp.clockOut(businessId, clockOutRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId 
         * @param {number} [page] 
         * @param {number} [limit] Items per page (max 100).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShifts(businessId: string, page?: number, limit?: number, options?: any): AxiosPromise<PaginatedResponseDto> {
            return localVarFp.getShifts(businessId, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId 
         * @param {string} employeeId The ID of the employee to check.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTodayShift(businessId: string, employeeId: string, options?: any): AxiosPromise<TodayShiftResponseDto> {
            return localVarFp.getTodayShift(businessId, employeeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} businessId 
         * @param {UnlockTerminalDto} unlockTerminalDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlock(businessId: string, unlockTerminalDto: UnlockTerminalDto, options?: any): AxiosPromise<EmployeeSessionResponseDto> {
            return localVarFp.unlock(businessId, unlockTerminalDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShiftTrackingApi - interface
 * @export
 * @interface ShiftTrackingApi
 */
export interface ShiftTrackingApiInterface {
    /**
     * 
     * @param {string} businessId 
     * @param {ClockInRequestDto} clockInRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShiftTrackingApiInterface
     */
    clockIn(businessId: string, clockInRequestDto: ClockInRequestDto, options?: AxiosRequestConfig): AxiosPromise<EmployeeShiftResponseDto>;

    /**
     * 
     * @param {string} businessId 
     * @param {ClockOutRequestDto} clockOutRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShiftTrackingApiInterface
     */
    clockOut(businessId: string, clockOutRequestDto: ClockOutRequestDto, options?: AxiosRequestConfig): AxiosPromise<EmployeeShiftResponseDto>;

    /**
     * 
     * @param {string} businessId 
     * @param {number} [page] 
     * @param {number} [limit] Items per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShiftTrackingApiInterface
     */
    getShifts(businessId: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedResponseDto>;

    /**
     * 
     * @param {string} businessId 
     * @param {string} employeeId The ID of the employee to check.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShiftTrackingApiInterface
     */
    getTodayShift(businessId: string, employeeId: string, options?: AxiosRequestConfig): AxiosPromise<TodayShiftResponseDto>;

    /**
     * 
     * @param {string} businessId 
     * @param {UnlockTerminalDto} unlockTerminalDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShiftTrackingApiInterface
     */
    unlock(businessId: string, unlockTerminalDto: UnlockTerminalDto, options?: AxiosRequestConfig): AxiosPromise<EmployeeSessionResponseDto>;

}

/**
 * ShiftTrackingApi - object-oriented interface
 * @export
 * @class ShiftTrackingApi
 * @extends {BaseAPI}
 */
export class ShiftTrackingApi extends BaseAPI implements ShiftTrackingApiInterface {
    /**
     * 
     * @param {string} businessId 
     * @param {ClockInRequestDto} clockInRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShiftTrackingApi
     */
    public clockIn(businessId: string, clockInRequestDto: ClockInRequestDto, options?: AxiosRequestConfig) {
        return ShiftTrackingApiFp(this.configuration).clockIn(businessId, clockInRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId 
     * @param {ClockOutRequestDto} clockOutRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShiftTrackingApi
     */
    public clockOut(businessId: string, clockOutRequestDto: ClockOutRequestDto, options?: AxiosRequestConfig) {
        return ShiftTrackingApiFp(this.configuration).clockOut(businessId, clockOutRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId 
     * @param {number} [page] 
     * @param {number} [limit] Items per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShiftTrackingApi
     */
    public getShifts(businessId: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return ShiftTrackingApiFp(this.configuration).getShifts(businessId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId 
     * @param {string} employeeId The ID of the employee to check.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShiftTrackingApi
     */
    public getTodayShift(businessId: string, employeeId: string, options?: AxiosRequestConfig) {
        return ShiftTrackingApiFp(this.configuration).getTodayShift(businessId, employeeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} businessId 
     * @param {UnlockTerminalDto} unlockTerminalDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShiftTrackingApi
     */
    public unlock(businessId: string, unlockTerminalDto: UnlockTerminalDto, options?: AxiosRequestConfig) {
        return ShiftTrackingApiFp(this.configuration).unlock(businessId, unlockTerminalDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StationsApi - axios parameter creator
 * @export
 */
export const StationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateStation: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/station/deactivate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStation: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/station`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SyncStationDto} syncStationDto Sync station data from frontend tablet to backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncStation: async (syncStationDto: SyncStationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'syncStationDto' is not null or undefined
            assertParamExists('syncStation', 'syncStationDto', syncStationDto)
            const localVarPath = `/api/v1/station/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncStationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SyncTerminalDto} syncTerminalDto Connect payment terminal to station
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncTerminal: async (syncTerminalDto: SyncTerminalDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'syncTerminalDto' is not null or undefined
            assertParamExists('syncTerminal', 'syncTerminalDto', syncTerminalDto)
            const localVarPath = `/api/v1/station/terminal/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncTerminalDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StationsApi - functional programming interface
 * @export
 */
export const StationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateStation(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateStation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStation(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStationResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SyncStationDto} syncStationDto Sync station data from frontend tablet to backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncStation(syncStationDto: SyncStationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StationSyncResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncStation(syncStationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SyncTerminalDto} syncTerminalDto Connect payment terminal to station
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncTerminal(syncTerminalDto: SyncTerminalDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StationSyncResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncTerminal(syncTerminalDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StationsApi - factory interface
 * @export
 */
export const StationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StationsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateStation(options?: any): AxiosPromise<void> {
            return localVarFp.deactivateStation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStation(options?: any): AxiosPromise<GetStationResponseDto> {
            return localVarFp.getStation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SyncStationDto} syncStationDto Sync station data from frontend tablet to backend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncStation(syncStationDto: SyncStationDto, options?: any): AxiosPromise<StationSyncResponseDto> {
            return localVarFp.syncStation(syncStationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SyncTerminalDto} syncTerminalDto Connect payment terminal to station
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncTerminal(syncTerminalDto: SyncTerminalDto, options?: any): AxiosPromise<StationSyncResponseDto> {
            return localVarFp.syncTerminal(syncTerminalDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StationsApi - interface
 * @export
 * @interface StationsApi
 */
export interface StationsApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StationsApiInterface
     */
    deactivateStation(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StationsApiInterface
     */
    getStation(options?: AxiosRequestConfig): AxiosPromise<GetStationResponseDto>;

    /**
     * 
     * @param {SyncStationDto} syncStationDto Sync station data from frontend tablet to backend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StationsApiInterface
     */
    syncStation(syncStationDto: SyncStationDto, options?: AxiosRequestConfig): AxiosPromise<StationSyncResponseDto>;

    /**
     * 
     * @param {SyncTerminalDto} syncTerminalDto Connect payment terminal to station
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StationsApiInterface
     */
    syncTerminal(syncTerminalDto: SyncTerminalDto, options?: AxiosRequestConfig): AxiosPromise<StationSyncResponseDto>;

}

/**
 * StationsApi - object-oriented interface
 * @export
 * @class StationsApi
 * @extends {BaseAPI}
 */
export class StationsApi extends BaseAPI implements StationsApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StationsApi
     */
    public deactivateStation(options?: AxiosRequestConfig) {
        return StationsApiFp(this.configuration).deactivateStation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StationsApi
     */
    public getStation(options?: AxiosRequestConfig) {
        return StationsApiFp(this.configuration).getStation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SyncStationDto} syncStationDto Sync station data from frontend tablet to backend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StationsApi
     */
    public syncStation(syncStationDto: SyncStationDto, options?: AxiosRequestConfig) {
        return StationsApiFp(this.configuration).syncStation(syncStationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SyncTerminalDto} syncTerminalDto Connect payment terminal to station
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StationsApi
     */
    public syncTerminal(syncTerminalDto: SyncTerminalDto, options?: AxiosRequestConfig) {
        return StationsApiFp(this.configuration).syncTerminal(syncTerminalDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TerminalApi - axios parameter creator
 * @export
 */
export const TerminalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Scan for available terminals on the network for the specified provider and business.
         * @summary Discover available payment terminals
         * @param {DiscoverTerminalDto} discoverTerminalDto Discover available payment terminals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverTerminal: async (discoverTerminalDto: DiscoverTerminalDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'discoverTerminalDto' is not null or undefined
            assertParamExists('discoverTerminal', 'discoverTerminalDto', discoverTerminalDto)
            const localVarPath = `/api/v1/terminal/discover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(discoverTerminalDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} businessId The id of the business
         * @param {PaymentProvider} provider The payment gateway or hardware provider handling the transaction.
         * @param {string} terminalId The unique hardware identifier of the physical terminal mapped to this kiosk.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerminalStatus: async (businessId: number, provider: PaymentProvider, terminalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getTerminalStatus', 'businessId', businessId)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('getTerminalStatus', 'provider', provider)
            // verify required parameter 'terminalId' is not null or undefined
            assertParamExists('getTerminalStatus', 'terminalId', terminalId)
            const localVarPath = `/api/v1/terminal/status/{businessId}`
                .replace(`{${"businessId"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (terminalId !== undefined) {
                localVarQueryParameter['terminalId'] = terminalId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TerminalApi - functional programming interface
 * @export
 */
export const TerminalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TerminalApiAxiosParamCreator(configuration)
    return {
        /**
         * Scan for available terminals on the network for the specified provider and business.
         * @summary Discover available payment terminals
         * @param {DiscoverTerminalDto} discoverTerminalDto Discover available payment terminals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discoverTerminal(discoverTerminalDto: DiscoverTerminalDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentTerminalDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discoverTerminal(discoverTerminalDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} businessId The id of the business
         * @param {PaymentProvider} provider The payment gateway or hardware provider handling the transaction.
         * @param {string} terminalId The unique hardware identifier of the physical terminal mapped to this kiosk.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTerminalStatus(businessId: number, provider: PaymentProvider, terminalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTerminalStatus(businessId, provider, terminalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TerminalApi - factory interface
 * @export
 */
export const TerminalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TerminalApiFp(configuration)
    return {
        /**
         * Scan for available terminals on the network for the specified provider and business.
         * @summary Discover available payment terminals
         * @param {DiscoverTerminalDto} discoverTerminalDto Discover available payment terminals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverTerminal(discoverTerminalDto: DiscoverTerminalDto, options?: any): AxiosPromise<Array<PaymentTerminalDto>> {
            return localVarFp.discoverTerminal(discoverTerminalDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} businessId The id of the business
         * @param {PaymentProvider} provider The payment gateway or hardware provider handling the transaction.
         * @param {string} terminalId The unique hardware identifier of the physical terminal mapped to this kiosk.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerminalStatus(businessId: number, provider: PaymentProvider, terminalId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getTerminalStatus(businessId, provider, terminalId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TerminalApi - interface
 * @export
 * @interface TerminalApi
 */
export interface TerminalApiInterface {
    /**
     * Scan for available terminals on the network for the specified provider and business.
     * @summary Discover available payment terminals
     * @param {DiscoverTerminalDto} discoverTerminalDto Discover available payment terminals
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalApiInterface
     */
    discoverTerminal(discoverTerminalDto: DiscoverTerminalDto, options?: AxiosRequestConfig): AxiosPromise<Array<PaymentTerminalDto>>;

    /**
     * 
     * @param {number} businessId The id of the business
     * @param {PaymentProvider} provider The payment gateway or hardware provider handling the transaction.
     * @param {string} terminalId The unique hardware identifier of the physical terminal mapped to this kiosk.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalApiInterface
     */
    getTerminalStatus(businessId: number, provider: PaymentProvider, terminalId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * TerminalApi - object-oriented interface
 * @export
 * @class TerminalApi
 * @extends {BaseAPI}
 */
export class TerminalApi extends BaseAPI implements TerminalApiInterface {
    /**
     * Scan for available terminals on the network for the specified provider and business.
     * @summary Discover available payment terminals
     * @param {DiscoverTerminalDto} discoverTerminalDto Discover available payment terminals
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalApi
     */
    public discoverTerminal(discoverTerminalDto: DiscoverTerminalDto, options?: AxiosRequestConfig) {
        return TerminalApiFp(this.configuration).discoverTerminal(discoverTerminalDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} businessId The id of the business
     * @param {PaymentProvider} provider The payment gateway or hardware provider handling the transaction.
     * @param {string} terminalId The unique hardware identifier of the physical terminal mapped to this kiosk.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalApi
     */
    public getTerminalStatus(businessId: number, provider: PaymentProvider, terminalId: string, options?: AxiosRequestConfig) {
        return TerminalApiFp(this.configuration).getTerminalStatus(businessId, provider, terminalId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve user Business information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBusiness: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/business`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve user Business information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserBusiness(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BusinessInfoResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBusiness(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserInfoResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve user Business information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBusiness(options?: any): AxiosPromise<Array<BusinessInfoResponseDto>> {
            return localVarFp.getUserBusiness(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options?: any): AxiosPromise<GetUserInfoResponseDto> {
            return localVarFp.getUserInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     * 
     * @summary Retrieve user Business information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserBusiness(options?: AxiosRequestConfig): AxiosPromise<Array<BusinessInfoResponseDto>>;

    /**
     * 
     * @summary Retrieve user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserInfo(options?: AxiosRequestConfig): AxiosPromise<GetUserInfoResponseDto>;

}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
    /**
     * 
     * @summary Retrieve user Business information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserBusiness(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserBusiness(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserInfo(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Filter user information with phone number
         * @param {UserValidation} userValidation User body data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userValidation: UserValidation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userValidation' is not null or undefined
            assertParamExists('getUser', 'userValidation', userValidation)
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userValidation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add credit points to user wallet
         * @param {number} userId 
         * @param {number} walletId 
         * @param {RewardPointPayload} rewardPointPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRewardPoints: async (userId: number, walletId: number, rewardPointPayload: RewardPointPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserRewardPoints', 'userId', userId)
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('updateUserRewardPoints', 'walletId', walletId)
            // verify required parameter 'rewardPointPayload' is not null or undefined
            assertParamExists('updateUserRewardPoints', 'rewardPointPayload', rewardPointPayload)
            const localVarPath = `/api/v1/users/{userId}/wallets/{walletId}/events`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rewardPointPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Filter user information with phone number
         * @param {UserValidation} userValidation User body data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userValidation: UserValidation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LoyaltyUserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userValidation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add credit points to user wallet
         * @param {number} userId 
         * @param {number} walletId 
         * @param {RewardPointPayload} rewardPointPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserRewardPoints(userId: number, walletId: number, rewardPointPayload: RewardPointPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserRewardPoints(userId, walletId, rewardPointPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Filter user information with phone number
         * @param {UserValidation} userValidation User body data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userValidation: UserValidation, options?: any): AxiosPromise<Array<LoyaltyUserDto>> {
            return localVarFp.getUser(userValidation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add credit points to user wallet
         * @param {number} userId 
         * @param {number} walletId 
         * @param {RewardPointPayload} rewardPointPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRewardPoints(userId: number, walletId: number, rewardPointPayload: RewardPointPayload, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserRewardPoints(userId, walletId, rewardPointPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * 
     * @summary Filter user information with phone number
     * @param {UserValidation} userValidation User body data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getUser(userValidation: UserValidation, options?: AxiosRequestConfig): AxiosPromise<Array<LoyaltyUserDto>>;

    /**
     * 
     * @summary Add credit points to user wallet
     * @param {number} userId 
     * @param {number} walletId 
     * @param {RewardPointPayload} rewardPointPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    updateUserRewardPoints(userId: number, walletId: number, rewardPointPayload: RewardPointPayload, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * 
     * @summary Filter user information with phone number
     * @param {UserValidation} userValidation User body data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(userValidation: UserValidation, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(userValidation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add credit points to user wallet
     * @param {number} userId 
     * @param {number} walletId 
     * @param {RewardPointPayload} rewardPointPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserRewardPoints(userId: number, walletId: number, rewardPointPayload: RewardPointPayload, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserRewardPoints(userId, walletId, rewardPointPayload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleAssignmentWebhook: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/add-employee-assignments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleBusinessWebhook: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/add-business`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OrderUpdateDto} orderUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleFoodoraEvent: async (orderUpdateDto: OrderUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderUpdateDto' is not null or undefined
            assertParamExists('handleFoodoraEvent', 'orderUpdateDto', orderUpdateDto)
            const localVarPath = `/api/webhook/order/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Handle Supabase employee sync webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleLoadEmployee: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/load-employee`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleNetsEvents: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/nets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleNetsRefundEvents: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/nets/refund`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Handle preorder reminder (triggered by scheduler)
         * @param {PreOrderReminderDto} preOrderReminderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handlePreorderReminder: async (preOrderReminderDto: PreOrderReminderDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'preOrderReminderDto' is not null or undefined
            assertParamExists('handlePreorderReminder', 'preOrderReminderDto', preOrderReminderDto)
            const localVarPath = `/api/webhook/preorder-reminder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(preOrderReminderDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRoleWebhook: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/add-roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleShiftWebhook: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/add-employee-shifts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Handle Viva payment webhook events
         * @param {VivaWebhookPayloadDto} vivaWebhookPayloadDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleVivaEvents: async (vivaWebhookPayloadDto: VivaWebhookPayloadDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vivaWebhookPayloadDto' is not null or undefined
            assertParamExists('handleVivaEvents', 'vivaWebhookPayloadDto', vivaWebhookPayloadDto)
            const localVarPath = `/api/webhook/viva/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vivaWebhookPayloadDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleWebhook: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/ship-day`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleWoltDriveEvent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/wolt-drive/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} country 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleWoltDriveEventByCountry: async (country: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('handleWoltDriveEventByCountry', 'country', country)
            const localVarPath = `/api/webhook/wolt-drive/{country}/event`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWoltProduct: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/wolt/product/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyVivaWebhook: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/viva/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleAssignmentWebhook(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleAssignmentWebhook(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleBusinessWebhook(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleBusinessWebhook(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OrderUpdateDto} orderUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleFoodoraEvent(orderUpdateDto: OrderUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleFoodoraEvent(orderUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Handle Supabase employee sync webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleLoadEmployee(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleLoadEmployee(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleNetsEvents(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleNetsEvents(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleNetsRefundEvents(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleNetsRefundEvents(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Handle preorder reminder (triggered by scheduler)
         * @param {PreOrderReminderDto} preOrderReminderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handlePreorderReminder(preOrderReminderDto: PreOrderReminderDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handlePreorderReminder(preOrderReminderDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleRoleWebhook(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleRoleWebhook(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleShiftWebhook(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleShiftWebhook(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Handle Viva payment webhook events
         * @param {VivaWebhookPayloadDto} vivaWebhookPayloadDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleVivaEvents(vivaWebhookPayloadDto: VivaWebhookPayloadDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleVivaEvents(vivaWebhookPayloadDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleWebhook(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleWebhook(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleWoltDriveEvent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleWoltDriveEvent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} country 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleWoltDriveEventByCountry(country: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleWoltDriveEventByCountry(country, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWoltProduct(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWoltProduct(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyVivaWebhook(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyVivaWebhook(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleAssignmentWebhook(options?: any): AxiosPromise<void> {
            return localVarFp.handleAssignmentWebhook(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleBusinessWebhook(options?: any): AxiosPromise<void> {
            return localVarFp.handleBusinessWebhook(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OrderUpdateDto} orderUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleFoodoraEvent(orderUpdateDto: OrderUpdateDto, options?: any): AxiosPromise<void> {
            return localVarFp.handleFoodoraEvent(orderUpdateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Handle Supabase employee sync webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleLoadEmployee(options?: any): AxiosPromise<void> {
            return localVarFp.handleLoadEmployee(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleNetsEvents(options?: any): AxiosPromise<void> {
            return localVarFp.handleNetsEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleNetsRefundEvents(options?: any): AxiosPromise<void> {
            return localVarFp.handleNetsRefundEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Handle preorder reminder (triggered by scheduler)
         * @param {PreOrderReminderDto} preOrderReminderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handlePreorderReminder(preOrderReminderDto: PreOrderReminderDto, options?: any): AxiosPromise<void> {
            return localVarFp.handlePreorderReminder(preOrderReminderDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRoleWebhook(options?: any): AxiosPromise<void> {
            return localVarFp.handleRoleWebhook(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleShiftWebhook(options?: any): AxiosPromise<void> {
            return localVarFp.handleShiftWebhook(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Handle Viva payment webhook events
         * @param {VivaWebhookPayloadDto} vivaWebhookPayloadDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleVivaEvents(vivaWebhookPayloadDto: VivaWebhookPayloadDto, options?: any): AxiosPromise<void> {
            return localVarFp.handleVivaEvents(vivaWebhookPayloadDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleWebhook(options?: any): AxiosPromise<void> {
            return localVarFp.handleWebhook(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleWoltDriveEvent(options?: any): AxiosPromise<void> {
            return localVarFp.handleWoltDriveEvent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} country 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleWoltDriveEventByCountry(country: string, options?: any): AxiosPromise<void> {
            return localVarFp.handleWoltDriveEventByCountry(country, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWoltProduct(options?: any): AxiosPromise<void> {
            return localVarFp.updateWoltProduct(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyVivaWebhook(options?: any): AxiosPromise<void> {
            return localVarFp.verifyVivaWebhook(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - interface
 * @export
 * @interface WebhookApi
 */
export interface WebhookApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    handleAssignmentWebhook(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    handleBusinessWebhook(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {OrderUpdateDto} orderUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    handleFoodoraEvent(orderUpdateDto: OrderUpdateDto, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Handle Supabase employee sync webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    handleLoadEmployee(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    handleNetsEvents(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    handleNetsRefundEvents(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Handle preorder reminder (triggered by scheduler)
     * @param {PreOrderReminderDto} preOrderReminderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    handlePreorderReminder(preOrderReminderDto: PreOrderReminderDto, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    handleRoleWebhook(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    handleShiftWebhook(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Handle Viva payment webhook events
     * @param {VivaWebhookPayloadDto} vivaWebhookPayloadDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    handleVivaEvents(vivaWebhookPayloadDto: VivaWebhookPayloadDto, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    handleWebhook(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    handleWoltDriveEvent(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} country 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    handleWoltDriveEventByCountry(country: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    updateWoltProduct(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    verifyVivaWebhook(options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI implements WebhookApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public handleAssignmentWebhook(options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).handleAssignmentWebhook(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public handleBusinessWebhook(options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).handleBusinessWebhook(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OrderUpdateDto} orderUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public handleFoodoraEvent(orderUpdateDto: OrderUpdateDto, options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).handleFoodoraEvent(orderUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Handle Supabase employee sync webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public handleLoadEmployee(options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).handleLoadEmployee(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public handleNetsEvents(options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).handleNetsEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public handleNetsRefundEvents(options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).handleNetsRefundEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Handle preorder reminder (triggered by scheduler)
     * @param {PreOrderReminderDto} preOrderReminderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public handlePreorderReminder(preOrderReminderDto: PreOrderReminderDto, options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).handlePreorderReminder(preOrderReminderDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public handleRoleWebhook(options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).handleRoleWebhook(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public handleShiftWebhook(options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).handleShiftWebhook(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Handle Viva payment webhook events
     * @param {VivaWebhookPayloadDto} vivaWebhookPayloadDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public handleVivaEvents(vivaWebhookPayloadDto: VivaWebhookPayloadDto, options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).handleVivaEvents(vivaWebhookPayloadDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public handleWebhook(options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).handleWebhook(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public handleWoltDriveEvent(options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).handleWoltDriveEvent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} country 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public handleWoltDriveEventByCountry(country: string, options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).handleWoltDriveEventByCountry(country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public updateWoltProduct(options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).updateWoltProduct(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public verifyVivaWebhook(options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).verifyVivaWebhook(options).then((request) => request(this.axios, this.basePath));
    }
}


